<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Lightning Network Onion Routing: Sphinx Packet Construction | Elle Mouton</title><meta name=keywords content><meta name=description content="Diving into all things BOLT-04"><meta name=author content><link rel=canonical href=https://www.ellemouton.com/drafts/sphinx/><link crossorigin=anonymous href=/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe+FVUFzPh7U=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://www.ellemouton.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.ellemouton.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.ellemouton.com/favicon-32x32.png><link rel=apple-touch-icon href=https://www.ellemouton.com/apple-touch-icon.png><link rel=mask-icon href=https://www.ellemouton.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-PMLX8P6J9S"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-PMLX8P6J9S',{anonymize_ip:!1})}</script><meta property="og:title" content="Lightning Network Onion Routing: Sphinx Packet Construction"><meta property="og:description" content="Diving into all things BOLT-04"><meta property="og:type" content="article"><meta property="og:url" content="https://www.ellemouton.com/drafts/sphinx/"><meta property="og:image" content="https://www.ellemouton.com/onion/cover.png"><meta property="article:section" content="drafts"><meta property="article:published_time" content="2024-03-22T00:00:00+00:00"><meta property="article:modified_time" content="2024-03-22T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.ellemouton.com/onion/cover.png"><meta name=twitter:title content="Lightning Network Onion Routing: Sphinx Packet Construction"><meta name=twitter:description content="Diving into all things BOLT-04"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Drafts","item":"https://www.ellemouton.com/drafts/"},{"@type":"ListItem","position":3,"name":"Lightning Network Onion Routing: Sphinx Packet Construction","item":"https://www.ellemouton.com/drafts/sphinx/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Lightning Network Onion Routing: Sphinx Packet Construction","name":"Lightning Network Onion Routing: Sphinx Packet Construction","description":"Diving into all things BOLT-04","keywords":[],"articleBody":"In the previous post, we covered what data we need to communicate to each node on a route. Now we will dive into exactly how we package up this data so that we leak as little information about the payment as possible to hops along the path. This is done using the Sphinx packet construction which ensures a few things:\n Each hop on the path will only know the previous hop and the next hop on the path. Each hop is only able to decrypt the payload that is meant for it.  In this article, we will work through exactly how this is done. Before we dive into the good stuff, however, we first need to cover a few basics.\nDiffie-Hellman Key Exchange Diffie-Hellman key exchange is a simple way for two private key owning entities to derive a secret shared key between them. All that the two parties need to do is exchange public keys.\nThe diagram above aims to show how this can be done between two parties who own keys A and B respectively. The private keys a and b remain private and yet the two parties are able to derive a shared secret key. To prove to yourself that this is indeed a shared secret key, ask yourself if a third party with private key q and public key Q could derive the shared secret between A and B if Q had knowledge of both the A and B public keys. You should be able to see that the answer is no.\nIn Sphinx packet construction, the onion packet creator, Alice, will use a shared secret key between a public key that she owns and the public key of each node on the path in order to encrypt data for the relevant hop.\nOnce a hop has derived the shared secret with Alice, they can then use that shared secret along with some constants (rho, mu, pad, um and ammag) to derive other keys or byte streams:\nEphemeral Keys Each hop on the path will need to be told what the public key of the sender is so that they can derive the shared secret with the sender and decrypt the packet. However, sharing the node level public key of the sender, A, with each hop is a bit of a privacy leak. Everyone on the path will know just how much Alice is spending on coffee. To prevent this, Alice will instead use an ephemeral key with each hop. This means that she will have a new private and public key pair for each hop on the path and will use that pair to derive the shared secret with the hop’s public key. After the payment is complete, Alice can discard this ephemeral key pair.\nNaively, Alice could derive a completely new and random key pair for each hop along the path but that means she would need to persist each private key while the payment completes, and she would need to include the ephemeral public key for each hop in the onion packet for that hop. This uses up quite a bit of onion packet space.\nInstead, what she will do is derive a single ephemeral key pair. The private key of this pair is called the session_key. Alice uses this key to derive all the other ephemeral keys along the path. What is cool about this is that she only has to communicate the very first public ephemeral key to the first hop. That hop will then be able to use that ephemeral key along with its shared secret with Alice to derive the ephemeral key to pass on to the following hop. This should become more clear with the long-running example later.\nHMAC A Hash-Based Message Authentication Code (or HMAC) is a message authentication technique. It is a cryptographic hash function that takes in a message to produce the code over along with a secret key. The code is only producible and verifiable by parties that have knowledge of the secret key.\nHMACs will be used throughout the sphinx packet construction so that each hop can verify that the contents of the packet (the message) has not been tampered with. Since the HMAC can only be derived by the sender, Alice, each HMAC for each hop must be present in the onion from the beginning. This will become more clear with the example.\nXOR The XOR (or Exclusive-OR) operation is a bitwise operation where the result is 1 if one and only one of the two bits being operated on is 1. In other words, the result of the XOR operation is only 1 if the two bits being operated on differ. The XOR truth table can be seen below. It shows the result (C) after performing the XOR operation on two bits, A and B, for each of the various combinations.\nThe next diagram demonstrates an interesting property of XOR that we will be making use of in the sphinx packet construction later in this post. It shows that taking the result of the above operation, C, and XORing it with A produces B. Similarly, the XOR of C and B produce A.\nTo really nail down the idea, let’s look at some examples: In example 1 below, you can see that if you XOR a packet with itself, it produces a zero byte array. So XORing something with itself essentially destroys information. Example 2 shows that if you take a packet and XOR it with a zero byte array of the same length, then it produces the original packet.\nOk let’s see some more useful and interesting examples:\nExample 3 shows that if you take a packet and XOR it with a random byte stream, then you get the encrypted form of the packet. Example 4 shows that if you then take that encrypted packet and once again XOR it with the same byte stream, then you are once again left with the clear text. The sphinx packet construction makes heavy use of XOR for encrypting a clear text packet using a pseudo random byte stream.\nSender preparation The example used in this post continues where the last post ended off. Basically we have the following route where Alice is the sender and Dave is the recipient. Alice essentially just needs to deliver a payload to each hop without leaking too much data about the route.\nAlice has a set of payloads that she wants to communicate to each hop. When the payloads are put into the onion packet, they are prefixed with a length and postfixed with a 32 HMAC.\nAlice now goes ahead and generates a session_key and uses this to derive the chain of ephemeral keys. Note that “bf” here stands for “blinding factor”. A blinding factor is used to tweak a private key or public key.\nI mentioned before that we don’t want hops on the route to have an idea of where on the route they are. To achieve this, the onion packet given to each hop will be the exact same size (1300 bytes) and each hop will only be able to read the payload meant for it. The rest of the onion will look like a random stream of bytes to that hop.\nFirst attempt at wrapping the onion. We are going to run through the onion wrapping process twice. During the first pass we will get an initial feel for it and we will see why certain complexities need to be added on the second pass.\nAlice needs to wrap the onion back to front: we first add the payload for Dave, encrypt that and then add the payload for Charlie and so on. The packet we end up giving to Bob will be a fully wrapped onion. Each hop will peel one layer of the onion.\nFirst, Alice generates a 1300 byte pseudo random stream using the session key. This is knows as the “padding”.\nWrapping for Dave She then slides over the padding to make room for Dave’s payload. The HMAC that is appended to Dave’s payload is not actually a real HMAC. Since Dave is the last hop, this onion doesn’t need to be passed onto any other hops and so this HMAC is made to be an empty set of zero bytes which serves as a signal to Dave that he is the final hop on the route.\nThe packet needs to remain 1300 bytes long and so that trailing section of the padding is chopped off.\nAlice then uses her shared key with Dave, $ss_{AD}$, along with the rho constant to derive a pseudo random stream of 1300 bytes. This stream is XOR’d with the onion packet which produces an encrypted packet that only Dave would be able to decrypt. Alice then uses $ss_{AD}$, the mu constant and the packet contents at this point to calculate an HMAC for this packet. Dave will later verify that this HMAC is equal to the HMAC that he produces over the packet when he receives.\nWrapping for Charlie Next, Alice will add Charlie’s payload. Note that his payload will include the $HMAC_1$ calculated above. Once again, the packet length is kept to 1300 bytes.\nSimilarly to the encryption for Dave, Alice now uses her shared secret with Charlie, $ss_{AC}$ to derive a pseudo random byte stream which she XORs with the onion packet. This produces the encrypted packet destined for Charlie. Once again, Alice calculates an appropriate HMAC for this payload.\nWrapping for Bob Ok last layer! Finally, Alice slides Bob’s payload in at the start of the packet and clips off the rest so that it is still a 1300 byte packet. She then XORs this with a byte stream derived from her shared secret with Bob, $ss_{AB}$, and then finally calculates the HMAC for this packet: $HMAC_3$.\nBefore sending this packet to Bob, Alice wraps it with some required information: The packet version byte, Alice’s first ephemeral key $E_{AB}$ and finally the HMAC ($HMAC_3$) for the final onion packet.\nAlice now hands this packet to Bob.\nPeeling the Onion Bob peels a layer The first thing that Bob will do is to derive the shared key between him and Alice using the ephemeral key, $E_{AB}$. While he is at it, he can also already compute the _next_ ephemeral key that he will need to communicate with Charlie.\nThen, Bob needs to validate the HMAC. He does this by using the derived shared secret with Alice, $ss_{AB}$, along with the mu constant and the onion packet contents to compute expected HMAC for the payload. The HMAC is valid if it is equal to the one he received from Alice that was appended to the end of the packet.\nThis HMAC should be valid because you can see that the package contents in the above image is the same as the package contents that Alice used to create this HMAC.\nGreat! Now Bob is ready to do some decrypting. Since he was able to derive the secret key $ss_{AB}$, he is able to derive the same pseudo random byte stream that Alice used to encrypt his payload. He uses this to XOR the payload which decrypts it. Oh, but wait! remember that Bob will remove his payload before passing it on to Charlie… but the packet needs to remain 1300 bytes long, and he can’t just replace the empty space with zero bytes since the next hop will be able to glean some information about the length of the route and the length of Bob’s payload by looking at the number of zero bytes. So instead, before decrypting the payload, Bob first appends 1300 zero bytes to the encrypted payload, generates 2600 bytes of pseudo random byte stream and only then does the XOR decryption.\nNow that the decryption is complete, Bob removes his payload and chops up the packet to once again be 1300 bytes:\nAs Alice did for Bob, Bob now packages the onion nicely for Charlie by adding the Ephemeral key that Charlie will need along with the $HMAC_2$ that Alice provided Bob with in his payload.\nYou may have already picked up an issue here… take a moment here to see if you can spot the issue. It will become more clear when we dive into Charlie’s verification process in the next step. For now, let’s assume Bob hands this over to Charlie.\nCharlie peels a layer Charlie receives the packaged onion from Bob. The first thing is does is to use the ephemeral key $E_{AC}$ along with his own private key, c, to derive the shared secret between him and Alice. He then uses this to derive the ephemeral key for Dave too.\nThen, he checks to see if the HMAC is valid given the payload. Ok this is where the issue lies! If you scroll back to see the diagram showing the message that Alice used to create this HMAC, you will see that the packet looked different. But now we at least know what the packet should look like when Alice calculates the HMAC for Charlie.\nFor the sake of completion and so we can find out where else things might have gone wrong, let’s assume that Charlie continues the process.\nCharlie uses the shared secret key to decrypt the packet similarly to how Bob did it. He then can read his payload and reconstruct the packet for Dave.\nDave peels a layer Dave receives the packet and derives his shared secret key with Alice:\nHe then attempts to do the HMAC verification. Once again, this will fail since the packet contents does not match the packet contents that Alice used when creating the HMAC. But again, we now know what it should look like, and we will use this information on our second attempt.\nLet’s again assume that Dave continues and uses the shared secret to decrypt the packet.\nDave will see that the HMAC sent to him is a zero byte array. He therefore knows that he is the last hop on the path.\nSecond attempt at wrapping the onion. Ok so we’ve made some mistakes, but we have also learned some lessons. Now that we know what each packet needs to look like at the time of computing the HMACs, we can redo the onion wrapping process correctly.\nLet’s start by taking a look at the packet at the point Dave gets it (before decryption):\nThe difference between this packet and the one we originally used to create the HMAC is the end bit shown in the diagram above. Luckily we have kept track of which pseudo random byte streams and which sections of those byte streams are involved here. So all Alice needs to do at the start is to construct this section which is called the “filler”. The diagram below shows its construction:\nOk cool! Let’s try this again shall we?\nWrapping for Dave The initial padding generation remains the same:\nAgain we slide in Dave’s payload and encrypt it:\nHere is where things change! We know that before Alice uses Dave’s payload to compute the HMAC, she must first insert the filler.\nGreat! Now the HMAC that Charlie ends up receiving will in fact be valid for the payload he gets.\nWrapping for Charlie Alice then again slides in Charlie’s payload, encrypts it and then… do we need to cut out some bytes and replace them with a derived filler again? Well… no, it doesn’t seem that we do! Due to the properties of XOR, XORing the packets existing filler contents with the byte stream that Charlie uses to decrypt the payload, the resulting packet is actually equal to the packet that Charlie will receive! Therefore, nothing special needs to be done at this point. Alice can go ahead and calculate the HMAC as is.\nWrapping for Bob Finally, Alice adds Bob’s payload, encrypts the packet and computes the final HMAC.\nNotice that this final onion packet is identical to the one that we had at the end of the first pass we did (except of course that the HMACs are all correct now) and so the peeling of this packet will look exactly like the peeling of the first pass packet.\nErrors Compared to what we have already covered, understanding how errors are dealt with should be a breeze :)\nLet’s assume that when Charlie decodes the payload in the onion sent from Alice, he realises that she is asking him to forward an amount that would mean that he does not get the fee that he has advertised. Charlie will then want to fail the payment and so instead of passing the onion on to Dave, he instead constructs a failure message packet which will contain a message he wishes to send back to Alice telling her what went wrong. He may choose to pad this message too. He will use the shared secret he has with Alice, $ss_{AC}$ along with the um constant to produce an HMAC over the data. He will then use $ss_{AC}$ along with the ammag constant to produce a pseudo random bytes stream which he will then XOR with the failure message packet. He will then put this encrypted message in an update_fail_htlc message and send that back to Bob.\nBob will simply take his shared secret with Alice, $ss_{AB}$, produce another byte stream and re-encrypt the payload as is. He, too, will put this into an update_fail_htlc message and send it back to Alice.\nWhen Alice receives this message, she does not immediately know which hop produced the payload, but she does know in which order things would have been encrypted. So she starts decrypting by un-peeling Bob’s encryption layer. Once decrypted, she looks at the first 32 bytes of the payload (the size of an HMAC), computes the HMAC for the rest of the payload and checks if those two HMACs are equal. In this case, they will not be which means that Bob was not the erring node.\nShe then continues by peeling back Charlie’s encryption layer and then repeats the process of checking the HMAC. In this case, the HMACs will be equal and so Alice knows that Charlie is the source of the error, and so she can now read his erring reason from the failure message.\nOne little edge case One edge case to be aware of is where Charlie gets the onion packet from Bob but then is not able to successfully parse it. If Charlie cannot parse it, then he won’t know the ephemeral key to use to derive the shared secret with Alice. This means that he would not be able to encrypt a failure message packet. So in this case, Charlie will send Bob an update_fail_malformed_htlc message with some information about the type of error that occurred. When Bob receives this, he knows that he must do the initial encryption round for this error. He does this and then sends the packet back to Alice in an update_fail_htlc message.\nConclusion Well if you are still here - congrats! You now understand the complexities creating a Sphinx onion packet!\nAs always, if you think anything needs clarification or if you have any questions - leave a comment below. If there are corrections that you think should be made to the text, feel free to let me know or to open a pull request on the website’s GitHub page.\n","wordCount":"3237","inLanguage":"en","image":"https://www.ellemouton.com/onion/cover.png","datePublished":"2024-03-22T00:00:00Z","dateModified":"2024-03-22T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.ellemouton.com/drafts/sphinx/"},"publisher":{"@type":"Organization","name":"Elle Mouton","logo":{"@type":"ImageObject","url":"https://www.ellemouton.com/favicon.ico"}}}</script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:'\\[',right:'\\]',display:!0},{left:'$$',right:'$$',display:!0},{left:'\\(',right:'\\)',display:!1},{left:'$',right:'$',display:!1}],throwOnError:!1})})</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add('dark')</script><header class=header><nav class=nav><div class=logo><a href=https://www.ellemouton.com accesskey=h title="Elle Mouton (Alt + H)">Elle Mouton</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://www.ellemouton.com/archives title=Archive><span>Archive</span></a></li><li><a href=https://www.ellemouton.com/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Lightning Network Onion Routing: Sphinx Packet Construction</h1><div class=post-meta><span title="2024-03-22 00:00:00 +0000 UTC">March 22, 2024</span></div></header><figure class=entry-cover><img loading=lazy src=https://www.ellemouton.com/onion/cover.png alt></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#diffie-hellman-key-exchange aria-label="Diffie-Hellman Key Exchange">Diffie-Hellman Key Exchange</a></li><li><a href=#ephemeral-keys aria-label="Ephemeral Keys">Ephemeral Keys</a></li><li><a href=#hmac aria-label=HMAC>HMAC</a></li><li><a href=#xor aria-label=XOR>XOR</a></li><li><a href=#sender-preparation aria-label="Sender preparation">Sender preparation</a></li><li><a href=#first-attempt-at-wrapping-the-onion aria-label="First attempt at wrapping the onion.">First attempt at wrapping the onion.</a><ul><ul><li><a href=#wrapping-for-dave aria-label="Wrapping for Dave">Wrapping for Dave</a></li><li><a href=#wrapping-for-charlie aria-label="Wrapping for Charlie">Wrapping for Charlie</a></li><li><a href=#wrapping-for-bob aria-label="Wrapping for Bob">Wrapping for Bob</a></li></ul></ul></li><li><a href=#peeling-the-onion aria-label="Peeling the Onion">Peeling the Onion</a><ul><ul><li><a href=#bob-peels-a-layer aria-label="Bob peels a layer">Bob peels a layer</a></li><li><a href=#charlie-peels-a-layer aria-label="Charlie peels a layer">Charlie peels a layer</a></li><li><a href=#dave-peels-a-layer aria-label="Dave peels a layer">Dave peels a layer</a></li></ul></ul></li><li><a href=#second-attempt-at-wrapping-the-onion aria-label="Second attempt at wrapping the onion.">Second attempt at wrapping the onion.</a><ul><ul><li><a href=#wrapping-for-dave-1 aria-label="Wrapping for Dave">Wrapping for Dave</a></li><li><a href=#wrapping-for-charlie-1 aria-label="Wrapping for Charlie">Wrapping for Charlie</a></li><li><a href=#wrapping-for-bob-1 aria-label="Wrapping for Bob">Wrapping for Bob</a></li></ul></ul></li><li><a href=#errors aria-label=Errors>Errors</a><ul><ul><li><a href=#one-little-edge-case aria-label="One little edge case">One little edge case</a></li></ul></ul></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li></ul></div></details></div><div class=post-content><p>In the <a href=../../drafts/onion-routing-prelims>previous post</a>, we covered <em>what</em> data we need to
communicate to each node on a route. Now we will dive into exactly <em>how</em> we
package up this data so that we leak as little information about the payment as
possible to hops along the path. This is done using the <a href=https://github.com/lightning/bolts/blob/master/04-onion-routing.md>Sphinx</a> packet
construction which ensures a few things:</p><ol><li>Each hop on the path will only know the previous hop and the next hop on the
path.</li><li>Each hop is only able to decrypt the payload that is meant for it.</li></ol><p>In this article, we will work through exactly how this is done. Before we dive
into the good stuff, however, we first need to cover a few basics.</p><h1 id=diffie-hellman-key-exchange>Diffie-Hellman Key Exchange<a hidden class=anchor aria-hidden=true href=#diffie-hellman-key-exchange>#</a></h1><p><a href=https://www.techtarget.com/searchsecurity/definition/Diffie-Hellman-key-exchange>Diffie-Hellman key exchange</a> is a simple way for two private key owning
entities to derive a secret shared key between them. All that the two parties
need to do is exchange public keys.</p><p><img loading=lazy src=/onion/2-dhke.png#center alt></p><p>The diagram above aims to show how this can be done between two parties who own
keys <code>A</code> and <code>B</code> respectively. The private keys <code>a</code> and <code>b</code> remain private and
yet the two parties are able to derive a shared secret key. To prove to yourself
that this is indeed a shared secret key, ask yourself if a third party with
private key <code>q</code> and public key <code>Q</code> could derive the shared secret between <code>A</code>
and <code>B</code> if <code>Q</code> had knowledge of both the <code>A</code> and <code>B</code> public keys. You should be
able to see that the answer is no.</p><p>In Sphinx packet construction, the onion packet creator, Alice, will use a
shared secret key between a public key that she owns and the public key of each
node on the path in order to encrypt data for the relevant hop.</p><p>Once a hop has derived the shared secret with Alice, they can then use that
shared secret along with some constants (<code>rho</code>, <code>mu</code>, <code>pad</code>, <code>um</code> and <code>ammag</code>)
to derive other keys or byte streams:</p><p><img loading=lazy src=/onion/4-key_derivation.png#center alt></p><h1 id=ephemeral-keys>Ephemeral Keys<a hidden class=anchor aria-hidden=true href=#ephemeral-keys>#</a></h1><p>Each hop on the path will need to be told what the public key of the sender is
so that they can derive the shared secret with the sender and decrypt the
packet. However, sharing the node level public key of the sender, <code>A</code>, with
each hop is a bit of a privacy leak. Everyone on the path will know just how
much Alice is spending on coffee. To prevent this, Alice will instead use an
ephemeral key with each hop. This means that she will have a new private and
public key pair for each hop on the path and will use that pair to derive the
shared secret with the hop’s public key. After the payment is complete, Alice
can discard this ephemeral key pair.</p><p>Naively, Alice could derive a completely new and random key pair for each hop
along the path but that means she would need to persist each private key while
the payment completes, <em>and</em> she would need to include the ephemeral public key
for each hop in the onion packet for that hop. This uses up quite a bit of onion
packet space.</p><p>Instead, what she will do is derive a single ephemeral key pair. The private key
of this pair is called the <code>session_key</code>. Alice uses this key to derive all the
other ephemeral keys along the path. What is cool about this is that she only
has to communicate the very first public ephemeral key to the first hop. That
hop will then be able to use that ephemeral key along with its shared secret
with Alice to derive the ephemeral key to pass on to the following hop. This
should become more clear with the long-running example later.</p><h1 id=hmac>HMAC<a hidden class=anchor aria-hidden=true href=#hmac>#</a></h1><p>A <a href=https://en.wikipedia.org/wiki/HMAC>Hash-Based Message Authentication Code (or HMAC)</a> is a message
authentication technique. It is a cryptographic hash function that takes in a
message to produce the code over along with a secret key. The code is only
producible and verifiable by parties that have knowledge of the secret key.</p><p>HMACs will be used throughout the sphinx packet construction so that each hop
can verify that the contents of the packet (the message) has not been tampered
with. Since the HMAC can only be derived by the sender, Alice, each HMAC for
each hop must be present in the onion from the beginning. This will become more
clear with the example.</p><h1 id=xor>XOR<a hidden class=anchor aria-hidden=true href=#xor>#</a></h1><p>The <a href=https://en.wikipedia.org/wiki/XOR_gate>XOR</a> (or Exclusive-OR) operation is a bitwise operation where the
result is 1 if one <em>and only one</em> of the two bits being operated on is 1. In
other words, the result of the XOR operation is only 1 if the two bits being
operated on differ. The XOR truth table can be seen below. It shows the result
(<code>C</code>) after performing the XOR operation on two bits, <code>A</code> and <code>B</code>, for each of
the various combinations.</p><p><img loading=lazy src=/onion/xor-1.png#center alt></p><p>The next diagram demonstrates an interesting property of XOR that we will be
making use of in the sphinx packet construction later in this post. It shows
that taking the result of the above operation, <code>C</code>, and XORing it with <code>A</code>
produces <code>B</code>. Similarly, the XOR of <code>C</code> and <code>B</code> produce <code>A</code>.</p><p><img loading=lazy src=/onion/xor-2.png#center alt></p><p>To really nail down the idea, let’s look at some examples: In example 1 below,
you can see that if you XOR a packet with itself, it produces a zero byte
array. So XORing something with itself essentially destroys information.
Example 2 shows that if you take a packet and XOR it with a zero byte array of
the same length, then it produces the original packet.</p><p><img loading=lazy src=/onion/xor-3.png#center alt></p><p>Ok let’s see some more useful and interesting examples:</p><p><img loading=lazy src=/onion/xor-4.png#center alt></p><p>Example 3 shows that if you take a packet and XOR it with a random byte stream,
then you get the encrypted form of the packet. Example 4 shows that if you then
take that encrypted packet and once again XOR it with the <em>same</em> byte stream,
then you are once again left with the clear text. The sphinx packet
construction makes heavy use of XOR for encrypting a clear text packet using a
pseudo random byte stream.</p><h1 id=sender-preparation>Sender preparation<a hidden class=anchor aria-hidden=true href=#sender-preparation>#</a></h1><p>The example used in this post continues where the last post ended off.
Basically we have the following route where Alice is the sender and Dave is the
recipient. Alice essentially just needs to deliver a payload to each hop
without leaking too much data about the route.</p><p><img loading=lazy src=/onion/1-path.png#center alt></p><p>Alice has a set of payloads that she wants to communicate to each hop. When the
payloads are put into the onion packet, they are prefixed with a length and
postfixed with a 32 HMAC.</p><p><img loading=lazy src=/onion/5-payloads.png#center alt></p><p>Alice now goes ahead and generates a <code>session_key</code> and uses this to derive the
chain of <a href=#ephemeral-keys>ephemeral keys</a>. Note that &ldquo;bf&rdquo; here stands for
&ldquo;blinding factor&rdquo;. A blinding factor is used to tweak a private key or public
key.</p><p><img loading=lazy src=/onion/3-ephemeral_keys.png#center alt></p><p>I mentioned before that we don’t want hops on the route to have an idea of where
on the route they are. To achieve this, the onion packet given to each hop will
be the exact same size (1300 bytes) and each hop will only be able to read the
payload meant for it. The rest of the onion will look like a random stream of
bytes to that hop.</p><h1 id=first-attempt-at-wrapping-the-onion>First attempt at wrapping the onion.<a hidden class=anchor aria-hidden=true href=#first-attempt-at-wrapping-the-onion>#</a></h1><p>We are going to run through the onion wrapping process twice. During the first
pass we will get an initial feel for it and we will see why certain complexities
need to be added on the second pass.</p><p>Alice needs to wrap the onion back to front: we first add the payload for Dave,
encrypt that and then add the payload for Charlie and so on. The packet we end
up giving to Bob will be a fully wrapped onion. Each hop will peel one layer of
the onion.</p><p>First, Alice generates a 1300 byte pseudo random stream using the session key.
This is knows as the &ldquo;padding&rdquo;.</p><p><img loading=lazy src=/onion/6-padding.png#center alt></p><h3 id=wrapping-for-dave>Wrapping for Dave<a hidden class=anchor aria-hidden=true href=#wrapping-for-dave>#</a></h3><p>She then slides over the padding to make room for Dave’s payload. The HMAC that
is appended to Dave’s payload is not actually a real HMAC. Since Dave is the
last hop, this onion doesn’t need to be passed onto any other hops and so this
HMAC is made to be an empty set of zero bytes which serves as a signal to Dave
that he is the final hop on the route.</p><p>The packet needs to remain 1300 bytes long and so that trailing section of the
padding is chopped off.</p><p><img loading=lazy src=/onion/7-wrap_dave_1.png#center alt></p><p>Alice then uses her shared key with Dave, $ss_{AD}$, along with the <code>rho</code>
constant to derive a pseudo random stream of 1300 bytes. This stream is XOR&rsquo;d
with the onion packet which produces an encrypted packet that only Dave would
be able to decrypt. Alice then uses $ss_{AD}$, the <code>mu</code> constant and the packet
contents at this point to calculate an HMAC for this packet. Dave will later
verify that this HMAC is equal to the HMAC that he produces over the packet when
he receives.</p><p><img loading=lazy src=/onion/8-wrap_dave_2.png#center alt></p><h3 id=wrapping-for-charlie>Wrapping for Charlie<a hidden class=anchor aria-hidden=true href=#wrapping-for-charlie>#</a></h3><p>Next, Alice will add Charlie’s payload. Note that his payload will include the
$HMAC_1$ calculated above. Once again, the packet length is kept to 1300 bytes.</p><p><img loading=lazy src=/onion/9-wrap_charlie_1.png#center alt></p><p>Similarly to the encryption for Dave, Alice now uses her shared secret with
Charlie, $ss_{AC}$ to derive a pseudo random byte stream which she XORs with
the onion packet. This produces the encrypted packet destined for Charlie. Once
again, Alice calculates an appropriate HMAC for this payload.</p><h3 id=wrapping-for-bob>Wrapping for Bob<a hidden class=anchor aria-hidden=true href=#wrapping-for-bob>#</a></h3><p>Ok last layer! Finally, Alice slides Bob’s payload in at the start of the
packet and clips off the rest so that it is still a 1300 byte packet. She then
XORs this with a byte stream derived from her shared secret with Bob, $ss_{AB}$,
and then finally calculates the HMAC for this packet: $HMAC_3$.</p><p><img loading=lazy src=/onion/10-wrap_bob_1.png#center alt></p><p>Before sending this packet to Bob, Alice wraps it with some required
information: The packet version byte, Alice’s first ephemeral key $E_{AB}$ and
finally the HMAC ($HMAC_3$) for the final onion packet.</p><p><img loading=lazy src=/onion/11-final_onion.png#center alt></p><p>Alice now hands this packet to Bob.</p><h1 id=peeling-the-onion>Peeling the Onion<a hidden class=anchor aria-hidden=true href=#peeling-the-onion>#</a></h1><h3 id=bob-peels-a-layer>Bob peels a layer<a hidden class=anchor aria-hidden=true href=#bob-peels-a-layer>#</a></h3><p>The first thing that Bob will do is to derive the shared key between him and
Alice using the ephemeral key, $E_{AB}$. While he is at it, he can also already
compute the _next_ ephemeral key that he will need to communicate with Charlie.</p><p><img loading=lazy src=/onion/13-bob_keys.png#center alt></p><p>Then, Bob needs to validate the HMAC. He does this by using the derived shared
secret with Alice, $ss_{AB}$, along with the <code>mu</code> constant and the onion packet
contents to compute expected HMAC for the payload. The HMAC is valid if it is
equal to the one he received from Alice that was appended to the end of the
packet.</p><p><img loading=lazy src=/onion/12-peel_bob_1.png#center alt></p><p>This HMAC should be valid because you can see that the package contents in the
above image is the same as the package contents that Alice used to create this
HMAC.</p><p>Great! Now Bob is ready to do some decrypting. Since he was able to derive the
secret key $ss_{AB}$, he is able to derive the same pseudo random byte stream
that Alice used to encrypt his payload. He uses this to XOR the payload which
decrypts it. Oh, but wait! remember that Bob will remove his payload before
passing it on to Charlie… but the packet needs to remain 1300 bytes long, and he
can&rsquo;t just replace the empty space with zero bytes since the next hop will be
able to glean some information about the length of the route and the length of
Bob’s payload by looking at the number of zero bytes. So instead, before
decrypting the payload, Bob first appends 1300 zero bytes to the encrypted
payload, generates 2600 bytes of pseudo random byte stream and only then does
the XOR decryption.</p><p><img loading=lazy src=/onion/14-peel_bob_2.png#center alt></p><p>Now that the decryption is complete, Bob removes his payload and chops up the
packet to once again be 1300 bytes:</p><p><img loading=lazy src=/onion/15-charlie_onion.png#center alt></p><p>As Alice did for Bob, Bob now packages the onion nicely for Charlie by adding
the Ephemeral key that Charlie will need along with the $HMAC_2$ that Alice
provided Bob with in his payload.</p><p><img loading=lazy src=/onion/15-onion_for_charlie.png#center alt></p><p>You may have already picked up an issue here… take a moment here to see if you
can spot the issue. It will become more clear when we dive into Charlie’s
verification process in the next step. For now, let’s assume Bob hands this over
to Charlie.</p><h3 id=charlie-peels-a-layer>Charlie peels a layer<a hidden class=anchor aria-hidden=true href=#charlie-peels-a-layer>#</a></h3><p>Charlie receives the packaged onion from Bob. The first thing is does is to use
the ephemeral key $E_{AC}$ along with his own private key, <code>c</code>, to derive the
shared secret between him and Alice. He then uses this to derive the ephemeral
key for Dave too.</p><p><img loading=lazy src=/onion/17-charlie_keys.png#center alt></p><p>Then, he checks to see if the HMAC is valid given the payload. Ok this is where
the issue lies! If you scroll back to see the diagram showing the message that
Alice used to create this HMAC, you will see that the packet looked different.
But now we at least know what the packet <em>should</em> look like when Alice
calculates the HMAC for Charlie.</p><p><img loading=lazy src=/onion/16-peel_charlie_1.png#center alt></p><p>For the sake of completion <em>and</em> so we can find out where else things might
have gone wrong, let’s assume that Charlie continues the process.</p><p>Charlie uses the shared secret key to decrypt the packet similarly to how Bob
did it. He then can read his payload and reconstruct the packet for Dave.</p><p><img loading=lazy src=/onion/18-peel_charlie_2.png#center alt></p><h3 id=dave-peels-a-layer>Dave peels a layer<a hidden class=anchor aria-hidden=true href=#dave-peels-a-layer>#</a></h3><p>Dave receives the packet and derives his shared secret key with Alice:</p><p><img loading=lazy src=/onion/20-dave_keys.png#center alt></p><p>He then attempts to do the HMAC verification. Once again, this will fail since
the packet contents does not match the packet contents that Alice used when
creating the HMAC. But again, we now know what it should look like, and we will
use this information on our second attempt.</p><p><img loading=lazy src=/onion/19-peel_dave_1.png#center alt></p><p>Let&rsquo;s again assume that Dave continues and uses the shared secret to decrypt the
packet.</p><p><img loading=lazy src=/onion/21-peel_dave_2.png#center alt></p><p>Dave will see that the HMAC sent to him is a zero byte array. He therefore knows
that he is the last hop on the path.</p><h1 id=second-attempt-at-wrapping-the-onion>Second attempt at wrapping the onion.<a hidden class=anchor aria-hidden=true href=#second-attempt-at-wrapping-the-onion>#</a></h1><p>Ok so we’ve made some mistakes, but we have also learned some lessons. Now
that we know what each packet needs to look like at the time of computing the
HMACs, we can redo the onion wrapping process correctly.</p><p>Let’s start by taking a look at the packet at the point Dave gets it (before
decryption):</p><p><img loading=lazy src=/onion/22-filler_1.png#center alt></p><p>The difference between this packet and the one we originally used to create the
HMAC is the end bit shown in the diagram above. Luckily we have kept track of
which pseudo random byte streams and which sections of those byte streams are
involved here. So all Alice needs to do at the start is to construct this
section which is called the “filler”. The diagram below shows its construction:</p><p><img loading=lazy src=/onion/23-filler_2.png#center alt></p><p>Ok cool! Let’s try this again shall we?</p><h3 id=wrapping-for-dave-1>Wrapping for Dave<a hidden class=anchor aria-hidden=true href=#wrapping-for-dave-1>#</a></h3><p>The initial padding generation remains the same:</p><p><img loading=lazy src=/onion/24-padding.png#center alt></p><p>Again we slide in Dave’s payload and encrypt it:</p><p><img loading=lazy src=/onion/24-wrap_dave.png#center alt></p><p>Here is where things change! We know that before Alice uses Dave’s payload to
compute the HMAC, she must first insert the filler.</p><p><img loading=lazy src=/onion/25-wrap_dave_2.png#center alt></p><p>Great! Now the HMAC that Charlie ends up receiving will in fact be valid for the
payload he gets.</p><h3 id=wrapping-for-charlie-1>Wrapping for Charlie<a hidden class=anchor aria-hidden=true href=#wrapping-for-charlie-1>#</a></h3><p>Alice then again slides in Charlie’s payload, encrypts it and then… do we need
to cut out some bytes and replace them with a derived filler again? Well… no,
it doesn’t seem that we do! Due to the properties of XOR, XORing the packets
existing filler contents with the byte stream that Charlie uses to decrypt the
payload, the resulting packet <em>is</em> actually equal to the packet that Charlie
will receive! Therefore, nothing special needs to be done at this point. Alice
can go ahead and calculate the HMAC as is.</p><p><img loading=lazy src=/onion/26-wrap_charlie_1.png#center alt></p><h3 id=wrapping-for-bob-1>Wrapping for Bob<a hidden class=anchor aria-hidden=true href=#wrapping-for-bob-1>#</a></h3><p>Finally, Alice adds Bob’s payload, encrypts the packet and computes the final
HMAC.</p><p><img loading=lazy src=/onion/27-wrap_bob.png#center alt></p><p>Notice that this final onion packet is identical to the one that we had at the
end of the first pass we did (except of course that the HMACs are all correct
now) and so the peeling of this packet will look exactly like the peeling of the
first pass packet.</p><h1 id=errors>Errors<a hidden class=anchor aria-hidden=true href=#errors>#</a></h1><p>Compared to what we have already covered, understanding how errors are dealt
with should be a breeze :)</p><p>Let’s assume that when Charlie decodes the payload in the onion sent from Alice,
he realises that she is asking him to forward an amount that would mean that he
does not get the fee that he has advertised. Charlie will then want to fail the
payment and so instead of passing the onion on to Dave, he instead constructs a
failure message packet which will contain a message he wishes to send back to
Alice telling her what went wrong. He may choose to pad this message too. He
will use the shared secret he has with Alice, $ss_{AC}$ along with the <code>um</code>
constant to produce an HMAC over the data. He will then use $ss_{AC}$ along with
the <code>ammag</code> constant to produce a pseudo random bytes stream which he will then
XOR with the failure message packet. He will then put this encrypted message in
an <code>update_fail_htlc</code> message and send that back to Bob.</p><p><img loading=lazy src=/onion/errors-1.png#center alt></p><p>Bob will simply take his shared secret with Alice, $ss_{AB}$, produce another
byte stream and re-encrypt the payload as is. He, too, will put this into an
<code>update_fail_htlc</code> message and send it back to Alice.</p><p><img loading=lazy src=/onion/errors-2.png#center alt></p><p>When Alice receives this message, she does not immediately know which hop
produced the payload, but she does know in which order things would have been
encrypted. So she starts decrypting by un-peeling Bob’s encryption layer. Once
decrypted, she looks at the first 32 bytes of the payload (the size of an HMAC),
computes the HMAC for the rest of the payload and checks if those two HMACs are
equal. In this case, they will not be which means that Bob was not the erring
node.</p><p><img loading=lazy src=/onion/errors-3.png#center alt></p><p>She then continues by peeling back Charlie’s encryption layer and then repeats
the process of checking the HMAC. In this case, the HMACs will be equal and so
Alice knows that Charlie is the source of the error, and so she can now read his
erring reason from the failure message.</p><p><img loading=lazy src=/onion/errors-4.png#center alt></p><h3 id=one-little-edge-case>One little edge case<a hidden class=anchor aria-hidden=true href=#one-little-edge-case>#</a></h3><p>One edge case to be aware of is where Charlie gets the onion packet from Bob but
then is not able to successfully parse it. If Charlie cannot parse it, then he
won’t know the ephemeral key to use to derive the shared secret with Alice. This
means that he would not be able to encrypt a failure message packet. So in this
case, Charlie will send Bob an <code>update_fail_malformed_htlc</code> message with some
information about the type of error that occurred. When Bob receives this, he
knows that he must do the initial encryption round for this error. He does this
and then sends the packet back to Alice in an <code>update_fail_htlc</code> message.</p><h1 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h1><p>Well if you are still here - congrats! You now understand the complexities
creating a Sphinx onion packet!</p><p>As always, if you think anything needs clarification or if you have any
questions - leave a comment below. If there are corrections that you think
should be made to the text, feel free to let me know or to open a pull request
on the website’s GitHub page.</p></div><footer class=post-footer><ul class=post-tags></ul><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Lightning Network Onion Routing: Sphinx Packet Construction on twitter" href="https://twitter.com/intent/tweet/?text=Lightning%20Network%20Onion%20Routing%3a%20Sphinx%20Packet%20Construction&url=https%3a%2f%2fwww.ellemouton.com%2fdrafts%2fsphinx%2f&hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Lightning Network Onion Routing: Sphinx Packet Construction on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fwww.ellemouton.com%2fdrafts%2fsphinx%2f&title=Lightning%20Network%20Onion%20Routing%3a%20Sphinx%20Packet%20Construction&summary=Lightning%20Network%20Onion%20Routing%3a%20Sphinx%20Packet%20Construction&source=https%3a%2f%2fwww.ellemouton.com%2fdrafts%2fsphinx%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Lightning Network Onion Routing: Sphinx Packet Construction on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fwww.ellemouton.com%2fdrafts%2fsphinx%2f&title=Lightning%20Network%20Onion%20Routing%3a%20Sphinx%20Packet%20Construction"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Lightning Network Onion Routing: Sphinx Packet Construction on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.ellemouton.com%2fdrafts%2fsphinx%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Lightning Network Onion Routing: Sphinx Packet Construction on whatsapp" href="https://api.whatsapp.com/send?text=Lightning%20Network%20Onion%20Routing%3a%20Sphinx%20Packet%20Construction%20-%20https%3a%2f%2fwww.ellemouton.com%2fdrafts%2fsphinx%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Lightning Network Onion Routing: Sphinx Packet Construction on telegram" href="https://telegram.me/share/url?text=Lightning%20Network%20Onion%20Routing%3a%20Sphinx%20Packet%20Construction&url=https%3a%2f%2fwww.ellemouton.com%2fdrafts%2fsphinx%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer><script src=https://utteranc.es/client.js repo=ellemouton/website issue-term=pathname theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://www.ellemouton.com>Elle Mouton</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>