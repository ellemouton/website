[{"content":"I’ve previously written in depth about how Lightning channels are opened, but I’ve never gone into the details of the normal operations and closures of channels. Since I promised in my previous post about Taproot channel transactions that I would write a follow-up explaining how all the channel messages need to be updated in order to support the new MuSig2 signing required by Taproot channels, I think now is the time to finally dive into the normal channel operations and closures so that the follow-up post on how Taproot channels affect these operations is easier to parse.\nOverview In this blog post, I will talk about the normal operations of a channel. This involves understanding how HTLCs are added to a channel and how channel peers commit to a new state including these HTLCs. Then I will cover how a channel’s normal flow is re-established after a disconnection and finally, the cooperative channel closure flow will be covered. All of these topics are covered in Bolt 2, but I thought a diagram or two could help with understanding. I plan on doing all of this with a long-running example.\nPreliminaries Here are a few links that cover some preliminaries that might be useful for understanding this blog post:\n Why channel peers have an asymmetric state and how they go about updating this state in a trust-less way: Updating State. What HTLC outputs look like on a commitment transaction: HTLC deep-dive. How two nodes go about opening a channel: Opening and announcing a pre-taproot LN channel.  Normal Channel Operation Setting the scene Alice and Bob (hello old friends!) have successfully opened their channel. They have both seen that the funding transaction has confirmed, and they have exchanged the channel_ready message with each other to indicate that they are ready to use the channel. The state of their asymmetric commitment transactions currently look as follows:\nBoth commitment transactions spend the 2-of-2 multi-sig funding transaction output. Spending from this output requires a signature from both parties. The signatures are represented by the two boxes at the top of the commitment transactions. You can see from the diagram that Alice’s commitment transaction has a signature from Bob represented by the blue box (say it with me: “Bob is blue!”) and Bob has a signature from Alice for his commitment transaction represented by the green box (“Alice is green” doesn’t have quite the same ring to it). Each commitment transaction also has the to_local and to_remote outputs which pay the respective parties their current channel balance. Both Alice and Bob have the ability to sign their own commitment transaction at any time and broadcast it to the Bitcoin network. This would be a force close.\nFor the sake of making the next few diagrams in this article a bit simpler, I am going to ignore the funding transaction along with the to_local and to_remote outputs for a while since our initial focus is going to be on adding and removing HTLC outputs. So the above diagram can instead be represented as follows:\nA red coloured commitment transaction, as shown below, represents past, revoked commitment transactions. If Alice or Bob were to sign and broadcast one of their older revoked commitment transactions then the other side would be able to sweep all their funds. So these revoked transactions can effectively be considered invalid. The yellow commitment transactions represent the latest, valid set of commitment transactions. These are the commitment transactions that would be broadcast in a force close. Then finally, each side has what can be thought of as a “staging area” where changes to the commitment transaction can be proposed. Later on, either side can decide when it wants its counterparty to commit to the changes in their staging commitment transaction. For those of you who love a good analogy - this is very much like a git workflow: past commits are out of date, but they tell a nice story of what has happened, your latest committed changes represent the current state of your project and any changes that are not yet committed are in staging.\nAdding an HTLC When either Alice or Bob want to send a payment across the channel in question (which would happen if either of them wanted to send a payment themselves or if they are routing another node’s payment) then they would need to propose the inclusion of the HTLC to their channel peer. This is done with the update_add_htlc message:\nThe channel_id is used to communicate which channel this change should take place on, the id is an always-incrementing identifier for this proposed change from the sender. The amount_msat is the amount that should be attached to the HTLC output, the cltv_expiry is the block height that the HTLC should expire at and finally the onion_routing_packet and optional blinding_point both contain data that the recipient will use to determine where next to send the payment.\nSomething that definitely took me a while to wrap my head around is the fact that the sender of this message does not put this update in their own staging area commitment transaction yet. This is because the update is still \u0026ldquo;pending on the receiver\u0026rdquo; because the sender has not yet received any acknowledgement from receiver for the new update. This is to allow for the case where one peer sends an update and then immediately receives a commitment_signed message (more details on this later). In that case, there should be no ambiguity around which updates are included in the transaction being signed. Hopefully this makes more sense as we work through the example.\n⚙️ Step 1: Alice -\u0026gt; Bob: update_add_htlc(A1) Ok so let’s say that Alice sends Bob an update_add_htlc. Let’s call this HTLC A1 since it is the first one that Alice (A) is sending to Bob. If Bob is happy with all the fields in the message, then he adds the HTLC to his staging area commitment transaction and Alice marks the HTLC as pending on Bob\u0026rsquo;s side but does not yet add it to her staging commitment transaction:\nNote that neither side has actually committed to this HTLC and so if Bob is a routing node for this payment, he should not yet send update_add_HTLC to the next hop in the route until A1 has been irrevocably committed. An HTLC addition or removal is only considered irrevocably committed once both parties in the channel have committed to the commitment transaction with or without it respectively.\nSomething that the more simplified diagram fails to show is that Alice\u0026rsquo;s main output in Bob\u0026rsquo;s staging commitment transaction (ie, the to_remote output) will now have the value of the added HTLC subtracted (along with the fees to cover the extra output). If the HTLC ends up succeeding then this amount will be added to Bob\u0026rsquo;s output and if it ends up failing, then it will be re-added to Alice\u0026rsquo;s output.\n⚙️ Step 2: Alice -\u0026gt; Bob: update_add_htlc(A2) Even if they have not committed to HTLC A1 yet, that does not stop them from adding more changes to the staging area. So Alice is more than welcome to propose a new HTLC, A2, to Bob:\n⚙️ Step 3: Bob -\u0026gt; Alice update_add_htlc(B1) Similarly, Bob can suggest a change B1 to Alice:\nCommitting to the current state At some point, one of the peers will want to make sure that the other peer has committed to the latest set of changes and revoke the previous valid state. This is done by sending the commitment_signed message:\nThe channel_id once again refers to the channel in question. The signature is the sender\u0026rsquo;s signature for the remote party’s staging area commitment transaction. num_htlcs refers to the number of HTLCs that the sender expects to be on the remote commitment transaction and this is then followed by htlc_signatures which is an array of num_hltcs signatures which are the sender’s signatures for each of the second-level HTLC transactions that the remote party would need to broadcast if they were ever to force close the channel. If you need a reminder about why the second-level HTLC transactions are needed, give this post a read.\n⚙️ Step 4: Alice -\u0026gt; Bob: commitment_signed Let’s say that Alice sends this message to Bob. Bob will now have all the required signatures from Alice to broadcast his staging-area commitment transaction:\nNotice that Alice knew that her signature would need to cover the A1 and A2 HTLCs. This is fine because the underlying transport is guaranteed to be reliable and ordered meaning that if Bob was to receive Alice\u0026rsquo;s commitment_signed message then it means that he definitely received her update_add_htlc messages for A1 and A2. Alice and Bob both know that the signature should not cover the B1 HTLC since Alice has not sent an acknowledgement for it yet.\nAnother thing to notice is that Bob now actually has two valid commitment transactions since he has not yet revoked his previous state. He is, however, incentivised at this point to revoke his previous commitment transaction since the HTLCs on the new state are either:\n Payments to Bob himself meaning that he gains from committing to the new state. If he doesn’t commit to the new state, then Alice won\u0026rsquo;t either and so there would still exist a version of a commitment transaction that does not pay Bob his incoming funds. Similarly to the above point, if Bob is routing a payment, then he is also incentivised to try to get the HTLC irrevocably committed since he would earn routing fees if the payment succeeds. Finally, if Bob is making the payment himself, then the first state would in fact be more desirable to him since he strictly has less funds in the second state. However, the merchant that Bob is making the payment to won\u0026rsquo;t release the goods being purchased unless funds come through which won\u0026rsquo;t happen if Alice does not pass on the HTLC which she won\u0026rsquo;t do unless it has been irrevocably committed to. So again, Bob is incentivised to revoke his previous state.  ⚙️ Step 5: Bob -\u0026gt; Alice: revoke_and_ack In response to Alice’s commitment_signed, Bob sends the revoke_and_ack message:\nThe per_commitment_secret provides Alice with the information she needs in order to be able to spend any revocation path on Bob’s previously valid state. See this post for more details about how revocation works. The next_per_commitment_point gives Alice the information she needs in order to derive the revocation public key that will be used in Bob’s next commitment transaction. Once Alice receives this message, Bob’s previous commitment transaction has successfully been revoked. Note that this message explicitly acknowledges the commitment_signed message sent by Alice and by extension, since messages delivery is reliable and ordered, it also implicitly acknowledges the update_add_htlc messages that Alice sent for A1 and A2. Alice can therefore finally add A1 and A2 to her staging area commitment transaction since they are no longer pending on Bob\u0026rsquo;s side:\nLet’s clean up the diagram a bit…\nThat’s better.\nFrom the above diagram, notice that Alice\u0026rsquo;s and Bob’s latest commitment transactions are actually out of sync. This is fine since none of the updates have been irrevocably committed yet. That might seem hard to believe since the commitment transactions look so different so let’s walk through the consequences of either of these transactions ending up on-chain from the perspective of both sides.\n  From Alice’s perspective:\n if her commitment transaction is broadcast, she gets back her original to_local amount. if Bob’s commitment transaction is broadcast, then Alice\u0026rsquo;s offered HTLCs (such as A1 and A2) will be on-chain. For offered HTLCs, Alice is sending sats out meaning that her to_local would be lower. But, if Bob was a router node for these HTLCs then he would not have forwarded them as they are not yet irrevocably committed meaning that he won\u0026rsquo;t receive the pre-images required to claim these HTLCs and Alice would be able to get her funds back via the timeout path. If Bob was the recipient of these HTLCs, then he would be able to produce the pre-image to claim the HTLCs, but then Alice would see the pre-image on-chain and would be able to claim the incoming HTLCs from their incoming channel and would thus have earned routing fees.    From Bob’s perspective (very similar to the logic for Alice):\n if Alice’s commitment transaction is broadcast, Bob gets back his funds via the to_remote output. If Bob had to force close via his commitment transaction, then HTLCs offered to him (like A1 and A2) would be on-chain, if Bob was routing these, then he would not have forwarded them on since they are not yet irrevocably committed. He thus won\u0026rsquo;t be able to claim the success path but that is fine since the funds for these did not come out of his balance. If Bob was the final destination for these, then he would be able to claim them via the success path.    ⚙️ Step 6: Alice -\u0026gt; Bob: update_add_htlc(A3) I want to really nail down the point that the commitment transactions can remain out of sync indefinitely and that Bob does not need to send commitment_signed just because Alice did. So, for the sake of the example, let’s say that Alice at this point sends yet another HTLC, A3, to Bob:\n⚙️ Step 7: Bob -\u0026gt; Alice: commitment_signed Bob wants to irrevocably commit some of the HTLCs so that he can forward them on, so he finally sends Alice a commitment_signed of his own. This will include his signature for Alice’s staging-area commitment transaction along with all the signatures required from him for the second-level HTLC outputs.\n⚙️ Step 8: Alice -\u0026gt; Bob: revoke_and_ack Just like Bob did previously, Alice responds to the commitment_signed with a revoke_and_ack in order to revoke her previous state. This also serves as an acknowledgement to Bob that Alice has received and committed to B1 and so Bob can now add B1 to his staging area commitment transaction.\nAllow me to clean that up real quick…\nMuch better.\nAt last, we have some irrevocably committed HTLCs! A1 and A2 have been irrevocably committed. B1 and A3, however, have not since they have not yet been committed to by both parties.\nLet\u0026rsquo;s quickly irrevocably commit B1 and A3.\n⚙️ Step 8: Alice -\u0026gt; Bob: commitment_signed ⚙️ Step 9: Bob -\u0026gt; Alice: revoke_and_ack ⚙️ Step 10: Bob -\u0026gt; Alice: commitment_signed ⚙️ Step 11: Alice -\u0026gt; Bob: revoke_and_ack Another clean-up:\nOk cool! Now all the HTLCs have been irrevocably committed.\nRemoving HTLCs You probably get the idea of adding HTLCs now. But how about removing them? HTLCs are removed if a payment succeeds or if it fails. Note that HTLC removal messages can only be sent by the peer who did not send the original update_add_htlc and that HTLC’s are only removable once they have been irrevocably committed to. Luckily for us, all the HTLCs have been irrevocably committed, and so we can start removing them now.\n⚙️ Step 12: Bob -\u0026gt; Alice: update_fulfill_htlc(A2) In the best case scenario, an HTLC is removed because it is being fulfilled meaning that its pre-image is being passed back. This is done with the update_fulfilled_htlc message which looks as follows:\nIn our example, Bob sends Alice the update_fulfill_htlc message for HTLC A2. This also demonstrates that the HTLCs don’t need to be removed in the same order they were added.\nNotice that just like the updates for adding an HTLC, updates for removing an HTLC will also initially be pending on the receiver side until they have been acknowledged by a revoke_and_ack. So in our case, Alice removes A2 from her staging area transaction when she receives the update_fulfill_htlc (and allocates the HTLC amount to Bob\u0026rsquo;s output) but Bob does not yet remove the HTLC from his staging area transaction.\nUnlike other update messages, there is no need to wait for an HTLC removal to be irrevocably committed if you receive the pre-image for it. You can immediately send the pre-image upstream in order to claim any HTLCs there.\n⚙️ Step 13: Bob -\u0026gt; Alice: update_fail_htlc(A1) HTLCs can also be removed due to payment failures such as HTLCs timing out or if there was some sort of routing failure such as a specific channel on the path no longer existing, a hop’s fee requirements not being met, a link not having sufficient balance etc. Such failures are communicated with the update_fail_htlc message:\nThe reason field is an encrypted blob for the sender of the payment in order to inform them of the failure reason.\nAfter Bob sends Alice the update_fail_htlc message for A1, the state looks as follows:\n⚙️ Step 14: Bob -\u0026gt; Alice: update_fail_malformed_htlc(A3) The final message that can be used to remove an HTLC is the update_fail_malformed_htlc message:\nThis is sent back if any hop was unable to parse the onion_routing_packet it received in update_add_htlc. If Bob sends Alice this message for A3, then the state now looks as follows:\n⚙️ Step 15: Alice -\u0026gt; Bob: update_fulfill_htlc(B1) Alice also initiates the removal of B1 by sending an update_fulfill_htlc to Bob.\nLet’s now clean-up the HTLC removals by irrevocably committing them. This will require a few commitment_signed-revoke_and_ack flows:\n⚙️ Step 16: Bob-\u0026gt; Alice: commitment_signed ⚙️ Step 17: Alice -\u0026gt; Bob: revoke_and_ack ⚙️ Step 18: Alice -\u0026gt; Bob: commitment_signed ⚙️ Step 19: Bob -\u0026gt; Alice: revoke_and_ack ⚙️ Step 20: Bob -\u0026gt; Alice: commitment_signed ⚙️ Step 21: Alice -\u0026gt; Bob: revoke_and_ack The two valid states now look nice and clean once again:\nUpdating fees There is one more update_* message that we need to cover and that is the update_fee message. This message is used to update the fee-rate that the peers should use when constructing their commitment transactions. The original fee-rate is decided in the open-channel flow but if the average mempool fee-rate increases, the channel funder might decide to update the fee of the commitment transactions so that they have a better chance of getting confirmed in a timely manner in a force close situation. It could also be that when the channel was opened, a very high fee-rate was chosen and perhaps a lower fee-rate would be desired.\nThis message follows similar rules to other update_* messages in that it must also be irrevocably committed before it takes effect. The only other extra rule that applies to this message is that only the channel funder may send this message.\nOne thing to note is that with anchor channels, the need to use the update_fee message is becoming less and less since nodes will be able to use CPFP on the force-close transaction if required.\nMessage Retransmission Something that you may have picked up on while walking through the add/remove HTLC flow is that explicit acknowledgements for the update_* messages is delayed until the commitment_signed/revoke_and_ack exchange. That is ok most of the time since we assume that the underlying transport between the two nodes (see Bolt 8) is ordered and reliable. However, if the connection needs to be re-established for some reason, there will be doubt regarding whether our peer has received the last message that we sent. This is where the channel_reestablish message comes in. Upon reconnection, before continuing with the normal operation flow, the peers will exchange this message to make sure they are on the same page and to determine which messages they possibly need to re-send to their peer.\nEach peer in the channel has their version of the commitment transaction and the two commitment transactions can be updated independently meaning that the number of times that one side’s commitment transaction state has been updated (through the commitment_signed and revoke_and_ack flow) could be completely different to that of the other side. The next_commitment_number field in the channel_reestablish message allows us to communicate with our peer the next commitment_signed that we expect to receive from them. This way, they will know if we have perhaps missed a commitment_signed from them that they previously sent before the disconnection. In other words, next_commitment_number tells the remote peer what we see our latest committed state to be. Similarly, next_revocation_number is the commitment number of the next revoke_and_ack that we expect to receive. In other words, this indicates to our peer which commitment number we think is their latest one. The your_last_per_commitment_secret is the last per-commitment secret received from the remote peer which will give the remote peer an idea of the state it has definitely revoked. my_current_per_commitment_point is the commitment point of the local party on its last commitment transaction signed by the remote peer (in other words, the commitment transaction that has not yet been revoked). There are a lot of checks that a node should do when receiving a channel_reestablish in order to make sure that all necessary updates are re-sent so that the channel can continue as normal. There are also some checks that ensure that nodes are not tricked into revoking a state that should not yet be revoked or tricked into broadcasting a state that has been revoked. If you are interested in the details around these checks, see bolt 2.\nNote that when a connection re-establish happens, both sides must remove any un-committed updates from their staging area. If we stick with the git analogy, they should hit git stash when a reconnection occurs. This means that both sides will need to re-transmit any update_* messages that were not yet committed on the other side’s commitment transaction.\nClosing a channel cooperatively Alice and Bob sure had some good times together but all good things must come to an end. Closing a channel in a cooperative way requires the two peers to decide on a final closing transaction that will spend from the funding transaction and will pay each of them their final channel balance immediately.\n⚙️ Step 22: Bob -\u0026gt; Alice: shutdown Bob has decided that it is time to cut ties and sends Alice the shutdown message.\nThe shutdown message contains the scriptpubkey that Bob would like his final channel balance to be sent to in the closing transaction. Once Bob has sent this message, he may no longer send any new update_add_htlc messages. He may only send HTLC removal and update_fee messages. When Alice receives this message from Bob, she must respond with her own shutdown message and may also no longer send any new update_add_htlc messages. Alice and Bob now need to wait until all remaining HTLCs have been cleared from both commitment transactions. Since the closing transaction will spend from the funding transaction and explicitly looks different from the commitment transactions, I’ll re-introduce some of the details in to the state diagram:\nOnce all the HTLCs have been cleared, which in our example is already the case, they can start negotiating a fee to use for the final closing transaction. The funder of the channel must start this negotiation. Let’s assume that the funder of this channel was Alice.\n⚙️ Step 23: Alice -\u0026gt; Bob: closing_signed Alice will first choose a fee-rate that she thinks is appropriate for the closing transaction. She will then use that fee-rate to complete the construction of the closing transaction and will sign it. She then sends the closing_signed message to Bob:\nThe fee_satoshis field tells Bob the fee in satoshis that Alice used to construct the first closing transaction proposal and the signature contains Alice’s signature for this proposal. She may optionally also include the min_fee_satoshis and max_fee_satoshis fields in order to let Bob know that if he disagrees with her proposed fee_satoshis, then he may send a counterproposal as long as his counterproposal lies between the provided minimum and maximum values.\nAt this point, the channel state looks as follows:\nThere are two valid commitment transactions that can be signed at any time by each party to perform a force close, and there is one closing transaction proposal that uses a fee-rate of x sats-per-byte. This closing transaction currently only has Alice’s signature and so is not yet valid.\nIf at this point, Bob is happy with Alice\u0026rsquo;s proposal, he could go ahead and sign the closing transaction using the fee-rate proposed by Alice and could broadcast it and that would be the end of it. But for the sake of the example, let\u0026rsquo;s say that Bob isn\u0026rsquo;t quite happy yet.\n⚙️ Step 24: Bob -\u0026gt; Alice: closing_signed Bob may decide that the fee rate that Alice used is too low. So he sends a counterproposal with a new fee rate, y sats-per-byte, along with his signature for this counterproposal.\n⚙️ Step 25: Alice -\u0026gt; Bob: closing_signed If Alice is happy with Bob’s counterproposal, then she signs the closing transaction using the fee-rate suggested by Bob. She may then broadcast the transaction and call it a day. However, it is recommended in the spec that Alice send one more closing_signed message to Bob but this time with the fee_satoshis field set to y sats-per-byte along with her signature for the transaction. Both parties will now have both signature required in order to broadcast the final closing transaction that uses the y sats-per-byte fee rate.\nEither or both parties may now broadcast the closing transaction to the Bitcoin network. Eventually it will be confirmed, and the channel will officially be closed.\nIf this channel was a public channel, then any node in the network that had this channel in their routing graph will be able to see that the channel’s funding output has not been spent and so will remove the channel from their graph at this point.\nThe beauty of the channel is that Alice and Bob could have sent millions of HTLCs back and forth throughout the lifetime of the channel and in the end, all that showed up on-chain was the opening and closing transaction.\nAlice and Bob lived happily ever after.\nThanks for reading! As always, if anything is unclear or incorrect, feel free to leave a comment down below.\n","permalink":"https://www.ellemouton.com/drafts/normal-operation-pre-taproot/","summary":"A deep-dive into the normal operation and closure of a pre-taproot Lightning Network channel","title":"Normal operation and closure of a pre-taproot LN channel"},{"content":"Hold on to your hats folks, things are about to get real.\nOverview In this post, I will dive into the structure of Taproot channel funding and commitment transactions. If you missed my previous post about Taproot and MuSig2, it might be a good idea to read that one first for a recap of the building blocks that will be used throughout this post. If you perhaps also need a re-cap of the general structure of commitment transactions then check out this post where I cover why each output in a commitment transaction looks the way it does.\nNote that Taproot Channels are still in the design phase and so until the proposal by the one and only Roasbeef is merged, this blog post will be a living document that I will update if any changes are made to the proposal. This is currently up-to-date as of commit e95e7a.\nIf you have read some of my previous blog posts, you might have noticed that I love to make use of diagrams. Well this post is diagrams on steroids. To help with understanding, here is a legend showing what each colour generally represents:\nOk, ready? Let\u0026rsquo;s dive in!\nA quick note on NUMS points A NUMS point, or a nothing-up-my-sleeves point, is a public key that no one knows the private key to and that is derived from a string binding it to the context that it is being used in. The NUMS point used in taproot channels is derived from the string “Lightning Simple Taproot” using this NUMS generation tool. Since no one knows the private key for the NUMS point, it can be used as the internal key for a Taproot output in order to effectively cancel out the possibility of a key-path spend since no one would be able to create a valid signature for it.\nFunding Transaction Output The funding transaction output is the output that defines the opening of the channel. In pre-taproot channels, this output pays into a 2-of-2 multisig meaning that any transaction (commitment or closing transaction) spending from the output must be signed by both channel peers. Since the output is a P2SH, once it is spent, the underlying 2-of-2 multisig is revealed in the witness and so it becomes pretty clear to anyone observing the chain that the transaction was for a Lightning channel.\nIn the case of Taproot channels, this output is now a 2-of-2 MuSig2. Both parties will still need to sign each transaction that spends from the output, however, the signatures will now be aggregated via the MuSig2 protocol into a single signature. This means that in the ideal case where the channel is closed in a cooperative manner, the channel will look no different from any other P2TR key-path spend. This is a huge privacy improvement for unannounced channels since there is no way to tell that the transaction was for a Lightning channel, and it never gets advertised to the network through the gossip protocol. As for announced Taproot channels, the gossip protocol will actually need to be completely re-designed to support the new channel type and there is currently an ongoing debate around if this new gossip version should advertise the channel\u0026rsquo;s funding transaction at all or not. More on Taproot channel gossip in a future post.\nHere is a diagram showing how a Taproot channel funding output is constructed:\nThe two parties in a channel, the local and remote peer, use the MuSig2 protocol to aggregate their individual funding keys, P_a and P_b, into the aggregate key, P_agg, which is also the internal key. This internal key is then tweaked with a BIP86 tweak. You might recall from the previous post that a BIP86 tweak gives the channel owners the ability to prove to other nodes on the network that this funding output does not have a hidden script path.\nSpending from the funding transaction The funding output can only ever be spent via the key path. Since the internal key is an aggregate key produced via MuSig2, to spend it requires both parties to produce partial signatures for the message being signed. These signatures are then aggregated using the MuSig2 PartialSigAgg function and finally tweaked with the tweak, T, to produce the signature that would validly spend the funding output.\nNotice that unlike in pre-taproot channels where spending from the funding output would require two signatures created completely independently of each other, in Taproot channels, the signatures are created in an interactive manner between the peers. I will cover the details of how exactly this affects the interaction between the peers in the next blog post.\nCommitment Transaction Outputs There are six different outputs that a commitment transaction can have. These are: the to_local and to_remote outputs, the local and remote anchor outputs, the offered htlc output and the accepted htlc output. Let’s dive in.\nThe to_local output The to_local output is responsible for paying the local peer their channel balance. The output must be revocable by the remote party at all times and only after to_self_delay blocks should the local party be able to spend from the output. As you can see in the diagram below, both these paths are added as Taproot leaves in the Taproot tree and a public NUMS point is used as the internal key which effectively cancels out the key-spend path. You might be asking yourself why the revocation pub key is not used as the internal key and this is a good question since that is in fact how the output was in the original design. But you can see from the diagram below that the revocation script does not only contain the revocation public key but also strangely contains the P_local_delay key. Notice also that the key is not followed by OP_CHECKSIG but rather just by an OP_DROP which means that a signature is not required for the key. All that is required is that the key is revealed in the script. This reveal of P_local_delay in the revocation path is the only reason why the revocation public key could not be used as the internal key for the output. The reason for this design will be made more clear in the section describing the local anchor output. There is a good reason, I promise ;)\nScript path spends Since the internal key of the output is a public NUMS point, it is only possible to spend this output via a script path.\nRevocation path If this commitment transaction ends up on-chain and is for a state that has already been revoked, then the remote party will be able to sweep the funds via the revocation path. They can do so with the following witness:\nIt contains a signature for the revocation public key, the revocation script (which includes a reveal of the P_local_delay key) and finally it contains a control block which contains the internal key (the NUMS key) along with an inclusion proof for the revocation script.\nTo-local delay path If this commitment transaction ends up on-chain as part of an honest force-close scenario then the remote party will not be able to spend via the revocation path. In this case, the transaction will be spendable by the local party via the local delay script path after to_self_delay blocks have been confirmed. The following diagram shows the witness that will be required to spend this path:\nIt contains a witness for the local-delayed script which is a valid signature from the local party for their key, P_local_delayed. The script itself must also be revealed and finally, the control block must be specified. In this case, the control block only contains the parity bit of to_local output’s output key, the internal key (which is the NUMS point) and the inclusion proof for the to-local delay script.\nThe to_remote output This output pays the remote party their channel balance. As with all anchor channels, any non-anchor outputs must have a CSV of at least one to not break the CPFP carve out rule. Therefore, the remote party is only allowed access to their funds after one confirmation. This type of requirement can only be added in a script and so this output also makes use of the Taproot script tree.\nSimilarly to the to_local output, we use the NUMS point for the internal key here so that a key path spend is not possible.\nScript path spend Once the commitment transaction has one confirmation, the remote peer can spend it via the script path using the following witness:\nRemote Anchor Output This is the output that the remote party will be able to use to CPFP the commitment transaction if required. The remote party’s public key is thus used as the internal key. To ensure that this output (a very small output of only 330 satoshis) is definitely cleaned up at some point from the UTXO set, another output path is added which allows anyone to spend the output after it has been confirmed for 16 blocks. This extra path is added as a script in the script tree.\nKey path spend Spending via the key path just requires a signature from the remote party which they will tweak with the TapTweak.\nScript path spend Once the output has been confirmed for 16 blocks, it becomes fair game. Anyone is allowed to spend from this output as long as they can produce the following spending script:\nNotice anything here? If you were a third party trying to sweep some expired anchor outputs for some free sats, would you be able to produce the above spending script? The answer is: yes, but only if you know what P_remote is! Before reading on, I suggest taking some time to think about how you could possibly come to know what P_remote is. It is not present in the funding transaction, nor is it present in the commitment transaction. Scroll up through the diagrams to see if you can see where it is revealed.\nOk ready? It is only revealed if the to_remote output is spent as it appears in the witness required to spend that output. This means that the remote anchor is spendable by anyone after 16 blocks only when the to_remote output has been spent.\nLocal Anchor Output This is the output that you, the local party, will be able to use to CPFP the commitment transaction. And just like the remote anchor, it is spendable by anyone after 16 blocks. So the internal key is P_local_delayed and the “anyone can spend after 16 blocks” script is put in the script tree.\nKey path spend Spending via the key path just requires a signature from the local party which they will tweak with the TapTweak.\nScript path spend Just like the remote anchor, the parties wanting to spend via the “anyone can spend” path require the P_local_delayed public key to first be revealed. This is revealed when the to_local output is spent by the local party via the script path and importantly this is also revealed even if the revocation path is taken in the to_local output! This is the whole reason why the internal key for the to_local output could not just be the revocation key and why we have to instead force a script path spend that also reveals the P_local_delayed key. From the witness below, you can see why knowledge of the P_local_delay key is required for someone to spend this anchor output via the script path. If it was not revealed then there is a chance that the output would remain floating in the UTXO set forever since third parties would not know how to spend it.\nOffered HTLC Output An offered HTLC pays out to the remote party if they reveal the pre-image to a given hash before a certain CLTV timeout. After the timeout, the local party will be able to claim the output via the htlc-timeout transaction (details on that below). If the commitment transaction is a revoked state, then the remote party should be able to sweep the output at any time.\nKey path spend The internal key is set to the revocation key which is spendable only by the remote party and only if the commitment transaction is for a revoked state. If this is the case, then the remote party can sweep the output with the following signature:\nScript path spends The other two spend paths, the success and timeout paths, are placed in the script tree and spending either of them requires providing a valid witness for the script, the script itself and a control block which this time does include an inclusion proof since more than one script is present in the tree.\nSuccess Path To spend via the success path, the following witness is required.\nTimeout Path The following witness is required to spend via the timeout path. The transaction that will spend the timeout path is the htlc-timeout transaction - more details on that transaction later on. If you need a recap on the reason why second-stage htlc transactions are necessary, check out this post.\nAccepted HTLC Output The accepted HTLC output pays out to an htlc-success transaction if we (the local party) are able to provide the pre-image for the given payment hash. Otherwise, after a certain cltv_expiry, the remote party will be able to sweep the funds back via the timeout path. If the commitment transaction is a revoked state, then the remote party should be able to sweep the output at any time.\nKey path spend The internal key is set to the revocation key which is spendable only by the remote party and only if the commitment transaction is for a revoked state. If this is the case, then the remote party can sweep the output with the following signature:\nScript path spends The other two spend paths, the success and timeout paths, are placed in the script tree and spending either of them requires providing a valid witness for the script, the script itself and a control block which this time does include an inclusion proof since more than one script is present in the tree.\nSuccess Path To spend via the htlc-success transaction, the following witness must be provided:\nTimeout Path To spend via the timout path, the remote party must provide the following witness:\nHTLC Timeout and Success Transactions The htlc-timeout and htlc-success transactions look mostly identical so here is one diagram to describe both:\nThe first difference between the htlc-success and htlc-timeout transactions is the input they are spending and hence, the witness required for spending that input. The htlc-timeout transaction spends the timeout path of the offered HTLC output and the htlc-success transaction spends the success path of the accepted HTLC output. The other difference is the Locktime: the htlc-timeout transaction has a Locktime of cltv_expiry and the htlc-success transaction has a Locktime of zero.\nThe outputs of the htlc-success and htlc-timeout transactions are identical: they are immediately spendable by the remote party via the revocation path if the associated commitment transaction is for a revoked state. Otherwise, they are spendable by the local party after to_self_delay blocks have been confirmed.\nThe key path and script path spend scripts are exactly the same as for the to_local output.\nWrap Up If you have made it all the way through that, congrats! You should now have a pretty solid understanding of the structure of Taproot channel commitment transactions. My next blog post will cover how the various channel peer messages will need to be updated to support MuSig2 signing. I expect it to be a short and sweet one.\nAs always, if you have any questions, comments or corrections, please feel free to leave a comment down below :)\n","permalink":"https://www.ellemouton.com/posts/taproot-chan-txs/","summary":"A deep-dive into the structure of Taproot channel transactions","title":"Taproot Channel Transactions"},{"content":"In my last blog post, I promised a follow-up post on the workings of Taproot channels. However, when I started working on it, I realised that it might be a good idea to first dedicate a post to recap the preliminaries that will be required in order to understand the follow-up Taproot channel articles. So here you go!\nOverview This post will cover some basics around Taproot outputs and how to spend them via either the key or script paths. It will also cover the MuSig2 flow between two signing parties. Note that I won’t go into extreme detail for either of these topics. Instead, this post is aimed at refreshing your memory on these topics or giving you enough of an understanding of how Taproot outputs and MuSig2 work so that the follow-up articles are more easily digestible. There are better articles out there for you if you want to get into the nitty-gritty of these topics and of course you can always go check out the BIPs if you are brave: Schnorr signatures, Taproot, Tapscript and MuSig2.\nOk, enough chit-chat. Onto the good stuff!\nA quick note on BIP340 public keys Public keys will mostly be encoded as 32-byte arrays instead of the usual 33-byte compressed public key representation that you might be used to. If the secp256k1 curve is plotted over a non-finite field (as shown below) then you can see that for every x-coordinate, there are two possible y-coordinates. Since the curve is actually over a finite field with an odd order, one y-coordinate for a given x-coordinate will always be even and the other one will be odd. The assumption for 32-byte encoded public keys is that the y-coordinate is always the even one. This means that if you want to create a valid BIP340 signature but your private key, d, produces a public key, P, with an odd y-coordinate, then all you need to do is negate your private key. This will produce public key P’ which has the same x-coordinate as your original public key but with an even y-coordinate. For more information regarding BIP340 public keys and signatures (also known as Schnorr signatures), check out the BIP itself.\nTaproot Outputs A Taproot output shows up in the scriptPubKey section of a transaction (just like all other outputs) and has the following form:\nThe OP_1 indicates that this is a SegWit Version 1 output (a.k.a. Taproot output) and what follows are 32 bytes that represent the output key (see BIP340 public keys above). I will often use Q to refer to this key. To give the full picture, here is a Taproot output in a transaction:\nOk cool. But what exactly is in this output? Is it just like a P2PK output? No. That would be lame. The truth is that this simple-looking output could be a huge variety of different things. It could be a simple single public key (yes, like a P2PK). It could be an n-of-n MuSig2 public key. It could also have a bunch of script branch options, or it could even be a combination of all the above! Let’s break these options down a bit.\nSingle Key or n-of-n MuSig2 outputs If you wanted to just create an output that sends to a single public key, P, then this is easy to do. In this case, your output key, Q, just becomes your key, P, which is often called the internal key.\nTo spend this output, all you need is to provide a BIP340 signature in the witness which you would calculate using the private key, d, used to derive P. See the note explained in the BIP340 Public Keys section about possibly needing to negate your private key first.\nNow, what if you instead wanted to use an n-of-n aggregate MuSig2 public key? Turns out that this will look exactly the same on-chain as for the single key case explained above! All that changes is the steps that you and your fellow signers need to take to set up the aggregate public key and then to calculate the final signature. But once all that is complete, what ends up on-chain looks no different.\nScript Paths Here is where the magic really happens. You can also have the option of spending your Taproot output via a script and each output can have multiple scripts from which it can be spent. Another cool thing is that if you choose to include script paths in your Taproot output, you can still add a regular key path like before. Let’s say, for example, that you want to be able to spend your output at any time, but you also want to add three script paths so that it can also be spent in other scenarios: perhaps after 30 days you want your partner to be able to spend the output. That would be one script path. If you also have two other script paths (perhaps one is a 2-of-3 multi-sig and the other requires a pre-image reveal), then your Taproot output would be constructed as follows:\nLet’s walk through the above diagram a bit:\nFirst, the three scripts (Script A, Script B and Script C) are all put into a Merkle tree as shown bottom right. The root of this Merkle tree is then hashed along with our internal key, P, to get the 32-byte tweak, t. This tweak is converted to its elliptic curve point form by multiplying it with the generator point, G, to get T which is then added to our internal key, P, to get the final output key, Q. I have skipped over some things here such as the details of the script encodings and also how the scripts are hashed in the Merkle tree so check out the relevant BIPs if you are interested.\nAlrighty - our fancy Taproot output has been set up! But now… how do we spend it? There are two ways of spending this transaction: the first is via the internal key, P. We call this a key path spend. The other way is via one of the scripts in the tree. This type of spend is called a script path spend.\nKey Path Spends Spending via the key path is very simple and is similar to spending the output if it was just a normal un-tweaked key as described earlier on. The only difference is that you will need to tweak your private key, d, with the tweak, t. In other words, your new private key becomes d + t which is what you will use to calculate your signature. That’s it! If you spend the output via the key path, there is no need to reveal any of the scripts and so anyone looking at the spend on-chain will have no clue that the output even had the potential to be spent via a script path.\nScript Path Spends To spend via one of the script paths requires a slightly more complicated witness. Let’s say we want to spend via Script B. We will need to do a few things to convince a verifier that we have the right to spend the output:\n We must provide a valid spending script for Script B. We need to prove that Script B is actually embedded in the output.  Step 1 is pretty simple: just provide the valid witness script for Script B along with Script B itself. Step 2 is slightly more involved. To prove that Script B is embedded in Q, we need to give the verifier all the building blocks required in order to actually construct Q. These building blocks are put in what is called the “control block”. The first thing in the control block is the internal key, P. It also contains the Merkle proof that allows the verifier to compute the Merkle tree root. The witness already includes Script B itself (it was required for step 1), so the verifier can compute hB (see the diagram above showing the Merkle tree construction) themselves, and so we just need to provide hA and hC. The validator will use these hashes to calculate the script_root and then hash this along with the internal key, P, in order to arrive at the tweak, t. The validator can then compute the corresponding tweak point, T, add that to the internal key, P, to get the output key, Q. The final thing that the control block must include is a bit indicating if the final Q point has an odd or even y-coordinate so that the validator can check if the Q they computed does have the correct y-coordinate.\nIt is important to note that no knowledge of d (the private key for the internal key, P) was required for spending via Script B (assuming of course that Script B itself does not involve P). Another cool thing is that we did not need to reveal the contents of the other scripts in the tree, only their hashes.\nBIP86 Tweaks There is a clever trick that can be used if you would like to create an output with no script path that allows you to also prove to a third party that there is no script path. All you do is construct Q as if you were constructing an output with script paths but the script root is left empty.\nSpending this output can now only be done via the key spend path using private key d + t. Then, P can be provided to any third parties who want proof that there is no script path. They would use P to compute t and T and then would verify that P + T is equal to the output key, Q. More info about this can be found in BIP86.\nMuSig2 With the Taproot soft fork, bitcoin nodes now have an understanding of BIP340 signatures (or Schnorr signatures). The beauty of these signatures is their linearity: the owner of public key P_1 can create a partial signature, sig_1 for the message msg and the owner of public key P_2 can create sig_2 for the same message. The two parties will then be able to combine their signatures such that sig where sig = sig_1 + sig_2 is a valid signature for the aggregate of their public keys: P = P_1 + P_2.\nThis is really cool because it means that instead of needing to create a long n-of-n multisig script and then needing to pay for the blockchain space to store each of the n signatures, only one signature will be needed and no long script will be required at all. Instead, only a single public key (which is actually an aggregate public key) needs to appear on-chain.\nThe tricky part here is everything that needs to happen off-chain during the setup of this aggregate public key as well as for the creation of the final signature. MuSig2 is the protocol that defines how this should be done. The various steps have been carefully thought through in order to keep the process trust-less and to protect parties from attacks such as key cancellation.\nBIP327 defines the MuSig2 protocol along with a bunch of algorithms that should be used for the various steps of the process. Since the aim of this article is to provide all the building blocks required for understanding Lightning Taproot channels, I will only talk about MuSig2 at an API level using the defined algorithms and will focus more on how it will be used in Lightning. If you would like to dig into it more you can check out the BIP itself. I have also implemented all the MuSig2 methods from scratch here if you are the type of person who prefers looking at code.\nMuSig2 vs n-of-n Multisig An important thing to keep in mind is that with n-of-n multisig outputs, parties can generate their signatures completely independently of the other parties. As long as they have the message to be signed along with their private key, they can create a signature. This signature can then safely be distributed to the other parties and eventually the transaction witness will have all n signatures. In other words: no interaction is required between parties at signing time. With n-of-n MuSig2 this is not the case since there is one public key on-chain and thus one signature needs to be produced. The n parties have to interact with each other in order to produce this final signature.\nExplanation by example Let’s walk through the case where two parties, Alice and Bob, want to set up a 2-of-2 MuSig2 output and then create a signature to spend from it.\nThis first diagram shows the initial state: Alice and Bob both have private keys and the corresponding public keys and currently the two parties have no shared knowledge.\nWhen the two parties decide to construct an output together, they will first need to exchange public keys. Both parties will then use the MuSig2 KeySort algorithm to sort the keys and then the KeyAgg algorithm to aggregate the keys. This will produce the aggregate key, P_agg, which would be the key that would appear in the transaction output.\nOnce Alice and Bob have a shared message that they want to sign (which would most likely be the spending transaction), they can move onto the signing phase.\nStep one of the signing phase involves each party generating nonces. They will each generate a secret nonce, called the secnonce, and from the secnonce the associated public nonce, called the pubnonce, can be determined. Note that each secnonce is actually made up of two private keys and each pubnonce is made up of the two public keys associated with those private keys. The details of why there are two nonces is outside the scope of this post. Alice and Bob will then need to exchange the public nonces and then both parties will use the MuSig2 NonceAgg function to determine the aggregate nonce: aggnonce. Note that this step had nothing to do with the message to be signed meaning that this step can actually take place before the message to be signed is known.\nWhen the public nonces have been exchanged and both parties know the message to be signed then each party can use the MuSig2 Sign function to produce partial signatures.\nThe final step is for the parties to exchange their partial signatures. Each party can then use the MuSig2 PartialSigAgg function to calculate the final signature. This signature will be a valid signature for P_agg over the message, msg.\nIt is important to become familiar with the above MuSig2 flow because it will be used very often in the next few articles. In Taproot channels the funding output of a channel will be a MuSig2 aggregate public key. This means that every commitment transaction created that spends from the funding output will need to go through this signing flow. Since channel states in Lightning are asymmetric, this also means that this flow will need to happen twice per state update: once to sign the local commitment transaction and once to sign the remote one. But more on that in the next blog post :)\nThanks for reading! I hope that was useful. If you think there is anything that could use clarification or that is incorrect then please don’t hesitate to reach out to let me know.\n","permalink":"https://www.ellemouton.com/posts/taproot-prelims/","summary":"A recap of the building blocks required for Taproot channels","title":"Taproot and MuSig2 recap"},{"content":"In this article, I will go over the process of opening a Lightning Network channel as it works today (pre taproot channels). I will start with the channel_open message and will talk in detail about it and all the messages involved in “opening” the channel ending with the channel_announcement message.\nMy goal for this article is to recap today’s channel open flow so that we can later focus only on the changes required for opening a taproot channel1.\nThis article replaces my previous short article on channel opens. It includes more detail and more diagrams (yay diagrams!). I will assume that the reader understands the structure of a commitment transaction and understands why they are asymmetric. If you feel a bit rusty in this area, please check out my articles explaining these concepts in detail.\nThe end goal Before we dig into the first step, I think it is useful to illustrate the goal we are trying to reach. I will once again use our trusty peers, Alice and Bob, to tell the story.\nAlice and Bob are both Lightning Network nodes. Alice’s node ID (ie, the public key used to identify her node) is alice_node_id and Bob’s node ID is bob_node_id. Their main two goals are:\n They want to open a channel between themselves in a trustless way. They want to be able to advertise their new channel so that the rest of the network can use it for routing.  Opening the channel A channel is opened once both parties have the ability to fully sign their respective commitment transactions and once the funding transaction is on chain. Throughout this explanation, I will use diagrams and colours to illustrate the process. In the diagrams, a white background means that the field of the transaction is not yet known. A coloured-in field indicates that the field value is known. Any green fields are used to highlight any of Alice’s public keys or signatures and any blue fields are used to show Bob’s.\nThere are three transactions in play for the opening of a channel. The first is the funding transaction which will need to go on chain. The other two are the first commitment transactions held by Alice and Bob describing the initial state of the channel.\nHere are the diagrams used to describe the three transactions. Note that at the moment we still don’t know anything about the parameters of the channel and so all fields still have a white background. Remember that our end goal is to have all these fields coloured in.\nThe open_channel message The first step of the process is Alice deciding that she wants to open a channel with Bob. In doing so, she also becomes the funder of the channel. Let’s say that Alice decides that she wants to open a 1 BTC channel and wants to immediately give Bob half of the channel’s capacity (0.5 BTC). Alice will now put together an open_channel message that she will send to Bob. Let’s take a look at the relevant open_channel parameters (I am leaving out any parameters that don’t have anything to do with the channel-open phase). You can skip this table if you want. It is just a reference for incase you want to check what the meaning of a field is.\nLet’s now fill in Alice’s values for these fields:\nAlice sends this message over to Bob.\nSince Alice has decided on the type of channel she wants to open (default channel type as opposed to an anchors, taproot etc) as well as the channel capacity, she can already piece together quite a large part of the funding transaction:\nSince she knows the capacity of the channel she wants to open, she can choose some of her UTXOs to be inputs to the funding transaction. Since Alice does not yet know which pub key Bob would want to use for the channel, she cannot yet finalise the channel funding output and hence can also not yet produce signatures for the inputs.\nSince Alice has decided on the channel type (and hence the commitment transaction structure), she can also start putting together the pieces of the commitment transactions. If we assume that Bob is delighted by this channel-opening proposal from Alice, then from this open_channel message, he can also start putting together the pieces. Remember that both parties will need to construct both commitment transactions since they will both need to be able to sign their peer’s transactions. Let’s take a look at what pieces they are now both able to fill in:\nAlice’s commitment transaction has filled in quite nicely. It has the structure of a default, non-anchor channel transaction and all her public keys have been filled in (alice_local_delayed_pk_1 is derived using her delayed_payment_basepoint and her first_commitment_point). Since she hasn’t received any messages from Bob yet, she has not yet been able to fill in any of his pub keys and since the funding transaction is still incomplete, she also can’t yet know the TXID to point the input of this commitment transaction to.\nBob’s commitment transaction (from his perspective) is looking a bit more complete:\nLike Alice, he also cannot yet fill in the funding transaction’s TXID, but he can fill in a few other things:\n The alice_pubkey_1, alice_to_self_delay, push_amt and local_amt values are taken as is from the open_channel message alice_payment_key_1 is derived using Alice’s payment_basepoint and first_commitment_point revoke_pubkey_1b is derived using Alice’s revocation_basepoint and Bob’s first_per_commitment point (at this point Alice cannot derive this point yet since she has not received his first_per_commitment_point)  Ok cool! Time for Bob to indicate to Alice his acceptance of the request by sending the next message: accept_channel\nThe accept_channel message The message shares many of the fields from open_channel. Here is the message that Bob will put together:\nWhen Alice gets this message from Bob, she can now complete the funding transaction’s output and can create the signatures for the inputs. Since everything is filled in, the TXID for the funding tx is now also known.\nAlice can now also further fill in her own commitment transaction:\n she is now able to use the values sent by Bob to fill in bob_pubkey_1, bob_payment_key_1, bob_to_self_delay and revoke_pubkey_1a since the TXID for the funding tx is now known, she can complete the input too.  She now knows everything she needs to know in order to sign this transaction herself but she is still missing Bob’s signature for this transaction.\nBob’s view of his commitment transaction is still the same as before since he learned no new info after sending the accept_channel message.\nNow that Alice knows the txid for the funding transaction, she is also able to complete her view of Bob’s commitment transaction and so she can produce her signature for his transaction. This is where the next message comes in: funding_created.\nThe funding_created message Alice will now use the funding_created message to tell Bob the TXID and index of the funding transaction along with her signature for Bob’s commitment transaction. Note that he still wont be able to broadcast his transaction since Alice has not yet broadcast the funding transaction.\nOnce the funding message has been received, Bob can fill in the rest of his commitment transaction:\nAlice won’t broadcast the funding transaction until she has a valid signature from Bob for her commitment transaction. Enter funding_signed:\nNotice that this is the first message to use the real channel ID instead of the temporary one.\nThis was the last piece of the puzzle for Alice. She now has all the info she needs to be able to sign her commitment transaction if ever needed.\nAlice can now safely broadcast the funding transaction. Both she and Bob will watch the chain for the confirmation of the funding transaction. Once it has reached the minimum_depth specified by Bob in accept_channel, both sides will exchange the channel_ready message (previously named funding_locked). This message serves as both a signal to the peer to indicate to them that the channel is ready for use (and that the channel announcement process can now start if the peers decided on an announced channel) and also to send across each peer’s second_per_commitment_point that they should use in their second commitment transaction.\nOk cool! We have completed our first goal: Alice and Bob have opened a channel between themselves in a trust-less way. Now we move on to step 2: announcing this channel to the network!\nAnnouncing the channel This part is fairly painless. Basically there is just one message, channel_announcement, that Alice and Bob need to construct together and once it is complete, then they can broadcast it to the network. Other nodes will use this message to prove a few things:\n That the channel funding tx is actually an existing, unspent UTXO with an acceptable number of confirmations. That the funding transaction output actually looks like a lightning channel funding transaction That the channel is actually owned by the keys that Alice and Bob say they used to construct the channel. That Alice and Bob both agree on the message being broadcast.  An incomplete version of the channel_announcement message looks as follows:\nh is the hash of all the data that will be covered by the signatures. In order to complete the message, Alice and Bob both compute a signature over h using the private keys associated with their node IDs and the pubkeys they used in the funding transaction. They then both exchange the announcement_signatures message in order to communicate these signatures to each other:\nNow both nodes can put together the complete channel_announcement message:\nLet’s go over the steps that a node (Charlie) receiving this message will go through in order to verify the new channel that Alice and Bob claimed to have opened.\n First, Charlie will use the short_channel_id included in the message to make sure that the channel’s funding transaction actually exists on-chain, that it has a sufficient number of confirmations and that it is in fact unspent. Then, Charlie will also check that the unspent output actually does look like a Lightning channel owned by alice_pubkey_1 and bob_pubkey_1. He will do this by using the advertised pubkeys to reconstruct the P2WSH and ensure that it is the same as the one found on-chain. Now, Charlie will want to confirm that the nodes owning the pubkeys found in the channel funding output do in fact belong to the nodes owning the node ID pubkeys. This is done by verifying the alice_pubkey_1_sig and bob_pubkey_1_sig signatures. If these signatures are valid, then it is clear that the owners of alice_pubkey_1 and bob_pubkey_1 agree to being associated with alice_node_ID and bob_node_ID since the message signed includes these nodes IDs. Finally, Charlie will also want to ensure that owners of the node ID pubkeys agree to being associated with the new channel. This is done by verifying the alice_node_ID_sig and bob_node_ID_sig signatures. If these signatures are valid, then it is clear that the owners of alice_node_ID_sig and bob_node_ID_sig agree to being associated with alice_pubkey_1 and bob_pubkey_1 since the message signed includes these pubkeys.  Alice and Bob are done! Their channel is open and other nodes in the network, like Charlie, will happily use the new channel.\nIn the next post, I will dive into how the above process will change with taproot channels (given the current proposal). The main thing that will need to change is how signatures are dealt with. In all the above cases, Alice and Bob didn\u0026rsquo;t really need to do anything special when they were generating their signatures since they each would need to provide their own signature to sign for the 2-of-2 funding transaction. But with taproot, the funding output will use Musig2 to combine the pubkeys of Alice and Bob and so any signatures will need to involve the Musig2 signing protocol… But let’s leave the details of that for next time :)\n  https://github.com/lightning/bolts/pull/995\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"https://www.ellemouton.com/posts/open_channel_pre_taproot/","summary":"A deep dive into opening a pre-taproot Lightning Network channel","title":"Opening and announcing a pre-taproot LN channel"},{"content":"In this post, I will briefly describe the needs of a bitcoin light client and why compact block filters satisfy these needs better than Bloom filters do. Then I will dive into exactly how compact block filters work and will follow this with a step by step guide for constucting such a filter from a testnet block.\nThe purpose of block filters A bitcoin light client is software that can back a bitcoin wallet without storing the blockchain. This means that it needs to be able to broadcast transactions to the network but most importantly it must be able to pick up when there is a new transaction that is relevant to the wallet it is backing. There are two ways a transaction becomes relevant to a wallet: either it is sending money to the wallet (creating a new output to a wallet address) or it is spending one of the UTXOs that the wallet owns.\nWhat was wrong with Bloom filters? Before BIP 158 came along, the most widely used method for light clients was to use Bloom filters1 as described in BIP 37. With a bloom filter, you take all the objects you are interested in (script pub keys spent or created), hash them a couple times and add the result of each to a bit map called a Bloom filter. This filter represents what you are interested in. You would then send this filter to a trusted bitcoin node and ask them to send you anything that matches your filter. The problem with this is that it is not very private since you are revealing some information to the bitcoin node you are sending this filter too. They can start getting an idea of the transactions you are interested in as well as the ones you are definitely not interested in. They can also just decide not to send you a transaction that matches the filter. So as you can see, it isn’t great for the light client. But it is also not great for the bitcoin node serving the light client. Each time you send them a filter, they have to load the relevant block from disk and determine which transactions match your filter. You could just spam them with fake filters and effectively DOS them. It takes very little energy to create a filter and lots to respond to it.\nIntroducing Compact Block Filters: Ok, take two. What we want is:\n More privacy Less asymmetry in the client - server work load. Ie, the server should be required to do way less work. Less trust. The light client shouldn\u0026rsquo;t need to worry about the server holding back relevant transactions.  With compact block filters, the server (full node) will for each block construct a deterministic filter that includes all the objects in the block. This filter can be calculated once and persisted. If light clients request a filter for a block, there is no asymmetry since the server wont have to do any more work than the client had to do when making the request. A light client can also choose to download the filters from multiple sources to ensure they match and can always download the full block and check for itself if the filter that the server provided was indeed correct given the blocks contents. Another bonus is that this is way more private. The light client no longer sends a fingerprint of the data it is interested in to the server. And so it becomes way more difficult to analyse the light client\u0026rsquo;s activity. The light client gets these filters from the server and checks for itself if any of its objects match what is seen in the filter and if it does match, then the light client asks for the full block. One thing to note with this way of doing things is that full nodes serving the light clients will need to persist these filters and the light clients might also want to persist a few filters and so it is important that the filters are as small as possible (hence the name, compact block filters).\nCool! Now we get to the cool stuff. How is this filter created? What does it look like?\nWhat do we want?\n We want to put fingerprints of certain objects in the filter so that when clients are looking to see if a block maybe contains info relevant to them, they can take all their objects and check if the filter matches on those objects. We want the filters to be as small as possible. Effectively we want to sort of summarise some of the block info… in a size much much smaller than the block.  The info included in the basic filter is: every transaction\u0026rsquo;s input\u0026rsquo;s scriptPubKey being spent and every transaction\u0026rsquo;s output\u0026rsquo;s scriptPubKey being created. So something like this:\nobjects = {spk1, spk2, spk3, spk4, ..., spkN} // A list of N scriptPubKeys. Technically we could just stop here and say this list of scriptPubKeys is our filter. It is a condensed version of what is in the block chain and contains the info the light client needs. With this list they could tell with 100% certainty if something they are interested in is in the block. But it is still pretty big. So the next step is all about making this list as compact as possibly. This is where things get insanely cool.\nFirst we convert each object into a number in a range such that the object numbers are uniformly distributed in that range: Let\u0026rsquo;s say we have 10 objects (N = 10), then we have some function that turns each of the objects into a number. Let’s say we chose the range [0, 10] since we have 10 objects. Now the hashing-plus-convert-to-number function we use will take each object and produce a number in the space from [0, 10]. It is uniformly distributed in this space. That means that, after ordering them, we will get (in the very very ideal case) something like this:\nFirst of all, wow that is so great cause we have drastically decreased the size of an objects finger print. Each one is just a number now. Ok so, let this be our new filter:\nnumbers := {1,2,3,4,5,6,7,8,9,10} Now a light client downloads the filter and wants to see if one of the objects they are looking for is matched in this filter. All they need to do is take their objects and do the same hashing-plus-convert-to-number scheme and check if any of the numbers are in the filter. What is the problem? The filter has a number for each possible number in the space! Meaning that absolutely any object will match on this filter. In other words, the false-positive rate of this filter is 1. This is no good. We have lost too much info on our quest to compress the data in the filter. What we need is a higher false-positive (fp) rate. Ok so let’s say we want a false positive rate of 5. Then what we want is to have our objects be mapped uniformly to a space of [0, 50]:\nThis is starting to look a bit better. If I am a client downloading this filter and I check if my objects are maybe in the filter, there will be a 1/5 chance that if it matches, it is a false positive. Great so now we have mapped 10 objects to numbers between 0 \u0026amp; 50. This new list of numbers is our filter. Again, we could stop here… but we can compress this even further!!\nWe have this list of ordered numbers that we know are distributed uniformly across this space between [0, 50]. We know that there are 10 items in the list. What this means is that we can deduce that the most likely difference between each of the numbers in this ordered list is about 5. In general, if we have N items and a false positive rate of M, then the space will be of size N * M. So the numbers in the space can range from 0 to N * M, but the difference between each number (once ordered) will be roughly M. M will definitely be a smaller number to store than a number in the N * M space. So what we can do is instead of storing each number, we can instead store the difference of each successive number. In the above case, this would mean that instead of storing [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50], we just store [0, 5, 5, 5, 5, 5, 5, 5, 5, 5] and then it is trivial to reconstruct the original list. As you can gather, storing the number 50 requires way more bits than storing the number 5. But why stop there? We can compress this even further!\nThis is where Golomb-Rice Coding comes in. This encoding works well for a list of numbers that will all very likely be close to some number. This is what we have! We have a list of numbers that will all very likely be close to 5 (or, in general, close to our FP rate of M) and so taking the quotient of any number in the list with that number (dividing each number by 5 and ignoring the remainder) will very likely be 0 (if the number is slightly less than 5) or 1 if the number is slight more than 5. The quotient could be 2, 3 etc but the likelihood decreases a lot. Great! So we can take advantage of this knowledge and say that we will encode a small quotient with the smallest number of bits that we can and use more bits to encode larger, unlikely, quotients. Then we also need to encode the remainders (since we want to be able to reconstruct the values exactly) and these will always be numbers between [0, M-1] (in our case, [0, 4]). For encoding the quotients, we use the following mapping:\nThe mapping above is easy to read: The number of 1s indicates the quotient we are encoding and the 0 indicates the end of the quotient encoding. So for each number in our list, we encode the quotient using the above table and then we convert the remainder to binary using the number of bits needed to encode the maximum of M-1. In our case, that is 3 bits. Here is a table showing the encoding of the possible remainders in our example:\nSo, in our ideal case example, our list of [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5] can be encoded as follows:\n0000 10000 10000 10000 10000 10000 10000 10000 10000 10000 Before we move on to a more realistic example, let’s see if we can reconstruct our original list from this filter.\nOk so we have: “0000100001000010000100001000010000100001000010000”. We know the how Golomb-Rice Coding encodes quotients and we also know that M is 5 (since this will be public knowledge known to everyone using this filter construction). Since we know M is 5, we know that 3 bits will be used to encode the remainders. So we can take our filter and produce the following quotient-remainder tuples:\n[(0, 0), (1, 0), (1, 0), (1, 0), (1, 0), (1, 0), (1, 0), (1, 0), (1, 0), (1, 0)] We know that the quotients were produced by dividing number by M (5), so we can reconstruct these:\n[0, 5, 5, 5, 5, 5, 5, 5, 5, 5] And we know that this list represents differences of numbers, so we can reconstruct the OG list:\n[0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50] A more realistic example We will now try to construct a filter from an actual Bitcoin testnet block. I\u0026rsquo;m going to use block 2101914. Let’s see what it’s actual filter is:\n$ bitcoin-cli getblockhash 2101914 000000000000002c06f9afaf2b2b066d4f814ff60cfbc4df55840975a00e035c $ bitcoin-cli getblockfilter 000000000000002c06f9afaf2b2b066d4f814ff60cfbc4df55840975a00e035c { \u0026quot;filter\u0026quot;: \u0026quot;5571d126b85aa79c9de56d55995aa292de0484b830680a735793a8c2260113148421279906f800c3b8c94ff37681fb1fd230482518c52df57437864023833f2f801639692646ddcd7976ae4f2e2a1ef58c79b3aed6a705415255e362581692831374a5e5e70d5501cdc0a52095206a15cd2eb98ac980c22466e6945a65a5b0b0c5b32aa1e0cda2545da2c4345e049b614fcad80b9dc9c903788163822f4361bbb8755b79c276b1cf7952148de1e5ee0a92f6d70c4f522aa6877558f62b34b56ade12fa2e61023abf3e570937bf379722bc1b0dc06ffa1c5835bb651b9346a270\u0026quot;, \u0026quot;header\u0026quot;: \u0026quot;8d0cd8353342930209ac7027be150e679bbc7c65cc62bb8392968e43a6ea3bfe\u0026quot; } Ok shweeeeeet, let’s see if we can reconstruct this filter from the block.\nThe full code for this can be found in this github repo. I will just show some pseudo code snippets here. The beef of the code is the function called constructFilter which takes in a bitcoin client that can be used to make calls to bitcoind and the block in question. The function looks something like this:\nfunc constructFilter(bc *bitcoind.Bitcoind, block bitcoind.Block) ([]byte, error) { // 1. Collect all the objects from the block that we want to add to the filter  // 2. Convert all the objects to numbers and sort them.  // 3. Get the differences between the sorted numbers  // 4. Encode these differences using Golomb-Rice Coding } Ok so step 1 is to collect all the objects from the block that we want to add to the filter. From the BIP, we know that these objects are all the scriptPubKeys being spent as well as all the scriptPubKeys of each output. Some extra rules from the BIP are that we skip the input for the coinbase transaction (since it is empty and meaningless) and we skip any OP_RETURN outputs. We also de-duplicate the data. So if there are two identical scriptPubKeys, we only include one in the filter.\n// The list of objects we want to include in our filter. These will be // every scriptPubKey being spent as well as each output\u0026#39;s scriptPubKey. // We use a map so that we can dedup any duplicate scriptPubKeys. objects := make(map[string] struct{}) // Loop over every transaction in the block. for i, tx := range block.Tx { // Add the scriptPubKey of each of the transaction\u0026#39;s outputs  // and add those to our list of objects.  for _, txOut := range tx.Vout { scriptPubKey := txOut.ScriptPubKey if len(scriptPubKey) == 0 { continue } // We don\u0026#39;t add the output if it is an OP_RETURN (0x6a).  if spk[0] == 0x6a { continue } objects[skpStr] = struct{}{} } // We don\u0026#39;t add the inputs of the coinbase transaction.  if i == 0 { continue } // For each input, go and fetch the scriptPubKey that it is  // spending.  for _, txIn := range tx.Vin { prevTx, err := bc.GetRawTransaction(txIn.Txid) if err != nil { return nil, err } scriptPubKey := prevTx.Vout[txIn.Vout].ScriptPubKey if len(scriptPubKey) == 0 { continue } objects[spkStr] = struct{}{} } } Ok great, we have all the objects we care about. And now we can also define the variable N to be the length of the objects map. In this example, N is 85.\nThe next step is to convert each of the objects to numbers spread uniformly across a range. Remember that this range depends on the false-positive rate we want. BIP158 defines the constant M to be 784931. This means that we want every 1/784931 matches to be a false-positive. As we did in our earlier example, we take this fp rate of M and multiply it by N to get the range that we want all our numbers to lie in. We define this as F where F = M*N. In our case, we have 85 objects and so F=66719135. I am not going to go into the details of the function used to map our objects to numbers (you can check out the details of this in the code in the linked repo). All you need to know for now is that it takes in an object, the constant F which defines the range that it needs to map the object to, and a key which is the block hash. Once we have all the numbers, we sort the list in ascending order and then we also create a new list called differences which will hold the differences between each sequential number in the sorted numbers list.\nnumbers := make([]uint64, 0, N) // Iterate over all the objects, convert them to numbers lying uniformly in the range [0, F] // and add them to the `numbers` list. for o := range objects { // Using the given key, max number (F) and object bytes (o),  // convert the object to a number between 0 and F.  v := convertToNumber(b, F, key) numbers = append(numbers, v) } // Sort the numbers. sort.Slice(numbers, func(i, j int) bool { return numbers[i] \u0026lt; numbers[j] }) // Convert the list of numbers to a list of differences. differences := make([]uint64, N) for i, num := range numbers { if i == 0 { differences[i] = num continue } differences[i] = num - numbers[i-1] } Awesome! Here is a graph showing the values in the numbers and differences lists:\nAs you can see, the 85 numbers are really nicely uniformly distributed across the space! And this results in the values in the differences list being pretty small.\nThe last step now is to use Golomb-Rice Coding to encode this differences list. Recall from the earlier explanation that we need to divide each difference by it’s most likely value and then we encode that quotient along with the remainder. In my earlier example I said that this most-likely value would be the M that we choose and that the remainder would then lie in the range [0, M]. However, this is not what is done in the BIP as it was found2 that this is in fact not the ideal way to choose the Golomb-Rice coder parameter when trying to optimize for the smallest possible size of the final encoded filter. And so instead of using M, a new constant of P is defined and P^2 is used as the Golomb-Rice parameter. P is defined as 19. This means that each difference value is divided by 2^19 to get the quotient and remainder and the remainder is then encoded in binary in 19 bits.\nfilter := bstream.NewBStreamWriter(0) // For each number in the differences list, calculate the quotient and // remainder after dividing by 2^P. for _, d := range differences { q := math.Floor(float64(d)/math.Exp2(float64(P))) r := d - uint64(math.Exp2(float64(P))*q) // Encode the quotient.  for i := 0; i \u0026lt; int(q); i++ { filter.WriteBit(true) } filter.WriteBit(false) filter.WriteBits(r, P) } Great stuff! Now when we print out this filter, we get:\n71d126b85aa79c9de56d55995aa292de0484b830680a735793a8c2260113148421279906f800c3b8c94ff37681fb1fd230482518c52df57437864023833f2f801639692646ddcd7976ae4f2e2a1ef58c79b3aed6a705415255e362581692831374a5e5e70d5501cdc0a52095206a15cd2eb98ac980c22466e6945a65a5b0b0c5b32aa1e0cda2545da2c4345e049b614fcad80b9dc9c903788163822f4361bbb8755b79c276b1cf7952148de1e5ee0a92f6d70c4f522aa6877558f62b34b56ade12fa2e61023abf3e570937bf379722bc1b0dc06ffa1c5835bb651b9346a270 Apart from the first two bytes, this matches the filter we got from bitcoind exactly! Why the 2 byte difference? The BIP says that the N value needs to be encoded in CompactSize format and appended to the front of the filter so that it can be decoded by the receiver. This is done as follows:\nfd := filter.Bytes() var buffer bytes.Buffer buffer.Grow(wire.VarIntSerializeSize(uint64(N)) + len(fd)) err = wire.WriteVarInt(\u0026amp;buffer, 0, uint64(N)) if err != nil { return nil, err } _, err = buffer.Write(fd) if err != nil { return nil, err } If we print out the filter now, we get one that matches the one we got from bitcoind exactly:\n5571d126b85aa79c9de56d55995aa292de0484b830680a735793a8c2260113148421279906f800c3b8c94ff37681fb1fd230482518c52df57437864023833f2f801639692646ddcd7976ae4f2e2a1ef58c79b3aed6a705415255e362581692831374a5e5e70d5501cdc0a52095206a15cd2eb98ac980c22466e6945a65a5b0b0c5b32aa1e0cda2545da2c4345e049b614fcad80b9dc9c903788163822f4361bbb8755b79c276b1cf7952148de1e5ee0a92f6d70c4f522aa6877558f62b34b56ade12fa2e61023abf3e570937bf379722bc1b0dc06ffa1c5835bb651b9346a270 Yay!\nHowever, from my understanding, there is no need to add N to the filter. If you know the value of P, then you can figure out the value of N. Let’s do this now by seeing if we can take the filter above, and reconstruct the original list of numbers:\nb := bstream.NewBStreamReader(filter) var ( numbers []uint64 prevNum uint64 ) for { // Read a quotient from the stream. Read until we encounter  // a \u0026#39;0\u0026#39; bit indicating the end of the quotient. The number of  // \u0026#39;1\u0026#39;s we encounter before reaching the \u0026#39;0\u0026#39; defines the  // quotient.  var q uint64 c, err := b.ReadBit() if err != nil { return err } for c { q++ c, err = b.ReadBit() if errors.Is(err, io.EOF) { break } else if err != nil { return err } } // The following P bits are the remainder encoded as binary.  r, err := b.ReadBits(P) if errors.Is(err, io.EOF) { break } else if err != nil { return err } n := q*uint64(math.Exp2(float64(P))) + r num := n + prevNum numbers = append(numbers, num) prevNum = num } fmt.Println(numbers) The above produces the same list of numbers that we had before and we were able to reconstruct this without the knowledge of N. So I am not sure why it was decided that N should be added to the filter. If anyone knows why it was required to add N to the filter, please let me know!\nCool, that was fun! Thanks for reading. Yeeeeet!\n  https://en.wikipedia.org/wiki/Bloom_filter\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://gist.github.com/sipa/576d5f09c3b86c3b1b75598d799fc845\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"https://www.ellemouton.com/posts/bip158/","summary":"What even is Golomb-Rice Coding?","title":"BIP158: Compact Block Filters Deep Dive"},{"content":"In previous post gave a simplified overview of HTLCs. This post will look in more detail at what these HTLCs actually look like and how they fit in the commitment transactions.\nFrom Part 2 on the Update layer, we learned a few things about how commitment transactions are done:\nFirst of all, they are asymmetric: Alice and Bob (the two participants of a channel) each hold their own commitment transactions. The commitment transactions that each participant holds looks slightly different to that of their peer in that any output going to the local node must be encumbered by a relative time lock of to_self_delay. This is to give the other party a chance to spend along the revocation path of the output if they need.\nGiven the above requirements of a commitment transaction, let’s look at how HTLC’s will fit into all of this. To do this, let’s use the example from the previous post where Alice is sending 2 BTC to a recipient and is using her channel with Bob as the first hop in the route (he might even be the final recipient). Remember that Alice has been given a hash, H, to which she needs to pay. In this example, Alice is the HTLC offerer and Bob is the HTLC receiver.\nZooming in on Alice: Let’s zoom in on how Alice will construct her commitment transaction to now include the HTLC. The commitment transaction will have three outputs:\n One 5 BTC output to Bob (spendable immediately). One 3 BTC output with two possible spending paths: One spendable by Alice after a to_self_delay and one immediately spendable by Bob if he has the required revocation key (see post 2 and post 3 for more details on revocation). One 2 BTC output with…. ok so here is where it gets tricky. Let’s think about what needs to be here a bit.  This output is where the HTLC magic must happen. We need the following spending paths on this output:\n It needs to be spendable by Bob if he has the pre-image of H (hash-locked path) Or spendable by Alice after cltv_expiry Or spendable by Bob immediately if he has the revocation key  BUT remember that Alice’s outputs to herself must always have a relative timelock of to_self_delay even after cltv_expiry. Knowing this, let’s update the HTLC spending paths a bit:\n It needs to be spendable by Bob if he has the pre-image of H (hash-locked path) Or spendable by Alice after absolute time cltv_expiry AND after relative delay to_self_delay Or spendable by Bob immediately if he has the revocation key  There is still a problem: Making the output to Alice encumbered by both these timelocks could in the worst case extend the HTLC’s timeout by to_self_delay. In other words, Bob could have an extra to_self_delay blocks in order to sweep the hash-locked output even though the HTLC is technically expired. So what is done instead is that instead having this output being locked by both timelock conditions, it is instead only locked by just the cltv_expiry one and then instead of sending funds to Alice directly, the funds are instead sent to a separate HTLC-timeout transaction (signed by both Alice and Bob) and this separate time out transaction then enforces the to_self_delay. This allows Alice to definitively lock in the fact that the HTLC has expired and removes Bob’s ability to claim the hash-locked output all while still ensuring that Alice can only get her funds after to_self_delay and thus still allow Bob to spend from the revocation path (of the HTLC-timeout transaction) if needed.\nThe final state of the commitment transaction’s HTLC output spending paths is as follows:\n One spending path to Bob if he pre-image of H (hash-locked path) One spending path to Bob if he has the revocation key. One spending path to a second-state HTLC-timeout transaction.  The HTLC-timeout transaction has the following construction:\n The transaction itself is timelocked with nLocktime set to cltv_expiry. Thus the spending path in the original commitment transaction that sends to this HTLC-timeout transaction is effectively time delayed by cltv_expiry. The transaction has one output with two possible spending paths:  one to Alice after to_self_delay one to Bob if he can provide the revocation key.    The Script for Alices (the HTLC offerer) commitment transaction’s HTLC output looks as follows:\n# To remote node with revocation key OP_DUP OP_HASH160 \u0026lt;RIPEMD160(SHA256(revocationpubkey))\u0026gt; OP_EQUAL OP_IF OP_CHECKSIG OP_ELSE \u0026lt;remote_htlcpubkey\u0026gt; OP_SWAP OP_SIZE 32 OP_EQUAL OP_NOTIF # To local node via HTLC-timeout transaction (timelocked). OP_DROP 2 OP_SWAP \u0026lt;local_htlcpubkey\u0026gt; 2 OP_CHECKMULTISIG OP_ELSE # To remote node with preimage. OP_HASH160 \u0026lt;RIPEMD160(payment_hash)\u0026gt; OP_EQUALVERIFY OP_CHECKSIG OP_ENDIF OP_ENDIF You can see in the script above that the first path is the revocation path, the second is the path to the HTLC-timeout transaction (the time-locked path) and the third is the hash-locked spending path.\nThe HTLC-timeout transaction output script looks as follows:\nOP_IF # Penalty transaction \u0026lt;revocationpubkey\u0026gt; OP_ELSE `to_self_delay` OP_CHECKSEQUENCEVERIFY OP_DROP \u0026lt;local_delayedpubkey\u0026gt; OP_ENDIF OP_CHECKSIG Zooming in on Bob: Let’s now zoom in on how Bob (the HTLC receiver) will construct his commitment transaction to include the HTLC. The commitment transaction will have three outputs:\n One 3 BTC output to Alice (spendable immediately). One 5 BTC output with two possible spending paths: One spendable by Bob after a to_self_delay and one immediately spendable by Alice if she has the required revocation key Again the 2 BTC output on Bob’s commitment transaction is a bit complicated. Let’s dive in.  Let’s again think about what spending paths this output should have:\n There should be a spending path that Bob can claim if he has the pre-image of H (hash-locked path) but since it is an output to himself it needs to have a to_self_delay. One spending path should be spendable by Alice immediately by Alice if she has the necessary revocation key. One spending path also needs to be spendable by Alice after cltv_expiry (time-locked output).  The problem with having all the above spending paths in the same script is that if Bob knows the pre-image but now has to wait to_self_delay blocks in order to spend from the hash-locked path then there is a change that this to_self_delay is longer than the cltv_expiry that Alice must wait in order to claim the time-locked path. So Alice could potentially spend along the time-locked even though Bob does have the pre-image. Similar to the situation with Alices commitment transaction, Bob needs a way to lock in the fact that the hash-locked path will be used while still delaying his redemption of the funds by to_self_delay. So, a separate HTLC-success transaction is used for this thus allowing Bob to spend from the hash-locked path to this HTLC-success transaction which will then separately enforce the to_self_delay condition.\nThe final state of the commitment transaction’s HTLC output spending paths is as follows:\n One spending path to Alice if she has the revocation key (revocation path) One spending path to Alice after cltv_expiry (time-locked path) One spending path to the HTLC-success transaction IF Bob can reveal the pre-image of H (hash-locked path).  The HTLC-timeout transaction has the following construction:\n The transaction is not time locked (unlike in Alice’s case). The transaction has one output with two possible spending paths:  one to Bob after to_self_delay one to Alice if she can provide the revocation key.    The Script for Bob’s (the HTLC receiver) commitment transaction’s HTLC output looks as follows:\n# To remote node with revocation key OP_DUP OP_HASH160 \u0026lt;RIPEMD160(SHA256(revocationpubkey))\u0026gt; OP_EQUAL OP_IF OP_CHECKSIG OP_ELSE \u0026lt;remote_htlcpubkey\u0026gt; OP_SWAP OP_SIZE 32 OP_EQUAL OP_IF # To local node via HTLC-success transaction. OP_HASH160 \u0026lt;RIPEMD160(payment_hash)\u0026gt; OP_EQUALVERIFY 2 OP_SWAP \u0026lt;local_htlcpubkey\u0026gt; 2 OP_CHECKMULTISIG OP_ELSE # To remote node after timeout. OP_DROP \u0026lt;cltv_expiry\u0026gt; OP_CHECKLOCKTIMEVERIFY OP_DROP OP_CHECKSIG OP_ENDIF OP_ENDIF You can see in the script above that the first path is the revocation path, the second is the path to the HTLC-timeout transaction (and is also the hash-locked path) and the third is the time-locked spending path.\nThe HTLC-timeout transaction output script looks as follows:\nOP_IF # Penalty transaction \u0026lt;revocationpubkey\u0026gt; OP_ELSE `to_self_delay` OP_CHECKSEQUENCEVERIFY OP_DROP \u0026lt;local_delayedpubkey\u0026gt; OP_ENDIF OP_CHECKSIG All together now: The final construction looks as follows:\nYeeeeet!\n","permalink":"https://www.ellemouton.com/posts/htlc-deep-dive/","summary":"Day 7 of #7DaysOfBitcoin","title":"LN Things Part 5: HTLC Deep Dive"},{"content":"The previous 2 posts were all about sending funds between the two participants of a channel (agreeing on current state and invalidating older state). This post will give an overview of HTLCs and how they allow multi-hop payments to be made. The next post will be a deep dive into exactly what these HTLCs look like and how they fit into the commitment transactions of a channel.\nLet’s look at a simple example.\nSimple 3 node, 2 hop network: In this example, the network is make up of three nodes (Alice, Bob and Charlie) and there are two channels set up: One between Alice and Bob and another between Bob and Charlie. Each channel has a capacity of 10 BTC and to start with the funds of each channel will be divided equally between the participants.\nFor the purposes of this overview of HTLCs, the commitment transactions describing the channels will be shown as they are in the diagram above, with one commitment transaction spending from the funding transaction and hence determining the channel state. This is not accurately representing the asymmetric construction described in post 2 but it will make the overview easier to understand. A more accurate description will be given in a later post.\nSuppose that Alice would like to pay Charlie. She cant pay him directly since they do not have a shared channel and it is costly (in terms of time and money) to open a channel just for the purposes of a quick transaction. Instead, Alice can use her channel with Bob to route a payment to Charlie since Bob has a channel with Charlie.\nStep 1: Generating and sharing the pre-image hash Alice first needs to tell Charlie that she wants to pay him. Charlie will then generate a random secret, S, and get the hash of S which we will call H. Charlie then sends H to Alice.\nStep 2: Setting up the chain of HTLCs\nLet’s say that Alice wants to pay Charlie 1 BTC. She will then find a route to Charlie (A-B-C) and will see that in order to use this route she will need to incentivise Bob to help her out by paying him a routing fee. In this example Bob charges a flat fee of 1 BTC for routing payments and so Alice will be paying a total of 2 BTC: 1 BTC for routing and 1 BTC for the recipient, Charlie. Alice then communicates with Bob that she would like to route a payment through him and does this by suggesting that they update their channel’s commitment transaction to have the following outputs (remember this is overly simplified and in reality both Alice and Bob will have their own commitment transactions):\n An output of 3 BTC back to Alice An output of 5 BTC to Bob An output of 2 BTC to a special script that has 2 possible spending paths: The first path can be spent by Bob if he has the pre-image of H. The second path can be spent by Alice after an absolute time cltv_expiry_AB. This special script that locks up the 2 BTC is called a Hash and Time Locked Contract (HTLC) because it has one hash-locked path and one time-locked path.  Bob will be happy to update to this new channel state because he can see that he is not loosing money (if the transaction goes on-chain and he still does not have the pre-image then he still gets back his original funds). And he can see that if he co-operates and continues with the payment forwarding process then he will be rewarded with a routing fee if the payment is successful because he will be able to claim the hash-locked output on the transaction.\nBob then goes ahead and locks up some of his funds in a similar way in his channel with Charlie. He updates the channel commitment transaction to have the following outputs:\n An output of 4 BTC to Bob An output of 5 BTC to Charlie An output of 1 BTC to an HTLC script that again has 2 spending paths: one spendable by Charlie if he can reveal the pre-image of H and one to Bob spendable after cltv_expiry_BC.  Bob is confident in locking his liquidity up in this way because if the payment fails then he will be able to claim his funds back along the HTLC’s time-locked path and if the payment is successful and the pre-image is revealed by Charlie when he spends along the hash-locked path then Bob will see this pre-image and will be able to claim the hashed-lock output in HTLC output from the commitment transaction he has with Alice.\nWhen Charlie receives this HTLC offer from Bob, he can see that he in fact does know the pre-image, S, that hashes to H and so he knows that he can claim the hash-locked path of the commitment transactions HTLC output if it were to go on-chain. Ideally, channels should remain open though so instead of publishing the transaction on-chain and sweeping the hash-locked contract there, Charlie instead just sends the pre-image, S, to Bob. This proves to Bob that Charlie would be able to claim the HTLC output if they were to broadcast the commitment transaction on-chain and so now the two parties can agree to just update their commitment transaction to reflect that Charlie now has the 1 BTC extra:\nNow that Bob has S, he can turn around and reveal S to Alice and thus prove to Alice that if their commitment transaction were to go on-chain, that Bob would be able to claim the hash-locked output. So as Bob and Charlie did in their channel, Alice and Bob similarly update their commitment transaction by removing the HTLC output and just reflecting the new balances:\nAlice has now effectively paid Charlie 1 BTC and Bob has earned a routing fee of 1 BTC.\nSome extra details: What if things go wrong? Perhaps Charlie goes offline and doesn’t respond to Bob with a pre-image. If this happens then Bob will need to broadcast the commitment transaction so that he can claim his funds back via the time-locked path of the HTLC. If he does broadcast the transaction but then Charlie comes back online before cltv_expiry_BC has been reached and goes and spends via the HTLC’s hash-locked path then Bob will be able to see the pre-image on the blockchain and will then be able to turn around to Alice and reveal the pre-image to her as per usual. From this example, you can see that it is important for the cltv_expiry values to decrease along the path from the sender to the receiver. This is because in the worst case, Charlie only reveals S to Bob just before cltv_expiry_BC and then Bob still needs time to turn around and reveal S to Alice before she is able to spend along the ctlv_expiry_AB path. Therefor cltv_expiry_BC must be before ctlv_expiry_AB.\n","permalink":"https://www.ellemouton.com/posts/htlc/","summary":"Day 6 of #7DaysOfBitcoin","title":"LN Things Part 4: HTLC Overview"},{"content":"In Part 2 I gave an overview of how two participants of a payment channel go about agreeing on a state and how they update their state. In this post we will look at the scripts used in the commitment transactions and dig into the revocation key process a bit more.\nTaking a look at Alice’s commitment transaction again: it spends from the funding transaction and has two outputs: a to_local output and a to_remote output.\nto_remote This output is simply a P2WPKH send to a public key belonging to Bob.\n\u0026lt;remotepubkey\u0026gt; to_local This output has 2 spending paths:\n the first is to a \u0026lt;revocationpubkey\u0026gt; the second is to a Public key belonging to Alice but is only spendable after a relative delay of to_self_delay blocks.  OP_IF # Penalty transaction \u0026lt;revocationpubkey\u0026gt; OP_ELSE `to_self_delay` OP_CHECKSEQUENCEVERIFY OP_DROP \u0026lt;local_delayedpubkey\u0026gt; OP_ENDIF OP_CHECKSIG In Part 2, the revocation key system was described as follows:\n Alice generates a temporary private key dA1 and its corresponding public key PA1 and sends the public key to Bob. Then Alice creates a commitment transaction where the to_local_output output has a spending path that is immediately spendable by Bob if he has the private ket dA1. If Alice and Bob agree to update their channel state, then the private keys for the previous state will be swapped (ie: Alice will send Bob dA1).  This description is mostly correct but not complete. If you take a look at the to_self_delay script above, you can see that the revocation path doesn’t have any condition that makes it seem like only Bob can spend it. It just looks like anyone with the private key corresponding the revocation public key can spend the output. This makes it seem like Alice can also spend the output since she is the one who derived the temporary private key in the first place. After diving into the LND code a bit to try and figure this out, I found that a very cool trick is used to ensure that only Bob can spend via the revocation path. (See function DeriveCommitmentKeys).\nBefore construction the commitment transactions, both Alice and Bob derive two temporary keys and the associated public keys. They will both derive a revocation_basepoint (r -\u0026gt; R) and a per_commitment_point (c -\u0026gt; C).\n Alice will have her revocation_basepoint key pair: rA1 -\u0026gt; RA1 and her per-commitment key pair: cA1 -\u0026gt; CA1. Bob will have his revocation_basepoint key pair: rB1 -\u0026gt; RB1 and his per-commitment key pair: cB1 -\u0026gt; CB1.  Now, in order to create her commitment transaction, Alice will send Bob her commitment point public key, CA1 and Bob will send Alice his revocation_basepoint public key, RB1. Alice then derives the following Revocation key RevA1 as follows:\nRev_A1 = R_B1 * sha256( R_B1 || C_A1 ) + C_A1 * sha256( C_A1 || R_B1 ) Alice’s to_local output script now looks as follows:\nOP_IF \u0026lt;Rev_A1\u0026gt; OP_ELSE `to_self_delay` OP_CHECKSEQUENCEVERIFY OP_DROP \u0026lt;alice_delayedpubkey\u0026gt; OP_ENDIF OP_CHECKSIG Now when the times comes for Alice and Bob to update their state and invalidate this old state, Alice sends Bob her private key for her per-commitment key pair, c_A1. With this key, Bob will be able to derive the private key corresponding the the public key Rev_A1 and will therefore be able to spend via the revocation output. He can do this because he has private key r_B1 that corresponds to public key R_B1. So he can calculate the private key as follows:\nrev_A1 = r_B1 * sha256( R_B1 || C_A1 ) + c_A1 * sha256( C_A1 || R_B1 ) Alice will not be able to derive this private key because she does not and will never have the private key r_B1.\nUpdated Diagrams from Post 2: State 1: State 2: ","permalink":"https://www.ellemouton.com/posts/revocation/","summary":"Day 3 of #7DaysOfBitcoin","title":"LN Things Part 3: Revocation in more detail"},{"content":"Today’s post is more of a set up for the next one. It describes the basics of the Lightning Network update layer using LN-Penalty. The next post will introduce HTLCs and then will dive into how the HTLCs fit into commitment transactions and how this plays along with the update layer.\nThe previous post described how Alice and Bob set up a channel. It mentioned that both Alice and Bob had commitment transactions that spent from the on-chain funding transaction and that the commitment transactions were both valid and could be published on the blockchain and pay the recipients what they are owed.\nThis post will describe the commitment transactions in more detail and will also show how the participants of the channel can agree on a new division of funds. In other words: how they create new commitment transaction that splits the funds differently and at the same time invalidate the older commitment transactions that they have.\nAsymmetric commitment transactions: In LN-penalty, each party in the channel will hold a commitment transaction representing the state of the channel. Why? To assigning blame. The commitment transactions held by each party vary slightly (details to follow) and this makes it clear which party broadcasted their commitment transaction and makes it possible for the correct party to be punished if they broadcast an invalid state. This concept will be made more clear in this post.\nSetting up state 1: Let’s assume that Alice and Bob start out each owning 5 BTC in a 10 BTC channel. To set up their initial commitment transactions, each party will first create temporary private keys (dA1 for Alice and dB1 for Bob) and calculate their associated public key (PA1 and PB1). Alice and Bob will then send each other the temporary public keys. At this point, both parties can construct their own commitment transaction. Alice’s will look as follows:\n It will spend from the funding transaction. It will have 2 outputs. (or more. HTLC outputs to come!) The to_remote output will send Bob his 5 BTC immediately. the to_local output is fancier: It either sends Alice her 5 BTC after an OP_CSV to_self_delay or it can immediately be spent by Bob if he is able to prove that he has Alices temporary private key dA1.  Bob will be able to construct Alice’s commitment transaction too and will thus be able to provide her with his signature for the input of her transaction (the one that spends from the channel’s funding transaction). And so Alice will have this valid transaction with Bob’s signature and so she can at any point sign it her self and broadcast it to the network to be confirmed in a block.\nBob will create his commitment transaction in a similar way. See the diagram below:\nNote that at this point, either party can broadcast their commitment transactions to the network. For example, let’s say Alice broadcasts her’s. Bob will get his 5 BTC immediately and Alice will need to wait to_self_delay blocks before she is able to use her 5 BTC. She doesn’t need to worry about Bob spending her output though because she knows that she never shared her secret private key with him.\nSetting up state 2: Now Alice wants to send Bob 1 BTC using their channel. So just like for stage 1, both parties will now generate new temporary private keys (dA2 for Alice and dB2 for Bob), calculate their associated public key (PA2 and PB2) and share the public keys with each other. And again, both parties will create commitment transactions to reflect this new state where Alice has transferred one of the BTC to Bob. The problem is that Alice still has the valid commitment transaction from before which is more profitable for her. To invalidate this old state and to prove to Bob that she is committing to this new state where she has paid him, Alice will send Bob her initial temporary private key (dA1). Since Bob now has this key, if Alice ever posts the old state, Bob will be able to spend Alice’s to_local output before she is able to claim it. Bob also sends Alice his old key (dB1) in order to invalidate his old state. He has no reason not to do this since the new state is more profitable to him.\nThat’s it! Alice and Bob can now update their shared channel state and invalidate old states.\n","permalink":"https://www.ellemouton.com/posts/updating-state/","summary":"Day 2 of #7DaysOfBitcoin","title":"LN Things Part 2: Updating State"},{"content":"What is a channel? It is literally just a transaction sending funds to a 2-of-2 multisig transaction. This creates an unspent UTXO and the channel is open until that UTXO is spent (crazy to think that the current state of the LN is just a subset of the current UTXO set). During the lifetime of the channel, a bunch of transactions are created that double spend the funding tx and eventually one of those (and only one. No double spends bro) will go on-chain and the channel will be closed. Ideally you only see these two on-chain transactions: one to open the channel and one to close it.\nCreating a channel: To create a channel we need to somehow get this initial funding channel on-chain. How this is done can be gleaned from BOLT2 but I will go through my understanding of it here. The following screenshot is from the bolt and shows the various messages sent between two nodes during channel creation. I will go through each of these.\nSince commitment transactions are part of the update layer (and ie will be analysed in a future post) I wont get into those details now but the important thing to know is that once a funding transaction is established and confirmed, commitment transactions are used to define the state that the channel is in (how the funds are distributed between the participants in the channel). So each commitment transaction pretty much just spends the funding transaction (uses the funding tx as its input) and then has outputs that define the division of funds between the participants.\nThe funding transaction for a channel between Alice and Bob is simply a transaction that has an output of the following form:\n2 \u0026lt;pubkeyA\u0026gt; \u0026lt;pubkeyB\u0026gt; 2 OP_CHECKMULTISIG Where \u0026lt;pubkeyA\u0026gt; is the Alice’s public key and \u0026lt;pubkeyB\u0026gt; Bob’s. Currently in the Lightning Network a channel is always funded by one side. So in our example lets say that Alice wants to open, and hence fund, the channel. The question is: how does she do this? Can she simply just send funds to the above script? No she cant because there is a chance that Bob might disappear and never be around to sign any transaction that attempts to spend from the funding transaction and this would mean that Alice’s funds would be stuck in this UTXO forever. Let’s go through each of the messages shown in the above diagram to see how it is done then.\nopen_channel: Alice sends this message to Bob to indicate that she wants to open a channel with him. This message includes various details regrading Alice’s requirements of the channel but the important one is the funding_pubkey. This is the public key that Alice intends to use as her public key in the funding transaction script.\naccept_channel: If Bob is happy with the terms that Alice has put forward in her channel offer, then he can send back the accept_channel message which also contains some of his requirements along with the funding_pubkey that he intends to use.\nAt this point, Alice has all that she needs to construct the funding transaction. However, she at this moment still does not broadcast the funding transaction because she still has no guarantee that Bob will not disappear. So what she needs is a commitment transaction signed by Bob that spends from the funding transaction and divides the channel balance accordingly. It could be the case that the initial division of funds allocates some funds to Bob too and so Bob would also want a valid commitment transaction that he can broadcast in case Alice disappears (the concept of asymmetric commitment transactions will be discussed in detail in a future post. For now, just know that both sides have a commitment transaction) . What Alice does now is construct the funding transaction (using Segwit inputs only so that the TXID of the transaction can not be changed due to script sig field malleation) but she does not broadcast the transaction. She sends bob the following message:\nfunding_created: This message contains the TXID of the funding transaction, the relevant output index of the funding transaction along with a signature for Bob’s commitment transaction (if Bob is following the rule then Alice is able construct the exact commitment transaction that he is holding and is thus able to provide her signature for it). Note that Bob cannot yet do anything with his commitment transaction since it is spending from a transaction that is not on the blockchain yet.\nfunding_signed: If Bob is happy then he can send Alice a funding_signed message.\nThis message will contain a Bob’s signature for Alice’s commitment transaction.\nAt this point, Alice now has a valid commitment transaction signed by Bob that spends from the funding transaction that sends her funds back to her. It is thus safe for her to now broadcast the funding transaction.\nchannel_ready: Both parties will be monitoring the blockchain at this point waiting for the funding transaction to be confirmed. Once each party sees it, they will send the other party the channel_ready message which contains the channel ID of the channel.\nThe channel is now open. YEET!\n","permalink":"https://www.ellemouton.com/posts/creating-a-channel/","summary":"Day 1 of #7DaysOfBitcoin","title":"LN Things Part 1: Creating a channel"}]