[{"content":"Hold on to your hats folks, things are about to get real.\nOverview In this post, I will dive into the structure of Taproot channel funding and commitment transactions. If you missed my previous post about Taproot and MuSig2, it might be a good idea to read that one first for a recap of the building blocks that will be used throughout this post. If you perhaps also need a re-cap of the general structure of commitment transactions then check out this post where I cover why each output in a commitment transaction looks the way it does.\nNote that Taproot Channels are still in the design phase and so until the proposal by the one and only Roasbeef is merged, this blog post will be a living document that I will update if any changes are made to the proposal. There are currently even a few open questions in the proposal which I will try to illustrate here.\nIf you have read some of my previous blog posts, you might have noticed that I love to make use of diagrams. Well this post is diagrams on steroids. To help with understanding, here is a legend showing what each colour generally represents:\nOk, ready? Let\u0026rsquo;s dive in!\nFunding Transaction Output Here is a diagram showing how a Taproot-channel funding output is constructed:\nThe two parties in a channel, the local and remote peer, use the MuSig2 protocol to aggregate their individual funding keys, P_a and P_b, into the aggregate key, P_agg, which is also the internal key. This internal key is then tweaked with a BIP86 tweak. You might recall from the previous post that a BIP86 tweak gives the channel owners the ability to prove to other nodes on the network that this funding output does not have a hidden script path.\nSpending from the funding transaction The funding output can only ever be spent via the key path. Since the internal key is an aggregate key produced via MuSig2, to spend it requires both parties to produce partial signatures for the message being signed. These signatures are then aggregated using the MuSig2 PartialSigAgg function and finally tweaked with the tweak, T, to produce the signature that would validly spend the funding output.\nCommitment Transaction Outputs There are six different outputs that a commitment transaction can have. These are: the to_local and to_remote outputs, the local and remote anchor outputs, the offered htlc output and the accepted htlc output. Let’s dive in.\nThe to_local output The to_local output is responsible for paying the local peer all the funds in the channel that belong to them that are not currently committed to an HTLC. The output must be revocable by the remote party and then only after to_self_delay blocks should the local party be able to spend from the output. The revocation key is used as the internal key and the to-local delayed script is then placed in the TapTree.\nKey path spend The revocation key which will only be spendable by the remote peer iff the state associated with this commitment transaction has been revoked (see more on revocation “here”) . Thus, if the local party tries to cheat the remote party by publishing an old state, the remote party will be able to sweep via the key spend path which also the most cost effective spending path.\nScript path spend If this commitment transaction ends up on-chain as part of an honest force-close scenario then the remote party will not be able to spend via the revocation key. In this case, the transaction will be spendable by the local party via the script path after to_self_delay blocks have been confirmed. The following diagram shows the witness that will be required to spend this path:\nIt contains a witness script for the local-delayed script. This witness only requires a valid signature from the local party. The script itself must also be revealed and finally, the control block must be specified. In this case, it only contains the parity bit of to_local output’s output key along with the internal key. Note that no inclusion proof needs to be included in the control block since there is only one script in the TapTree which means that the script root can be calculated straight from the local-delayed script.\nThe to_remote output This output pay’s the remote party their channel balance. As with all anchor channels, all non-anchor outputs must have a CSV of at least 1 so as to not break the CPFP-carveout rule. Therefore, the remote party is only allowed access to their funds after one confirmation. This type of requirement can only be added in a script and so this output also makes use of the TapTree.\nAt this point, you are likely wondering about the internal key. We only require one spend path for this output but unfortunately we had to put it in the TapTree. We still have to set an internal key, however, even though we don’t ever want anyone to be able to spend from it. From the diagram you can see that the spec currently sets this key to the same aggregate public key used in the funding transaction. The idea here being that if P_agg internal key, then we know that it would require cooperation among the two peers to spend via this key but there is really no reason for either party to want to do so. This effectively cancels out the key path.\nSome reviewers of the proposal have noted that using P_agg as the internal key here makes recovery for the remote peer basically impossible if they find them selves in a situation where they have lost all channel data, all channel backups and only have their master seed left. With legacy channels, remote parties who have lost all their channel data are still able to scan the chain for to_remote outputs that belong to them since they know the derivation path that would be used for deriving these keys. This property will be lost if P_agg is used as the internal key in the Taproot channel case because the remote party would not be able to derive it and thus would not be able to scan the chain for their outputs. It has therefore been suggested that instead of using P_agg here, that a public NUMS point be used instead. If a public NUMS point is used, then the remote nodes will once again retain the ability to scan the chain for to_remote outputs belonging to them.\nScript path spend Once the commitment transaction has one confirmation, the remote peer can spend it via the script path using the following witness:\nRemote Anchor Output This is the output that the remote party will be able to use to CPFP the commitment transaction if required. The remote party’s public key is thus used as the internal key. To ensure that this output (a very small output of only 330 satoshis) is definitely cleaned up at some point from the UTXO set, another output path is added which allows anyone to spend the output after it has been confirmed for 16 blocks. This extra path is added as a script in the TapTree.\nKey path spend The key spend path just requires a signature from the remote party which they will tweak with the TapTweak.\nScript path spend Once the output has been confirmed for 16 blocks, it becomes fair game. Anyone is allowed to spend from this output as long as they can produce the following spending script:\nNotice anything here? If you were a third party trying to sweep some expired anchor outputs for some free sats, would you be able to produce the above spending script? The answer is: yes, but only if you know what P_remote is! Before reading on, I suggest taking some time to think about how you could possibly come to know what P_remote is. It is not present in the funding transaction, nor is it present in the commitment transaction. Scroll up through the diagrams to see if you can see where it revealed.\nOk ready? It is only revealed if the to_remote output is spent as it appears in the witness required to spend that output. This means that the remote anchor is spendable by anyone after 16 blocks only when the to_remote output has been spent.\nLocal Anchor Output This is the output that you, the local party, will be able to use to CPFP the commitment transaction. And just like the remote anchor, it is spendable by anyone after 16 blocks. So the internal key is P_local_delayed and the “anyone can spend after 16 blocks” script is put in the TapTree.\nKey path spend The key spend path just requires a signature from the local party which they will tweak with the TapTweak.\nScript path spend Just like the remote anchor, the parties wanting to spend via the “anyone can spend” path require the P_local_delayed public key to first be revealed. This is revealed when the to_local output is spent by the local party via the script path.\nThere is, however, one very important difference between the to_local and to_remote output: the to_remote output can only be spent via the script path which means that P_remote is always revealed. However, the to_local output can be spent via two paths! In the ideal case, it is spent via the script path in which case the P_local_delayed is revealed and there is no issue. But in the bad case, the to_local output is spent via the revocation path in which case P_local_delayed will not be revealed. In that case only the two channel peers would ever have the information required to spend the local anchor.\nAn alternative that has been suggested is that the to_local output be changed so as to force the reveal of P_local_delayed no matter how it is spent. This could be done by changing the keyspend path to be a public NUMS point and then moving the revocation path to the TapTree and adjusting the script so that the P_local_delayed key is embedded in it so that it must be revealed if the revocation path is spent. The down side here is that this increases the spend cost of both output paths of the to_local output. The question comes down to how much we want to cater for this very rare edge case.\nOffered HTLC Output An offered HTLC pays out to the remote party if they reveal the pre-image to a given hash before a certain CLTV timeout. After the timeout, the local party will be able to claim the output via the htlc-timeout transaction (details on that below). If the commitment transaction is a revoked state, then the remote party should be able to sweep the output at any time.\nKey path spend The internal key is set to the revocation key which is spendable only by the remote party and only if the commitment transaction is for a revoked state. If this is the case, then the remote party can sweep the output with the following signature:\nScript path spends The other two spend paths, the success and timeout paths, are placed in the TapTree and spending either of them requires providing a valid witness for the script, the script itself and a control block which this time does include an inclusion proof since more than one script is present in the TapTree.\nSuccess Path To spend via the success path, the following witness is required.\nTimeout Path The following witness is required to spend via the timeout path. Transaction spending the timeout path is the htlc-timeout transaction. More details on that transaction later on. If you need a recap on the reason why second-stage htlc transactions are necessary, check out [this] post.\nAccepted HTLC Output The accepted HTLC output pays out to an htlc-success transaction if we (the local party) are able to provide the pre-image for the given payment hash. Otherwise, after a certain cltv_expiry, the remote party will be able to sweep the funds back. If the commitment transaction is a revoked state, then the remote party should be able to sweep the output at any time.\nKey path spend The internal key is set to the revocation key which is spendable only by the remote party and only if the commitment transaction is for a revoked state. If this is the case, then the remote party can sweep the output with the following signature:\nScript path spends The other two spend paths, the success and timeout paths, are placed in the TapTree and spending either of them requires providing a valid witness for the script, the script itself and a control block which this time does include an inclusion proof since more than one script is present in the TapTree.\nSuccess Path To spend via the htlc-success transaction, the following witness must be provided:\nTimeout Path To spend via the timout path, the remote party must provide the following witness:\nHTLC Timeout and Success Transactions The htlc-timeout and htlc-success transactions look mostly identical so here is one diagram to describe both:\nThe only difference between the htlc-success and htlc-timeout transactions would be the inputs they are spending and hence, the witness required for spending that input. The htlc-timeout transaction spends the timeout path of the offered HTLC output and the htlc-success transaction spends the success path of the accepted HTLC output.\nThe outputs of the htlc-success and htlc-timeout transactions are identical: they are immediately spendable by the remote party via the revocation path if the associated commitment transaction is for a revoked state. Otherwise, they are spendable by the local party after to_self_delay blocks have been confirmed.\nThe key path and script path spend scripts are exactly the same as for the to_local output.\n","permalink":"https://www.ellemouton.com/drafts/taproot-chan-txs/","summary":"A deep-dive into the structure of Taproot channel transactions","title":"Taproot Channel Transactions"},{"content":"In my last blog post, I promised a follow-up post on the workings of Taproot channels. However, when I started working on it, I realised that it might be a good idea to first dedicate a post to recap the preliminaries that will be required in order to understand the follow-up Taproot channel articles. So here you go!\nOverview This post will cover some basics around Taproot outputs and how to spend them via either the key or script paths. It will also cover the MuSig2 flow between two signing parties. Note that I won’t go into extreme detail for either of these topics. Instead, this post is aimed at refreshing your memory on these topics or giving you enough of an understanding of how Taproot outputs and MuSig2 work so that the follow-up articles are more easily digestible. There are better articles out there for you if you want to get into the nitty-gritty of these topics and of course you can always go check out the BIPs if you are brave: Schnorr signatures, Taproot, Tapscript and MuSig2.\nOk, enough chit-chat. Onto the good stuff!\nA quick note on BIP340 public keys Public keys will mostly be encoded as 32-byte arrays instead of the usual 33-byte compressed public key representation that you might be used to. If the secp256k1 curve is plotted over a non-finite field (as shown below) then you can see that for every x-coordinate, there are two possible y-coordinates. Since the curve is actually over a finite field with an odd order, one y-coordinate for a given x-coordinate will always be even and the other one will be odd. The assumption for 32-byte encoded public keys is that the y-coordinate is always the even one. This means that if you want to create a valid BIP340 signature but your private key, d, produces a public key, P, with an odd y-coordinate, then all you need to do is negate your private key. This will produce public key P’ which has the same x-coordinate as your original public key but with an even y-coordinate. For more information regarding BIP340 public keys and signatures (also known as Schnorr signatures), check out the BIP itself.\nTaproot Outputs A Taproot output shows up in the scriptPubKey section of a transaction (just like all other outputs) and has the following form:\nThe OP_1 indicates that this is a SegWit Version 1 output (a.k.a. Taproot output) and what follows are 32 bytes that represent the output key (see BIP340 public keys above). I will often use Q to refer to this key. To give the full picture, here is a Taproot output in a transaction:\nOk cool. But what exactly is in this output? Is it just like a P2PK output? No. That would be lame. The truth is that this simple-looking output could be a huge variety of different things. It could be a simple single public key (yes, like a P2PK). It could be an n-of-n MuSig2 public key. It could also have a bunch of script branch options, or it could even be a combination of all the above! Let’s break these options down a bit.\nSingle Key or n-of-n MuSig2 outputs If you wanted to just create an output that sends to a single public key, P, then this is easy to do. In this case, your output key, Q, just becomes your key, P, which is often called the internal key.\nTo spend this output, all you need is to provide a BIP340 signature in the witness which you would calculate using the private key, d, used to derive P. See the note explained in the BIP340 Public Keys section about possibly needing to negate your private key first.\nNow, what if you instead wanted to use an n-of-n aggregate MuSig2 public key? Turns out that this will look exactly the same on-chain as for the single key case explained above! All that changes is the steps that you and your fellow signers need to take to set up the aggregate public key and then to calculate the final signature. But once all that is complete, what ends up on-chain looks no different.\nScript Paths Here is where the magic really happens. You can also have the option of spending your Taproot output via a script and each output can have multiple scripts from which it can be spent. Another cool thing is that if you choose to include script paths in your Taproot output, you can still add a regular key path like before. Let’s say, for example, that you want to be able to spend your output at any time, but you also want to add three script paths so that it can also be spent in other scenarios: perhaps after 30 days you want your partner to be able to spend the output. That would be one script path. If you also have two other script paths (perhaps one is a 2-of-3 multi-sig and the other requires a pre-image reveal), then your Taproot output would be constructed as follows:\nLet’s walk through the above diagram a bit:\nFirst, the three scripts (Script A, Script B and Script C) are all put into a Merkle tree as shown bottom right. The root of this Merkle tree is then hashed along with our internal key, P, to get the 32-byte tweak, t. This tweak is converted to its elliptic curve point form by multiplying it with the generator point, G, to get T which is then added to our internal key, P, to get the final output key, Q. I have skipped over some things here such as the details of the script encodings and also how the scripts are hashed in the Merkle tree so check out the relevant BIPs if you are interested.\nAlrighty - our fancy Taproot output has been set up! But now… how do we spend it? There are two ways of spending this transaction: the first is via the internal key, P. We call this a key path spend. The other way is via one of the scripts in the tree. This type of spend is called a script path spend.\nKey Path Spends Spending via the key path is very simple and is similar to spending the output if it was just a normal un-tweaked key as described earlier on. The only difference is that you will need to tweak your private key, d, with the tweak, t. In other words, your new private key becomes d + t which is what you will use to calculate your signature. That’s it! If you spend the output via the key path, there is no need to reveal any of the scripts and so anyone looking at the spend on-chain will have no clue that the output even had the potential to be spent via a script path.\nScript Path Spends To spend via one of the script paths requires a slightly more complicated witness. Let’s say we want to spend via Script B. We will need to do a few things to convince a verifier that we have the right to spend the output:\n We must provide a valid spending script for Script B. We need to prove that Script B is actually embedded in the output.  Step 1 is pretty simple: just provide the valid witness script for Script B along with Script B itself. Step 2 is slightly more involved. To prove that Script B is embedded in Q, we need to give the verifier all the building blocks required in order to actually construct Q. These building blocks are put in what is called the “control block”. The first thing in the control block is the internal key, P. It also contains the Merkle proof that allows the verifier to compute the Merkle tree root. The witness already includes Script B itself (it was required for step 1), so the verifier can compute hB (see the diagram above showing the Merkle tree construction) themselves, and so we just need to provide hA and hC. The validator will use these hashes to calculate the script_root and then hash this along with the internal key, P, in order to arrive at the tweak, t. The validator can then compute the corresponding tweak point, T, add that to the internal key, P, to get the output key, Q. The final thing that the control block must include is a bit indicating if the final Q point has an odd or even y-coordinate so that the validator can check if the Q they computed does have the correct y-coordinate.\nIt is important to note that no knowledge of d (the private key for the internal key, P) was required for spending via Script B (assuming of course that Script B itself does not involve P). Another cool thing is that we did not need to reveal the contents of the other scripts in the tree, only their hashes.\nBIP86 Tweaks There is a clever trick that can be used if you would like to create an output with no script path that allows you to also prove to a third party that there is no script path. All you do is construct Q as if you were constructing an output with script paths but the script root is left empty.\nSpending this output can now only be done via the key spend path using private key d + t. Then, P can be provided to any third parties who want proof that there is no script path. They would use P to compute t and T and then would verify that P + T is equal to the output key, Q. More info about this can be found in BIP86.\nMuSig2 With the Taproot soft fork, bitcoin nodes now have an understanding of BIP340 signatures (or Schnorr signatures). The beauty of these signatures is their linearity: the owner of public key P_1 can create a partial signature, sig_1 for the message msg and the owner of public key P_2 can create sig_2 for the same message. The two parties will then be able to combine their signatures such that sig where sig = sig_1 + sig_2 is a valid signature for the aggregate of their public keys: P = P_1 + P_2.\nThis is really cool because it means that instead of needing to create a long n-of-n multisig script and then needing to pay for the blockchain space to store each of the n signatures, only one signature will be needed and no long script will be required at all. Instead, only a single public key (which is actually an aggregate public key) needs to appear on-chain.\nThe tricky part here is everything that needs to happen off-chain during the setup of this aggregate public key as well as for the creation of the final signature. MuSig2 is the protocol that defines how this should be done. The various steps have been carefully thought through in order to keep the process trust-less and to protect parties from attacks such as key cancellation.\nBIP327 defines the MuSig2 protocol along with a bunch of algorithms that should be used for the various steps of the process. Since the aim of this article is to provide all the building blocks required for understanding Lightning Taproot channels, I will only talk about MuSig2 at an API level using the defined algorithms and will focus more on how it will be used in Lightning. If you would like to dig into it more you can check out the BIP itself. I have also implemented all the MuSig2 methods from scratch here if you are the type of person who prefers looking at code.\nMuSig2 vs n-of-n Multisig An important thing to keep in mind is that with n-of-n multisig outputs, parties can generate their signatures completely independently of the other parties. As long as they have the message to be signed along with their private key, they can create a signature. This signature can then safely be distributed to the other parties and eventually the transaction witness will have all n signatures. In other words: no interaction is required between parties at signing time. With n-of-n MuSig2 this is not the case since there is one public key on-chain and thus one signature needs to be produced. The n parties have to interact with each other in order to produce this final signature.\nExplanation by example Let’s walk through the case where two parties, Alice and Bob, want to set up a 2-of-2 MuSig2 output and then create a signature to spend from it.\nThis first diagram shows the initial state: Alice and Bob both have private keys and the corresponding public keys and currently the two parties have no shared knowledge.\nWhen the two parties decide to construct an output together, they will first need to exchange public keys. Both parties will then use the MuSig2 KeySort algorithm to sort the keys and then the KeyAgg algorithm to aggregate the keys. This will produce the aggregate key, P_agg, which would be the key that would appear in the transaction output.\nOnce Alice and Bob have a shared message that they want to sign (which would most likely be the spending transaction), they can move onto the signing phase.\nStep one of the signing phase involves each party generating nonces. They will each generate a secret nonce, called the secnonce, and from the secnonce the associated public nonce, called the pubnonce, can be determined. Note that each secnonce is actually made up of two private keys and each pubnonce is made up of the two public keys associated with those private keys. The details of why there are two nonces is outside the scope of this post. Alice and Bob will then need to exchange the public nonces and then both parties will use the MuSig2 NonceAgg function to determine the aggregate nonce: aggnonce. Note that this step had nothing to do with the message to be signed meaning that this step can actually take place before the message to be signed is known.\nWhen the public nonces have been exchanged and both parties know the message to be signed then each party can use the MuSig2 Sign function to produce partial signatures.\nThe final step is for the parties to exchange their partial signatures. Each party can then use the MuSig2 PartialSigAgg function to calculate the final signature. This signature will be a valid signature for P_agg over the message, msg.\nIt is important to become familiar with the above MuSig2 flow because it will be used very often in the next few articles. In Taproot channels the funding output of a channel will be a MuSig2 aggregate public key. This means that every commitment transaction created that spends from the funding output will need to go through this signing flow. Since channel states in Lightning are asymmetric, this also means that this flow will need to happen twice per state update: once to sign the local commitment transaction and once to sign the remote one. But more on that in the next blog post :)\nThanks for reading! I hope that was useful. If you think there is anything that could use clarification or that is incorrect then please don’t hesitate to reach out to let me know.\n","permalink":"https://www.ellemouton.com/posts/taproot-prelims/","summary":"A recap of the building blocks required for Taproot channels","title":"Taproot and MuSig2 recap"},{"content":"In this article, I will go over the process of opening a Lightning Network channel as it works today (pre taproot channels). I will start with the channel_open message and will talk in detail about it and all the messages involved in “opening” the channel ending with the channel_announcement message.\nMy goal for this article is to recap today’s channel open flow so that we can later focus only on the changes required for opening a taproot channel1.\nThis article replaces my previous short article on channel opens. It includes more detail and more diagrams (yay diagrams!). I will assume that the reader understands the structure of a commitment transaction and understands why they are asymmetric. If you feel a bit rusty in this area, please check out my articles explaining these concepts in detail.\nThe end goal Before we dig into the first step, I think it is useful to illustrate the goal we are trying to reach. I will once again use our trusty peers, Alice and Bob, to tell the story.\nAlice and Bob are both Lightning Network nodes. Alice’s node ID (ie, the public key used to identify her node) is alice_node_id and Bob’s node ID is bob_node_id. Their main two goals are:\n They want to open a channel between themselves in a trustless way. They want to be able to advertise their new channel so that the rest of the network can use it for routing.  Opening the channel A channel is opened once both parties have the ability to fully sign their respective commitment transactions and once the funding transaction is on chain. Throughout this explanation, I will use diagrams and colours to illustrate the process. In the diagrams, a white background means that the field of the transaction is not yet known. A coloured-in field indicates that the field value is known. Any green fields are used to highlight any of Alice’s public keys or signatures and any blue fields are used to show Bob’s.\nThere are three transactions in play for the opening of a channel. The first is the funding transaction which will need to go on chain. The other two are the first commitment transactions held by Alice and Bob describing the initial state of the channel.\nHere are the diagrams used to describe the three transactions. Note that at the moment we still don’t know anything about the parameters of the channel and so all fields still have a white background. Remember that our end goal is to have all these fields coloured in.\nThe open_channel message The first step of the process is Alice deciding that she wants to open a channel with Bob. In doing so, she also becomes the funder of the channel. Let’s say that Alice decides that she wants to open a 1 BTC channel and wants to immediately give Bob half of the channel’s capacity (0.5 BTC). Alice will now put together an open_channel message that she will send to Bob. Let’s take a look at the relevant open_channel parameters (I am leaving out any parameters that don’t have anything to do with the channel-open phase). You can skip this table if you want. It is just a reference for incase you want to check what the meaning of a field is.\nLet’s now fill in Alice’s values for these fields:\nAlice sends this message over to Bob.\nSince Alice has decided on the type of channel she wants to open (default channel type as opposed to an anchors, taproot etc) as well as the channel capacity, she can already piece together quite a large part of the funding transaction:\nSince she knows the capacity of the channel she wants to open, she can choose some of her UTXOs to be inputs to the funding transaction. Since Alice does not yet know which pub key Bob would want to use for the channel, she cannot yet finalise the channel funding output and hence can also not yet produce signatures for the inputs.\nSince Alice has decided on the channel type (and hence the commitment transaction structure), she can also start putting together the pieces of the commitment transactions. If we assume that Bob is delighted by this channel-opening proposal from Alice, then from this open_channel message, he can also start putting together the pieces. Remember that both parties will need to construct both commitment transactions since they will both need to be able to sign their peer’s transactions. Let’s take a look at what pieces they are now both able to fill in:\nAlice’s commitment transaction has filled in quite nicely. It has the structure of a default, non-anchor channel transaction and all her public keys have been filled in (alice_local_delayed_pk_1 is derived using her delayed_payment_basepoint and her first_commitment_point). Since she hasn’t received any messages from Bob yet, she has not yet been able to fill in any of his pub keys and since the funding transaction is still incomplete, she also can’t yet know the TXID to point the input of this commitment transaction to.\nBob’s commitment transaction (from his perspective) is looking a bit more complete:\nLike Alice, he also cannot yet fill in the funding transaction’s TXID, but he can fill in a few other things:\n The alice_pubkey_1, alice_to_self_delay, push_amt and local_amt values are taken as is from the open_channel message alice_payment_key_1 is derived using Alice’s payment_basepoint and first_commitment_point revoke_pubkey_1b is derived using Alice’s revocation_basepoint and Bob’s first_per_commitment point (at this point Alice cannot derive this point yet since she has not received his first_per_commitment_point)  Ok cool! Time for Bob to indicate to Alice his acceptance of the request by sending the next message: accept_channel\nThe accept_channel message The message shares many of the fields from open_channel. Here is the message that Bob will put together:\nWhen Alice gets this message from Bob, she can now complete the funding transaction’s output and can create the signatures for the inputs. Since everything is filled in, the TXID for the funding tx is now also known.\nAlice can now also further fill in her own commitment transaction:\n she is now able to use the values sent by Bob to fill in bob_pubkey_1, bob_payment_key_1, bob_to_self_delay and revoke_pubkey_1a since the TXID for the funding tx is now known, she can complete the input too.  She now knows everything she needs to know in order to sign this transaction herself but she is still missing Bob’s signature for this transaction.\nBob’s view of his commitment transaction is still the same as before since he learned no new info after sending the accept_channel message.\nNow that Alice knows the txid for the funding transaction, she is also able to complete her view of Bob’s commitment transaction and so she can produce her signature for his transaction. This is where the next message comes in: funding_created.\nThe funding_created message Alice will now use the funding_created message to tell Bob the TXID and index of the funding transaction along with her signature for Bob’s commitment transaction. Note that he still wont be able to broadcast his transaction since Alice has not yet broadcast the funding transaction.\nOnce the funding message has been received, Bob can fill in the rest of his commitment transaction:\nAlice won’t broadcast the funding transaction until she has a valid signature from Bob for her commitment transaction. Enter funding_signed:\nNotice that this is the first message to use the real channel ID instead of the temporary one.\nThis was the last piece of the puzzle for Alice. She now has all the info she needs to be able to sign her commitment transaction if ever needed.\nAlice can now safely broadcast the funding transaction. Both she and Bob will watch the chain for the confirmation of the funding transaction. Once it has reached the minimum_depth specified by Bob in accept_channel, both sides will exchange the channel_ready message (previously named funding_locked). This message serves as both a signal to the peer to indicate to them that the channel is ready for use (and that the channel announcement process can now start if the peers decided on an announced channel) and also to send across each peer’s second_per_commitment_point that they should use in their second commitment transaction.\nOk cool! We have completed our first goal: Alice and Bob have opened a channel between themselves in a trust-less way. Now we move on to step 2: announcing this channel to the network!\nAnnouncing the channel This part is fairly painless. Basically there is just one message, channel_announcement, that Alice and Bob need to construct together and once it is complete, then they can broadcast it to the network. Other nodes will use this message to prove a few things:\n That the channel funding tx is actually an existing, unspent UTXO with an acceptable number of confirmations. That the funding transaction output actually looks like a lightning channel funding transaction That the channel is actually owned by the keys that Alice and Bob say they used to construct the channel. That Alice and Bob both agree on the message being broadcast.  An incomplete version of the channel_announcement message looks as follows:\nh is the hash of all the data that will be covered by the signatures. In order to complete the message, Alice and Bob both compute a signature over h using the private keys associated with their node IDs and the pubkeys they used in the funding transaction. They then both exchange the announcement_signatures message in order to communicate these signatures to each other:\nNow both nodes can put together the complete channel_announcement message:\nLet’s go over the steps that a node (Charlie) receiving this message will go through in order to verify the new channel that Alice and Bob claimed to have opened.\n First, Charlie will use the short_channel_id included in the message to make sure that the channel’s funding transaction actually exists on-chain, that it has a sufficient number of confirmations and that it is in fact unspent. Then, Charlie will also check that the unspent output actually does look like a Lightning channel owned by alice_pubkey_1 and bob_pubkey_1. He will do this by using the advertised pubkeys to reconstruct the P2WSH and ensure that it is the same as the one found on-chain. Now, Charlie will want to confirm that the nodes owning the pubkeys found in the channel funding output do in fact belong to the nodes owning the node ID pubkeys. This is done by verifying the alice_pubkey_1_sig and bob_pubkey_1_sig signatures. If these signatures are valid, then it is clear that the owners of alice_pubkey_1 and bob_pubkey_1 agree to being associated with alice_node_ID and bob_node_ID since the message signed includes these nodes IDs. Finally, Charlie will also want to ensure that owners of the node ID pubkeys agree to being associated with the new channel. This is done by verifying the alice_node_ID_sig and bob_node_ID_sig signatures. If these signatures are valid, then it is clear that the owners of alice_node_ID_sig and bob_node_ID_sig agree to being associated with alice_pubkey_1 and bob_pubkey_1 since the message signed includes these pubkeys.  Alice and Bob are done! Their channel is open and other nodes in the network, like Charlie, will happily use the new channel.\nIn the next post, I will dive into how the above process will change with taproot channels (given the current proposal). The main thing that will need to change is how signatures are dealt with. In all the above cases, Alice and Bob didn\u0026rsquo;t really need to do anything special when they were generating their signatures since they each would need to provide their own signature to sign for the 2-of-2 funding transaction. But with taproot, the funding output will use Musig2 to combine the pubkeys of Alice and Bob and so any signatures will need to involve the Musig2 signing protocol… But let’s leave the details of that for next time :)\n  https://github.com/lightning/bolts/pull/995\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"https://www.ellemouton.com/posts/open_channel_pre_taproot/","summary":"A deep dive into opening a pre-taproot Lightning Network channel","title":"Opening and announcing a pre-taproot LN channel"},{"content":"In this post, I will briefly describe the needs of a bitcoin light client and why compact block filters satisfy these needs better than Bloom filters do. Then I will dive into exactly how compact block filters work and will follow this with a step by step guide for constucting such a filter from a testnet block.\nThe purpose of block filters A bitcoin light client is software that can back a bitcoin wallet without storing the blockchain. This means that it needs to be able to broadcast transactions to the network but most importantly it must be able to pick up when there is a new transaction that is relevant to the wallet it is backing. There are two ways a transaction becomes relevant to a wallet: either it is sending money to the wallet (creating a new output to a wallet address) or it is spending one of the UTXOs that the wallet owns.\nWhat was wrong with Bloom filters? Before BIP 158 came along, the most widely used method for light clients was to use Bloom filters1 as described in BIP 37. With a bloom filter, you take all the objects you are interested in (script pub keys spent or created), hash them a couple times and add the result of each to a bit map called a Bloom filter. This filter represents what you are interested in. You would then send this filter to a trusted bitcoin node and ask them to send you anything that matches your filter. The problem with this is that it is not very private since you are revealing some information to the bitcoin node you are sending this filter too. They can start getting an idea of the transactions you are interested in as well as the ones you are definitely not interested in. They can also just decide not to send you a transaction that matches the filter. So as you can see, it isn’t great for the light client. But it is also not great for the bitcoin node serving the light client. Each time you send them a filter, they have to load the relevant block from disk and determine which transactions match your filter. You could just spam them with fake filters and effectively DOS them. It takes very little energy to create a filter and lots to respond to it.\nIntroducing Compact Block Filters: Ok, take two. What we want is:\n More privacy Less asymmetry in the client - server work load. Ie, the server should be required to do way less work. Less trust. The light client shouldn\u0026rsquo;t need to worry about the server holding back relevant transactions.  With compact block filters, the server (full node) will for each block construct a deterministic filter that includes all the objects in the block. This filter can be calculated once and persisted. If light clients request a filter for a block, there is no asymmetry since the server wont have to do any more work than the client had to do when making the request. A light client can also choose to download the filters from multiple sources to ensure they match and can always download the full block and check for itself if the filter that the server provided was indeed correct given the blocks contents. Another bonus is that this is way more private. The light client no longer sends a fingerprint of the data it is interested in to the server. And so it becomes way more difficult to analyse the light client\u0026rsquo;s activity. The light client gets these filters from the server and checks for itself if any of its objects match what is seen in the filter and if it does match, then the light client asks for the full block. One thing to note with this way of doing things is that full nodes serving the light clients will need to persist these filters and the light clients might also want to persist a few filters and so it is important that the filters are as small as possible (hence the name, compact block filters).\nCool! Now we get to the cool stuff. How is this filter created? What does it look like?\nWhat do we want?\n We want to put fingerprints of certain objects in the filter so that when clients are looking to see if a block maybe contains info relevant to them, they can take all their objects and check if the filter matches on those objects. We want the filters to be as small as possible. Effectively we want to sort of summarise some of the block info… in a size much much smaller than the block.  The info included in the basic filter is: every transaction\u0026rsquo;s input\u0026rsquo;s scriptPubKey being spent and every transaction\u0026rsquo;s output\u0026rsquo;s scriptPubKey being created. So something like this:\nobjects = {spk1, spk2, spk3, spk4, ..., spkN} // A list of N scriptPubKeys. Technically we could just stop here and say this list of scriptPubKeys is our filter. It is a condensed version of what is in the block chain and contains the info the light client needs. With this list they could tell with 100% certainty if something they are interested in is in the block. But it is still pretty big. So the next step is all about making this list as compact as possibly. This is where things get insanely cool.\nFirst we convert each object into a number in a range such that the object numbers are uniformly distributed in that range: Let\u0026rsquo;s say we have 10 objects (N = 10), then we have some function that turns each of the objects into a number. Let’s say we chose the range [0, 10] since we have 10 objects. Now the hashing-plus-convert-to-number function we use will take each object and produce a number in the space from [0, 10]. It is uniformly distributed in this space. That means that, after ordering them, we will get (in the very very ideal case) something like this:\nFirst of all, wow that is so great cause we have drastically decreased the size of an objects finger print. Each one is just a number now. Ok so, let this be our new filter:\nnumbers := {1,2,3,4,5,6,7,8,9,10} Now a light client downloads the filter and wants to see if one of the objects they are looking for is matched in this filter. All they need to do is take their objects and do the same hashing-plus-convert-to-number scheme and check if any of the numbers are in the filter. What is the problem? The filter has a number for each possible number in the space! Meaning that absolutely any object will match on this filter. In other words, the false-positive rate of this filter is 1. This is no good. We have lost too much info on our quest to compress the data in the filter. What we need is a higher false-positive (fp) rate. Ok so let’s say we want a false positive rate of 5. Then what we want is to have our objects be mapped uniformly to a space of [0, 50]:\nThis is starting to look a bit better. If I am a client downloading this filter and I check if my objects are maybe in the filter, there will be a 1/5 chance that if it matches, it is a false positive. Great so now we have mapped 10 objects to numbers between 0 \u0026amp; 50. This new list of numbers is our filter. Again, we could stop here… but we can compress this even further!!\nWe have this list of ordered numbers that we know are distributed uniformly across this space between [0, 50]. We know that there are 10 items in the list. What this means is that we can deduce that the most likely difference between each of the numbers in this ordered list is about 5. In general, if we have N items and a false positive rate of M, then the space will be of size N * M. So the numbers in the space can range from 0 to N * M, but the difference between each number (once ordered) will be roughly M. M will definitely be a smaller number to store than a number in the N * M space. So what we can do is instead of storing each number, we can instead store the difference of each successive number. In the above case, this would mean that instead of storing [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50], we just store [0, 5, 5, 5, 5, 5, 5, 5, 5, 5] and then it is trivial to reconstruct the original list. As you can gather, storing the number 50 requires way more bits than storing the number 5. But why stop there? We can compress this even further!\nThis is where Golomb-Rice Coding comes in. This encoding works well for a list of numbers that will all very likely be close to some number. This is what we have! We have a list of numbers that will all very likely be close to 5 (or, in general, close to our FP rate of M) and so taking the quotient of any number in the list with that number (dividing each number by 5 and ignoring the remainder) will very likely be 0 (if the number is slightly less than 5) or 1 if the number is slight more than 5. The quotient could be 2, 3 etc but the likelihood decreases a lot. Great! So we can take advantage of this knowledge and say that we will encode a small quotient with the smallest number of bits that we can and use more bits to encode larger, unlikely, quotients. Then we also need to encode the remainders (since we want to be able to reconstruct the values exactly) and these will always be numbers between [0, M-1] (in our case, [0, 4]). For encoding the quotients, we use the following mapping:\nThe mapping above is easy to read: The number of 1s indicates the quotient we are encoding and the 0 indicates the end of the quotient encoding. So for each number in our list, we encode the quotient using the above table and then we convert the remainder to binary using the number of bits needed to encode the maximum of M-1. In our case, that is 3 bits. Here is a table showing the encoding of the possible remainders in our example:\nSo, in our ideal case example, our list of [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5] can be encoded as follows:\n0000 10000 10000 10000 10000 10000 10000 10000 10000 10000 Before we move on to a more realistic example, let’s see if we can reconstruct our original list from this filter.\nOk so we have: “0000100001000010000100001000010000100001000010000”. We know the how Golomb-Rice Coding encodes quotients and we also know that M is 5 (since this will be public knowledge known to everyone using this filter construction). Since we know M is 5, we know that 3 bits will be used to encode the remainders. So we can take our filter and produce the following quotient-remainder tuples:\n[(0, 0), (1, 0), (1, 0), (1, 0), (1, 0), (1, 0), (1, 0), (1, 0), (1, 0), (1, 0)] We know that the quotients were produced by dividing number by M (5), so we can reconstruct these:\n[0, 5, 5, 5, 5, 5, 5, 5, 5, 5] And we know that this list represents differences of numbers, so we can reconstruct the OG list:\n[0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50] A more realistic example We will now try to construct a filter from an actual Bitcoin testnet block. I\u0026rsquo;m going to use block 2101914. Let’s see what it’s actual filter is:\n$ bitcoin-cli getblockhash 2101914 000000000000002c06f9afaf2b2b066d4f814ff60cfbc4df55840975a00e035c $ bitcoin-cli getblockfilter 000000000000002c06f9afaf2b2b066d4f814ff60cfbc4df55840975a00e035c { \u0026quot;filter\u0026quot;: \u0026quot;5571d126b85aa79c9de56d55995aa292de0484b830680a735793a8c2260113148421279906f800c3b8c94ff37681fb1fd230482518c52df57437864023833f2f801639692646ddcd7976ae4f2e2a1ef58c79b3aed6a705415255e362581692831374a5e5e70d5501cdc0a52095206a15cd2eb98ac980c22466e6945a65a5b0b0c5b32aa1e0cda2545da2c4345e049b614fcad80b9dc9c903788163822f4361bbb8755b79c276b1cf7952148de1e5ee0a92f6d70c4f522aa6877558f62b34b56ade12fa2e61023abf3e570937bf379722bc1b0dc06ffa1c5835bb651b9346a270\u0026quot;, \u0026quot;header\u0026quot;: \u0026quot;8d0cd8353342930209ac7027be150e679bbc7c65cc62bb8392968e43a6ea3bfe\u0026quot; } Ok shweeeeeet, let’s see if we can reconstruct this filter from the block.\nThe full code for this can be found in this github repo. I will just show some pseudo code snippets here. The beef of the code is the function called constructFilter which takes in a bitcoin client that can be used to make calls to bitcoind and the block in question. The function looks something like this:\nfunc constructFilter(bc *bitcoind.Bitcoind, block bitcoind.Block) ([]byte, error) { // 1. Collect all the objects from the block that we want to add to the filter  // 2. Convert all the objects to numbers and sort them.  // 3. Get the differences between the sorted numbers  // 4. Encode these differences using Golomb-Rice Coding } Ok so step 1 is to collect all the objects from the block that we want to add to the filter. From the BIP, we know that these objects are all the scriptPubKeys being spent as well as all the scriptPubKeys of each output. Some extra rules from the BIP are that we skip the input for the coinbase transaction (since it is empty and meaningless) and we skip any OP_RETURN outputs. We also de-duplicate the data. So if there are two identical scriptPubKeys, we only include one in the filter.\n// The list of objects we want to include in our filter. These will be // every scriptPubKey being spent as well as each output\u0026#39;s scriptPubKey. // We use a map so that we can dedup any duplicate scriptPubKeys. objects := make(map[string] struct{}) // Loop over every transaction in the block. for i, tx := range block.Tx { // Add the scriptPubKey of each of the transaction\u0026#39;s outputs  // and add those to our list of objects.  for _, txOut := range tx.Vout { scriptPubKey := txOut.ScriptPubKey if len(scriptPubKey) == 0 { continue } // We don\u0026#39;t add the output if it is an OP_RETURN (0x6a).  if spk[0] == 0x6a { continue } objects[skpStr] = struct{}{} } // We don\u0026#39;t add the inputs of the coinbase transaction.  if i == 0 { continue } // For each input, go and fetch the scriptPubKey that it is  // spending.  for _, txIn := range tx.Vin { prevTx, err := bc.GetRawTransaction(txIn.Txid) if err != nil { return nil, err } scriptPubKey := prevTx.Vout[txIn.Vout].ScriptPubKey if len(scriptPubKey) == 0 { continue } objects[spkStr] = struct{}{} } } Ok great, we have all the objects we care about. And now we can also define the variable N to be the length of the objects map. In this example, N is 85.\nThe next step is to convert each of the objects to numbers spread uniformly across a range. Remember that this range depends on the false-positive rate we want. BIP158 defines the constant M to be 784931. This means that we want every 1/784931 matches to be a false-positive. As we did in our earlier example, we take this fp rate of M and multiply it by N to get the range that we want all our numbers to lie in. We define this as F where F = M*N. In our case, we have 85 objects and so F=66719135. I am not going to go into the details of the function used to map our objects to numbers (you can check out the details of this in the code in the linked repo). All you need to know for now is that it takes in an object, the constant F which defines the range that it needs to map the object to, and a key which is the block hash. Once we have all the numbers, we sort the list in ascending order and then we also create a new list called differences which will hold the differences between each sequential number in the sorted numbers list.\nnumbers := make([]uint64, 0, N) // Iterate over all the objects, convert them to numbers lying uniformly in the range [0, F] // and add them to the `numbers` list. for o := range objects { // Using the given key, max number (F) and object bytes (o),  // convert the object to a number between 0 and F.  v := convertToNumber(b, F, key) numbers = append(numbers, v) } // Sort the numbers. sort.Slice(numbers, func(i, j int) bool { return numbers[i] \u0026lt; numbers[j] }) // Convert the list of numbers to a list of differences. differences := make([]uint64, N) for i, num := range numbers { if i == 0 { differences[i] = num continue } differences[i] = num - numbers[i-1] } Awesome! Here is a graph showing the values in the numbers and differences lists:\nAs you can see, the 85 numbers are really nicely uniformly distributed across the space! And this results in the values in the differences list being pretty small.\nThe last step now is to use Golomb-Rice Coding to encode this differences list. Recall from the earlier explanation that we need to divide each difference by it’s most likely value and then we encode that quotient along with the remainder. In my earlier example I said that this most-likely value would be the M that we choose and that the remainder would then lie in the range [0, M]. However, this is not what is done in the BIP as it was found2 that this is in fact not the ideal way to choose the Golomb-Rice coder parameter when trying to optimize for the smallest possible size of the final encoded filter. And so instead of using M, a new constant of P is defined and P^2 is used as the Golomb-Rice parameter. P is defined as 19. This means that each difference value is divided by 2^19 to get the quotient and remainder and the remainder is then encoded in binary in 19 bits.\nfilter := bstream.NewBStreamWriter(0) // For each number in the differences list, calculate the quotient and // remainder after dividing by 2^P. for _, d := range differences { q := math.Floor(float64(d)/math.Exp2(float64(P))) r := d - uint64(math.Exp2(float64(P))*q) // Encode the quotient.  for i := 0; i \u0026lt; int(q); i++ { filter.WriteBit(true) } filter.WriteBit(false) filter.WriteBits(r, P) } Great stuff! Now when we print out this filter, we get:\n71d126b85aa79c9de56d55995aa292de0484b830680a735793a8c2260113148421279906f800c3b8c94ff37681fb1fd230482518c52df57437864023833f2f801639692646ddcd7976ae4f2e2a1ef58c79b3aed6a705415255e362581692831374a5e5e70d5501cdc0a52095206a15cd2eb98ac980c22466e6945a65a5b0b0c5b32aa1e0cda2545da2c4345e049b614fcad80b9dc9c903788163822f4361bbb8755b79c276b1cf7952148de1e5ee0a92f6d70c4f522aa6877558f62b34b56ade12fa2e61023abf3e570937bf379722bc1b0dc06ffa1c5835bb651b9346a270 Apart from the first two bytes, this matches the filter we got from bitcoind exactly! Why the 2 byte difference? The BIP says that the N value needs to be encoded in CompactSize format and appended to the front of the filter so that it can be decoded by the receiver. This is done as follows:\nfd := filter.Bytes() var buffer bytes.Buffer buffer.Grow(wire.VarIntSerializeSize(uint64(N)) + len(fd)) err = wire.WriteVarInt(\u0026amp;buffer, 0, uint64(N)) if err != nil { return nil, err } _, err = buffer.Write(fd) if err != nil { return nil, err } If we print out the filter now, we get one that matches the one we got from bitcoind exactly:\n5571d126b85aa79c9de56d55995aa292de0484b830680a735793a8c2260113148421279906f800c3b8c94ff37681fb1fd230482518c52df57437864023833f2f801639692646ddcd7976ae4f2e2a1ef58c79b3aed6a705415255e362581692831374a5e5e70d5501cdc0a52095206a15cd2eb98ac980c22466e6945a65a5b0b0c5b32aa1e0cda2545da2c4345e049b614fcad80b9dc9c903788163822f4361bbb8755b79c276b1cf7952148de1e5ee0a92f6d70c4f522aa6877558f62b34b56ade12fa2e61023abf3e570937bf379722bc1b0dc06ffa1c5835bb651b9346a270 Yay!\nHowever, from my understanding, there is no need to add N to the filter. If you know the value of P, then you can figure out the value of N. Let’s do this now by seeing if we can take the filter above, and reconstruct the original list of numbers:\nb := bstream.NewBStreamReader(filter) var ( numbers []uint64 prevNum uint64 ) for { // Read a quotient from the stream. Read until we encounter  // a \u0026#39;0\u0026#39; bit indicating the end of the quotient. The number of  // \u0026#39;1\u0026#39;s we encounter before reaching the \u0026#39;0\u0026#39; defines the  // quotient.  var q uint64 c, err := b.ReadBit() if err != nil { return err } for c { q++ c, err = b.ReadBit() if errors.Is(err, io.EOF) { break } else if err != nil { return err } } // The following P bits are the remainder encoded as binary.  r, err := b.ReadBits(P) if errors.Is(err, io.EOF) { break } else if err != nil { return err } n := q*uint64(math.Exp2(float64(P))) + r num := n + prevNum numbers = append(numbers, num) prevNum = num } fmt.Println(numbers) The above produces the same list of numbers that we had before and we were able to reconstruct this without the knowledge of N. So I am not sure why it was decided that N should be added to the filter. If anyone knows why it was required to add N to the filter, please let me know!\nCool, that was fun! Thanks for reading. Yeeeeet!\n  https://en.wikipedia.org/wiki/Bloom_filter\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://gist.github.com/sipa/576d5f09c3b86c3b1b75598d799fc845\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"https://www.ellemouton.com/posts/bip158/","summary":"What even is Golomb-Rice Coding?","title":"BIP158: Compact Block Filters Deep Dive"},{"content":"In previous post gave a simplified overview of HTLCs. This post will look in more detail at what these HTLCs actually look like and how they fit in the commitment transactions.\nFrom Part 2 on the Update layer, we learned a few things about how commitment transactions are done:\nFirst of all, they are asymmetric: Alice and Bob (the two participants of a channel) each hold their own commitment transactions. The commitment transactions that each participant holds looks slightly different to that of their peer in that any output going to the local node must be encumbered by a relative time lock of to_self_delay. This is to give the other party a chance to spend along the revocation path of the output if they need.\nGiven the above requirements of a commitment transaction, let’s look at how HTLC’s will fit into all of this. To do this, let’s use the example from the previous post where Alice is sending 2 BTC to a recipient and is using her channel with Bob as the first hop in the route (he might even be the final recipient). Remember that Alice has been given a hash, H, to which she needs to pay. In this example, Alice is the HTLC offerer and Bob is the HTLC receiver.\nZooming in on Alice: Let’s zoom in on how Alice will construct her commitment transaction to now include the HTLC. The commitment transaction will have three outputs:\n One 5 BTC output to Bob (spendable immediately). One 3 BTC output with two possible spending paths: One spendable by Alice after a to_self_delay and one immediately spendable by Bob if he has the required revocation key (see post 2 and post 3 for more details on revocation). One 2 BTC output with…. ok so here is where it gets tricky. Let’s think about what needs to be here a bit.  This output is where the HTLC magic must happen. We need the following spending paths on this output:\n It needs to be spendable by Bob if he has the pre-image of H (hash-locked path) Or spendable by Alice after cltv_expiry Or spendable by Bob immediately if he has the revocation key  BUT remember that Alice’s outputs to herself must always have a relative timelock of to_self_delay even after cltv_expiry. Knowing this, let’s update the HTLC spending paths a bit:\n It needs to be spendable by Bob if he has the pre-image of H (hash-locked path) Or spendable by Alice after absolute time cltv_expiry AND after relative delay to_self_delay Or spendable by Bob immediately if he has the revocation key  There is still a problem: Making the output to Alice encumbered by both these timelocks could in the worst case extend the HTLC’s timeout by to_self_delay. In other words, Bob could have an extra to_self_delay blocks in order to sweep the hash-locked output even though the HTLC is technically expired. So what is done instead is that instead having this output being locked by both timelock conditions, it is instead only locked by just the cltv_expiry one and then instead of sending funds to Alice directly, the funds are instead sent to a separate HTLC-timeout transaction (signed by both Alice and Bob) and this separate time out transaction then enforces the to_self_delay. This allows Alice to definitively lock in the fact that the HTLC has expired and removes Bob’s ability to claim the hash-locked output all while still ensuring that Alice can only get her funds after to_self_delay and thus still allow Bob to spend from the revocation path (of the HTLC-timeout transaction) if needed.\nThe final state of the commitment transaction’s HTLC output spending paths is as follows:\n One spending path to Bob if he pre-image of H (hash-locked path) One spending path to Bob if he has the revocation key. One spending path to a second-state HTLC-timeout transaction.  The HTLC-timeout transaction has the following construction:\n The transaction itself is timelocked with nLocktime set to cltv_expiry. Thus the spending path in the original commitment transaction that sends to this HTLC-timeout transaction is effectively time delayed by cltv_expiry. The transaction has one output with two possible spending paths:  one to Alice after to_self_delay one to Bob if he can provide the revocation key.    The Script for Alices (the HTLC offerer) commitment transaction’s HTLC output looks as follows:\n# To remote node with revocation key OP_DUP OP_HASH160 \u0026lt;RIPEMD160(SHA256(revocationpubkey))\u0026gt; OP_EQUAL OP_IF OP_CHECKSIG OP_ELSE \u0026lt;remote_htlcpubkey\u0026gt; OP_SWAP OP_SIZE 32 OP_EQUAL OP_NOTIF # To local node via HTLC-timeout transaction (timelocked). OP_DROP 2 OP_SWAP \u0026lt;local_htlcpubkey\u0026gt; 2 OP_CHECKMULTISIG OP_ELSE # To remote node with preimage. OP_HASH160 \u0026lt;RIPEMD160(payment_hash)\u0026gt; OP_EQUALVERIFY OP_CHECKSIG OP_ENDIF OP_ENDIF You can see in the script above that the first path is the revocation path, the second is the path to the HTLC-timeout transaction (the time-locked path) and the third is the hash-locked spending path.\nThe HTLC-timeout transaction output script looks as follows:\nOP_IF # Penalty transaction \u0026lt;revocationpubkey\u0026gt; OP_ELSE `to_self_delay` OP_CHECKSEQUENCEVERIFY OP_DROP \u0026lt;local_delayedpubkey\u0026gt; OP_ENDIF OP_CHECKSIG Zooming in on Bob: Let’s now zoom in on how Bob (the HTLC receiver) will construct his commitment transaction to include the HTLC. The commitment transaction will have three outputs:\n One 3 BTC output to Alice (spendable immediately). One 5 BTC output with two possible spending paths: One spendable by Bob after a to_self_delay and one immediately spendable by Alice if she has the required revocation key Again the 2 BTC output on Bob’s commitment transaction is a bit complicated. Let’s dive in.  Let’s again think about what spending paths this output should have:\n There should be a spending path that Bob can claim if he has the pre-image of H (hash-locked path) but since it is an output to himself it needs to have a to_self_delay. One spending path should be spendable by Alice immediately by Alice if she has the necessary revocation key. One spending path also needs to be spendable by Alice after cltv_expiry (time-locked output).  The problem with having all the above spending paths in the same script is that if Bob knows the pre-image but now has to wait to_self_delay blocks in order to spend from the hash-locked path then there is a change that this to_self_delay is longer than the cltv_expiry that Alice must wait in order to claim the time-locked path. So Alice could potentially spend along the time-locked even though Bob does have the pre-image. Similar to the situation with Alices commitment transaction, Bob needs a way to lock in the fact that the hash-locked path will be used while still delaying his redemption of the funds by to_self_delay. So, a separate HTLC-success transaction is used for this thus allowing Bob to spend from the hash-locked path to this HTLC-success transaction which will then separately enforce the to_self_delay condition.\nThe final state of the commitment transaction’s HTLC output spending paths is as follows:\n One spending path to Alice if she has the revocation key (revocation path) One spending path to Alice after cltv_expiry (time-locked path) One spending path to the HTLC-success transaction IF Bob can reveal the pre-image of H (hash-locked path).  The HTLC-timeout transaction has the following construction:\n The transaction is not time locked (unlike in Alice’s case). The transaction has one output with two possible spending paths:  one to Bob after to_self_delay one to Alice if she can provide the revocation key.    The Script for Bob’s (the HTLC receiver) commitment transaction’s HTLC output looks as follows:\n# To remote node with revocation key OP_DUP OP_HASH160 \u0026lt;RIPEMD160(SHA256(revocationpubkey))\u0026gt; OP_EQUAL OP_IF OP_CHECKSIG OP_ELSE \u0026lt;remote_htlcpubkey\u0026gt; OP_SWAP OP_SIZE 32 OP_EQUAL OP_IF # To local node via HTLC-success transaction. OP_HASH160 \u0026lt;RIPEMD160(payment_hash)\u0026gt; OP_EQUALVERIFY 2 OP_SWAP \u0026lt;local_htlcpubkey\u0026gt; 2 OP_CHECKMULTISIG OP_ELSE # To remote node after timeout. OP_DROP \u0026lt;cltv_expiry\u0026gt; OP_CHECKLOCKTIMEVERIFY OP_DROP OP_CHECKSIG OP_ENDIF OP_ENDIF You can see in the script above that the first path is the revocation path, the second is the path to the HTLC-timeout transaction (and is also the hash-locked path) and the third is the time-locked spending path.\nThe HTLC-timeout transaction output script looks as follows:\nOP_IF # Penalty transaction \u0026lt;revocationpubkey\u0026gt; OP_ELSE `to_self_delay` OP_CHECKSEQUENCEVERIFY OP_DROP \u0026lt;local_delayedpubkey\u0026gt; OP_ENDIF OP_CHECKSIG All together now: The final construction looks as follows:\nYeeeeet!\n","permalink":"https://www.ellemouton.com/posts/htlc-deep-dive/","summary":"Day 7 of #7DaysOfBitcoin","title":"LN Things Part 5: HTLC Deep Dive"},{"content":"The previous 2 posts were all about sending funds between the two participants of a channel (agreeing on current state and invalidating older state). This post will give an overview of HTLCs and how they allow multi-hop payments to be made. The next post will be a deep dive into exactly what these HTLCs look like and how they fit into the commitment transactions of a channel.\nLet’s look at a simple example.\nSimple 3 node, 2 hop network: In this example, the network is make up of three nodes (Alice, Bob and Charlie) and there are two channels set up: One between Alice and Bob and another between Bob and Charlie. Each channel has a capacity of 10 BTC and to start with the funds of each channel will be divided equally between the participants.\nFor the purposes of this overview of HTLCs, the commitment transactions describing the channels will be shown as they are in the diagram above, with one commitment transaction spending from the funding transaction and hence determining the channel state. This is not accurately representing the asymmetric construction described in post 2 but it will make the overview easier to understand. A more accurate description will be given in a later post.\nSuppose that Alice would like to pay Charlie. She cant pay him directly since they do not have a shared channel and it is costly (in terms of time and money) to open a channel just for the purposes of a quick transaction. Instead, Alice can use her channel with Bob to route a payment to Charlie since Bob has a channel with Charlie.\nStep 1: Generating and sharing the pre-image hash Alice first needs to tell Charlie that she wants to pay him. Charlie will then generate a random secret, S, and get the hash of S which we will call H. Charlie then sends H to Alice.\nStep 2: Setting up the chain of HTLCs\nLet’s say that Alice wants to pay Charlie 1 BTC. She will then find a route to Charlie (A-B-C) and will see that in order to use this route she will need to incentivise Bob to help her out by paying him a routing fee. In this example Bob charges a flat fee of 1 BTC for routing payments and so Alice will be paying a total of 2 BTC: 1 BTC for routing and 1 BTC for the recipient, Charlie. Alice then communicates with Bob that she would like to route a payment through him and does this by suggesting that they update their channel’s commitment transaction to have the following outputs (remember this is overly simplified and in reality both Alice and Bob will have their own commitment transactions):\n An output of 3 BTC back to Alice An output of 5 BTC to Bob An output of 2 BTC to a special script that has 2 possible spending paths: The first path can be spent by Bob if he has the pre-image of H. The second path can be spent by Alice after an absolute time cltv_expiry_AB. This special script that locks up the 2 BTC is called a Hash and Time Locked Contract (HTLC) because it has one hash-locked path and one time-locked path.  Bob will be happy to update to this new channel state because he can see that he is not loosing money (if the transaction goes on-chain and he still does not have the pre-image then he still gets back his original funds). And he can see that if he co-operates and continues with the payment forwarding process then he will be rewarded with a routing fee if the payment is successful because he will be able to claim the hash-locked output on the transaction.\nBob then goes ahead and locks up some of his funds in a similar way in his channel with Charlie. He updates the channel commitment transaction to have the following outputs:\n An output of 4 BTC to Bob An output of 5 BTC to Charlie An output of 1 BTC to an HTLC script that again has 2 spending paths: one spendable by Charlie if he can reveal the pre-image of H and one to Bob spendable after cltv_expiry_BC.  Bob is confident in locking his liquidity up in this way because if the payment fails then he will be able to claim his funds back along the HTLC’s time-locked path and if the payment is successful and the pre-image is revealed by Charlie when he spends along the hash-locked path then Bob will see this pre-image and will be able to claim the hashed-lock output in HTLC output from the commitment transaction he has with Alice.\nWhen Charlie receives this HTLC offer from Bob, he can see that he in fact does know the pre-image, S, that hashes to H and so he knows that he can claim the hash-locked path of the commitment transactions HTLC output if it were to go on-chain. Ideally, channels should remain open though so instead of publishing the transaction on-chain and sweeping the hash-locked contract there, Charlie instead just sends the pre-image, S, to Bob. This proves to Bob that Charlie would be able to claim the HTLC output if they were to broadcast the commitment transaction on-chain and so now the two parties can agree to just update their commitment transaction to reflect that Charlie now has the 1 BTC extra:\nNow that Bob has S, he can turn around and reveal S to Alice and thus prove to Alice that if their commitment transaction were to go on-chain, that Bob would be able to claim the hash-locked output. So as Bob and Charlie did in their channel, Alice and Bob similarly update their commitment transaction by removing the HTLC output and just reflecting the new balances:\nAlice has now effectively paid Charlie 1 BTC and Bob has earned a routing fee of 1 BTC.\nSome extra details: What if things go wrong? Perhaps Charlie goes offline and doesn’t respond to Bob with a pre-image. If this happens then Bob will need to broadcast the commitment transaction so that he can claim his funds back via the time-locked path of the HTLC. If he does broadcast the transaction but then Charlie comes back online before cltv_expiry_BC has been reached and goes and spends via the HTLC’s hash-locked path then Bob will be able to see the pre-image on the blockchain and will then be able to turn around to Alice and reveal the pre-image to her as per usual. From this example, you can see that it is important for the cltv_expiry values to decrease along the path from the sender to the receiver. This is because in the worst case, Charlie only reveals S to Bob just before cltv_expiry_BC and then Bob still needs time to turn around and reveal S to Alice before she is able to spend along the ctlv_expiry_AB path. Therefor cltv_expiry_BC must be before ctlv_expiry_AB.\n","permalink":"https://www.ellemouton.com/posts/htlc/","summary":"Day 6 of #7DaysOfBitcoin","title":"LN Things Part 4: HTLC Overview"},{"content":"In Part 2 I gave an overview of how two participants of a payment channel go about agreeing on a state and how they update their state. In this post we will look at the scripts used in the commitment transactions and dig into the revocation key process a bit more.\nTaking a look at Alice’s commitment transaction again: it spends from the funding transaction and has two outputs: a to_local output and a to_remote output.\nto_remote This output is simply a P2WPKH send to a public key belonging to Bob.\n\u0026lt;remotepubkey\u0026gt; to_local This output has 2 spending paths:\n the first is to a \u0026lt;revocationpubkey\u0026gt; the second is to a Public key belonging to Alice but is only spendable after a relative delay of to_self_delay blocks.  OP_IF # Penalty transaction \u0026lt;revocationpubkey\u0026gt; OP_ELSE `to_self_delay` OP_CHECKSEQUENCEVERIFY OP_DROP \u0026lt;local_delayedpubkey\u0026gt; OP_ENDIF OP_CHECKSIG In Part 2, the revocation key system was described as follows:\n Alice generates a temporary private key dA1 and its corresponding public key PA1 and sends the public key to Bob. Then Alice creates a commitment transaction where the to_local_output output has a spending path that is immediately spendable by Bob if he has the private ket dA1. If Alice and Bob agree to update their channel state, then the private keys for the previous state will be swapped (ie: Alice will send Bob dA1).  This description is mostly correct but not complete. If you take a look at the to_self_delay script above, you can see that the revocation path doesn’t have any condition that makes it seem like only Bob can spend it. It just looks like anyone with the private key corresponding the revocation public key can spend the output. This makes it seem like Alice can also spend the output since she is the one who derived the temporary private key in the first place. After diving into the LND code a bit to try and figure this out, I found that a very cool trick is used to ensure that only Bob can spend via the revocation path. (See function DeriveCommitmentKeys).\nBefore construction the commitment transactions, both Alice and Bob derive two temporary keys and the associated public keys. They will both derive a revocation_basepoint (r -\u0026gt; R) and a per_commitment_point (c -\u0026gt; C).\n Alice will have her revocation_basepoint key pair: rA1 -\u0026gt; RA1 and her per-commitment key pair: cA1 -\u0026gt; CA1. Bob will have his revocation_basepoint key pair: rB1 -\u0026gt; RB1 and his per-commitment key pair: cB1 -\u0026gt; CB1.  Now, in order to create her commitment transaction, Alice will send Bob her commitment point public key, CA1 and Bob will send Alice his revocation_basepoint public key, RB1. Alice then derives the following Revocation key RevA1 as follows:\nRev_A1 = R_B1 * sha256( R_B1 || C_A1 ) + C_A1 * sha256( C_A1 || R_B1 ) Alice’s to_local output script now looks as follows:\nOP_IF \u0026lt;Rev_A1\u0026gt; OP_ELSE `to_self_delay` OP_CHECKSEQUENCEVERIFY OP_DROP \u0026lt;alice_delayedpubkey\u0026gt; OP_ENDIF OP_CHECKSIG Now when the times comes for Alice and Bob to update their state and invalidate this old state, Alice sends Bob her private key for her per-commitment key pair, c_A1. With this key, Bob will be able to derive the private key corresponding the the public key Rev_A1 and will therefore be able to spend via the revocation output. He can do this because he has private key r_B1 that corresponds to public key R_B1. So he can calculate the private key as follows:\nrev_A1 = r_B1 * sha256( R_B1 || C_A1 ) + c_A1 * sha256( C_A1 || R_B1 ) Alice will not be able to derive this private key because she does not and will never have the private key r_B1.\nUpdated Diagrams from Post 2: State 1: State 2: ","permalink":"https://www.ellemouton.com/posts/revocation/","summary":"Day 3 of #7DaysOfBitcoin","title":"LN Things Part 3: Revocation in more detail"},{"content":"Today’s post is more of a set up for the next one. It describes the basics of the Lightning Network update layer using LN-Penalty. The next post will introduce HTLCs and then will dive into how the HTLCs fit into commitment transactions and how this plays along with the update layer.\nThe previous post described how Alice and Bob set up a channel. It mentioned that both Alice and Bob had commitment transactions that spent from the on-chain funding transaction and that the commitment transactions were both valid and could be published on the blockchain and pay the recipients what they are owed.\nThis post will describe the commitment transactions in more detail and will also show how the participants of the channel can agree on a new division of funds. In other words: how they create new commitment transaction that splits the funds differently and at the same time invalidate the older commitment transactions that they have.\nAsymmetric commitment transactions: In LN-penalty, each party in the channel will hold a commitment transaction representing the state of the channel. Why? To assigning blame. The commitment transactions held by each party vary slightly (details to follow) and this makes it clear which party broadcasted their commitment transaction and makes it possible for the correct party to be punished if they broadcast an invalid state. This concept will be made more clear in this post.\nSetting up state 1: Let’s assume that Alice and Bob start out each owning 5 BTC in a 10 BTC channel. To set up their initial commitment transactions, each party will first create temporary private keys (dA1 for Alice and dB1 for Bob) and calculate their associated public key (PA1 and PB1). Alice and Bob will then send each other the temporary public keys. At this point, both parties can construct their own commitment transaction. Alice’s will look as follows:\n It will spend from the funding transaction. It will have 2 outputs. (or more. HTLC outputs to come!) The to_remote output will send Bob his 5 BTC immediately. the to_local output is fancier: It either sends Alice her 5 BTC after an OP_CSV to_self_delay or it can immediately be spent by Bob if he is able to prove that he has Alices temporary private key dA1.  Bob will be able to construct Alice’s commitment transaction too and will thus be able to provide her with his signature for the input of her transaction (the one that spends from the channel’s funding transaction). And so Alice will have this valid transaction with Bob’s signature and so she can at any point sign it her self and broadcast it to the network to be confirmed in a block.\nBob will create his commitment transaction in a similar way. See the diagram below:\nNote that at this point, either party can broadcast their commitment transactions to the network. For example, let’s say Alice broadcasts her’s. Bob will get his 5 BTC immediately and Alice will need to wait to_self_delay blocks before she is able to use her 5 BTC. She doesn’t need to worry about Bob spending her output though because she knows that she never shared her secret private key with him.\nSetting up state 2: Now Alice wants to send Bob 1 BTC using their channel. So just like for stage 1, both parties will now generate new temporary private keys (dA2 for Alice and dB2 for Bob), calculate their associated public key (PA2 and PB2) and share the public keys with each other. And again, both parties will create commitment transactions to reflect this new state where Alice has transferred one of the BTC to Bob. The problem is that Alice still has the valid commitment transaction from before which is more profitable for her. To invalidate this old state and to prove to Bob that she is committing to this new state where she has paid him, Alice will send Bob her initial temporary private key (dA1). Since Bob now has this key, if Alice ever posts the old state, Bob will be able to spend Alice’s to_local output before she is able to claim it. Bob also sends Alice his old key (dB1) in order to invalidate his old state. He has no reason not to do this since the new state is more profitable to him.\nThat’s it! Alice and Bob can now update their shared channel state and invalidate old states.\n","permalink":"https://www.ellemouton.com/posts/updating-state/","summary":"Day 2 of #7DaysOfBitcoin","title":"LN Things Part 2: Updating State"},{"content":"What is a channel? It is literally just a transaction sending funds to a 2-of-2 multisig transaction. This creates an unspent UTXO and the channel is open until that UTXO is spent (crazy to think that the current state of the LN is just a subset of the current UTXO set). During the lifetime of the channel, a bunch of transactions are created that double spend the funding tx and eventually one of those (and only one. No double spends bro) will go on-chain and the channel will be closed. Ideally you only see these two on-chain transactions: one to open the channel and one to close it.\nCreating a channel: To create a channel we need to somehow get this initial funding channel on-chain. How this is done can be gleaned from BOLT2 but I will go through my understanding of it here. The following screenshot is from the bolt and shows the various messages sent between two nodes during channel creation. I will go through each of these.\nSince commitment transactions are part of the update layer (and ie will be analysed in a future post) I wont get into those details now but the important thing to know is that once a funding transaction is established and confirmed, commitment transactions are used to define the state that the channel is in (how the funds are distributed between the participants in the channel). So each commitment transaction pretty much just spends the funding transaction (uses the funding tx as its input) and then has outputs that define the division of funds between the participants.\nThe funding transaction for a channel between Alice and Bob is simply a transaction that has an output of the following form:\n2 \u0026lt;pubkeyA\u0026gt; \u0026lt;pubkeyB\u0026gt; 2 OP_CHECKMULTISIG Where \u0026lt;pubkeyA\u0026gt; is the Alice’s public key and \u0026lt;pubkeyB\u0026gt; Bob’s. Currently in the Lightning Network a channel is always funded by one side. So in our example lets say that Alice wants to open, and hence fund, the channel. The question is: how does she do this? Can she simply just send funds to the above script? No she cant because there is a chance that Bob might disappear and never be around to sign any transaction that attempts to spend from the funding transaction and this would mean that Alice’s funds would be stuck in this UTXO forever. Let’s go through each of the messages shown in the above diagram to see how it is done then.\nopen_channel: Alice sends this message to Bob to indicate that she wants to open a channel with him. This message includes various details regrading Alice’s requirements of the channel but the important one is the funding_pubkey. This is the public key that Alice intends to use as her public key in the funding transaction script.\naccept_channel: If Bob is happy with the terms that Alice has put forward in her channel offer, then he can send back the accept_channel message which also contains some of his requirements along with the funding_pubkey that he intends to use.\nAt this point, Alice has all that she needs to construct the funding transaction. However, she at this moment still does not broadcast the funding transaction because she still has no guarantee that Bob will not disappear. So what she needs is a commitment transaction signed by Bob that spends from the funding transaction and divides the channel balance accordingly. It could be the case that the initial division of funds allocates some funds to Bob too and so Bob would also want a valid commitment transaction that he can broadcast in case Alice disappears (the concept of asymmetric commitment transactions will be discussed in detail in a future post. For now, just know that both sides have a commitment transaction) . What Alice does now is construct the funding transaction (using Segwit inputs only so that the TXID of the transaction can not be changed due to script sig field malleation) but she does not broadcast the transaction. She sends bob the following message:\nfunding_created: This message contains the TXID of the funding transaction, the relevant output index of the funding transaction along with a signature for Bob’s commitment transaction (if Bob is following the rule then Alice is able construct the exact commitment transaction that he is holding and is thus able to provide her signature for it). Note that Bob cannot yet do anything with his commitment transaction since it is spending from a transaction that is not on the blockchain yet.\nfunding_signed: If Bob is happy then he can send Alice a funding_signed message.\nThis message will contain a Bob’s signature for Alice’s commitment transaction.\nAt this point, Alice now has a valid commitment transaction signed by Bob that spends from the funding transaction that sends her funds back to her. It is thus safe for her to now broadcast the funding transaction.\nchannel_ready: Both parties will be monitoring the blockchain at this point waiting for the funding transaction to be confirmed. Once each party sees it, they will send the other party the channel_ready message which contains the channel ID of the channel.\nThe channel is now open. YEET!\n","permalink":"https://www.ellemouton.com/posts/creating-a-channel/","summary":"Day 1 of #7DaysOfBitcoin","title":"LN Things Part 1: Creating a channel"}]