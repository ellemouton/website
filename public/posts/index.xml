<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on Elle Mouton</title>
    <link>https://www.ellemouton.com/posts/</link>
    <description>Recent content in Posts on Elle Mouton</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 26 Mar 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://www.ellemouton.com/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Lightning Network Onion Routing: Sphinx Packet Construction</title>
      <link>https://www.ellemouton.com/posts/sphinx/</link>
      <pubDate>Tue, 26 Mar 2024 00:00:00 +0000</pubDate>
      
      <guid>https://www.ellemouton.com/posts/sphinx/</guid>
      <description>Diving into all things BOLT-04</description>
      <content:encoded><![CDATA[<p>In the <a href="../../posts/onion-routing-prelims">previous post</a>, we covered <em>what</em> data we need to
communicate to each node on a route. Now we will dive into exactly <em>how</em> we
package up this data so that we leak as little information about the payment as
possible to hops along the path. This is done using the <a href="https://github.com/lightning/bolts/blob/master/04-onion-routing.md">Sphinx</a> packet
construction which ensures a few things:</p>
<ol>
<li>Each hop on the path will only know the previous hop and the next hop on the
path.</li>
<li>Each hop is only able to decrypt the payload that is meant for it.</li>
</ol>
<p>In this article, we will work through exactly how this is done. Before we dive
into the good stuff, however, we first need to cover a few basics.</p>
<h1 id="diffie-hellman-key-exchange">Diffie-Hellman Key Exchange</h1>
<p><a href="https://www.techtarget.com/searchsecurity/definition/Diffie-Hellman-key-exchange">Diffie-Hellman key exchange</a> is a simple way for two private key owning
entities to derive a secret shared key between them. All that the two parties
need to do is exchange public keys.</p>
<p><img loading="lazy" src="/onion/2-dhke.png#center" alt=""  />
</p>
<p>The diagram above aims to show how this can be done between two parties who own
keys <code>A</code> and <code>B</code> respectively. The private keys <code>a</code> and <code>b</code> remain private and
yet the two parties are able to derive a shared secret key. To prove to yourself
that this is indeed a shared secret key, ask yourself if a third party with
private key <code>q</code> and public key <code>Q</code> could derive the shared secret between <code>A</code>
and <code>B</code> if <code>Q</code> had knowledge of both the <code>A</code> and <code>B</code> public keys. You should be
able to see that the answer is no.</p>
<p>In Sphinx packet construction, the onion packet creator, Alice, will use a
shared secret key between a public key that she owns and the public key of each
node on the path in order to encrypt data for the relevant hop.</p>
<p>Once a hop has derived the shared secret with Alice, they can then use that
shared secret along with some constants (<code>rho</code>, <code>mu</code>, <code>pad</code>, <code>um</code> and <code>ammag</code>)
to derive other keys or byte streams:</p>
<p><img loading="lazy" src="/onion/4-key_derivation.png#center" alt=""  />
</p>
<h1 id="ephemeral-keys">Ephemeral Keys</h1>
<p>Each hop on the path will need to be told what the public key of the sender is
so that they can derive the shared secret with the sender and decrypt the
packet. However, sharing the node level public key of the sender, <code>A</code>,  with
each hop is a bit of a privacy leak. Everyone on the path will know just how
much Alice is spending on coffee. To prevent this, Alice will instead use an
ephemeral key with each hop. This means that she will have a new private and
public key pair for each hop on the path and will use that pair to derive the
shared secret with the hop’s public key. After the payment is complete, Alice
can discard this ephemeral key pair.</p>
<p>Naively, Alice could derive a completely new and random key pair for each hop
along the path but that means she would need to persist each private key while
the payment completes, <em>and</em> she would need to include the ephemeral public key
for each hop in the onion packet for that hop. This uses up quite a bit of onion
packet space.</p>
<p>Instead, what she will do is derive a single ephemeral key pair. The private key
of this pair is called the <code>session_key</code>. Alice uses this key to derive all the
other ephemeral keys along the path. What is cool about this is that she only
has to communicate the very first public ephemeral key to the first hop. That
hop will then be able to use that ephemeral key along with its shared secret
with Alice to derive the ephemeral key to pass on to the following hop. This
should become more clear with the long-running example later.</p>
<h1 id="hmac">HMAC</h1>
<p>A <a href="https://en.wikipedia.org/wiki/HMAC">Hash-Based Message Authentication Code (or HMAC)</a> is a message
authentication technique. It is a cryptographic hash function that takes in a
message to produce the code over along with a secret key. The code is only
producible and verifiable by parties that have knowledge of the secret key.</p>
<p>HMACs will be used throughout the sphinx packet construction so that each hop
can verify that the contents of the packet (the message) has not been tampered
with. Since the HMAC can only be derived by the sender, Alice, each HMAC for
each hop must be present in the onion from the beginning. This will become more
clear with the example.</p>
<h1 id="xor">XOR</h1>
<p>The <a href="https://en.wikipedia.org/wiki/XOR_gate">XOR</a> (or Exclusive-OR) operation is a bitwise operation where the
result is 1 if one <em>and only one</em> of the two bits being operated on is 1. In
other words, the result of the XOR operation is only 1 if the two bits being
operated on differ. The XOR truth table can be seen below. It shows the result
(<code>C</code>) after performing the XOR operation on two bits, <code>A</code> and <code>B</code>, for each of
the various combinations.</p>
<p><img loading="lazy" src="/onion/xor-1.png#center" alt=""  />
</p>
<p>The next diagram demonstrates an interesting property of XOR that we will be
making use of in the sphinx packet construction later in this post. It shows
that taking the result of the above operation, <code>C</code>, and XORing it with <code>A</code>
produces <code>B</code>. Similarly, the XOR of <code>C</code> and <code>B</code> produce <code>A</code>.</p>
<p><img loading="lazy" src="/onion/xor-2.png#center" alt=""  />
</p>
<p>To really nail down the idea, let’s look at some examples: In example 1 below,
you can see that if you XOR a packet with itself, it produces a zero byte
array. So XORing something with itself essentially destroys information.
Example 2 shows that if you take a packet and XOR it with a zero byte array of
the same length, then it produces the original packet.</p>
<p><img loading="lazy" src="/onion/xor-3.png#center" alt=""  />
</p>
<p>Ok let’s see some more useful and interesting examples:</p>
<p><img loading="lazy" src="/onion/xor-4.png#center" alt=""  />
</p>
<p>Example 3 shows that if you take a packet and XOR it with a random byte stream,
then you get the encrypted form of the packet. Example 4 shows that if you then
take that encrypted packet and once again XOR it with the <em>same</em> byte stream,
then you are once again left with the clear text. The sphinx packet
construction makes heavy use of XOR for encrypting a clear text packet using a
pseudo random byte stream.</p>
<h1 id="sender-preparation">Sender preparation</h1>
<p>The example used in this post continues where the last post ended off.
Basically we have the following route where Alice is the sender and Dave is the
recipient. Alice essentially just needs to deliver a payload to each hop
without leaking too much data about the route.</p>
<p><img loading="lazy" src="/onion/1-path.png#center" alt=""  />
</p>
<p>Alice has a set of payloads that she wants to communicate to each hop. When the
payloads are put into the onion packet, they are prefixed with a length and
postfixed with a 32 HMAC.</p>
<p><img loading="lazy" src="/onion/5-payloads.png#center" alt=""  />
</p>
<p>Alice now goes ahead and generates a <code>session_key</code> and uses this to derive the
chain of <a href="#ephemeral-keys">ephemeral keys</a>. Note that &ldquo;bf&rdquo; here stands for
&ldquo;blinding factor&rdquo;. A blinding factor is used to tweak a private key or public
key.</p>
<p><img loading="lazy" src="/onion/3-ephemeral_keys.png#center" alt=""  />
</p>
<p>I mentioned before that we don’t want hops on the route to have an idea of where
on the route they are. To achieve this, the onion packet given to each hop will
be the exact same size (1300 bytes) and each hop will only be able to read the
payload meant for it. The rest of the onion will look like a random stream of
bytes to that hop.</p>
<h1 id="first-attempt-at-wrapping-the-onion">First attempt at wrapping the onion.</h1>
<p>We are going to run through the onion wrapping process twice. During the first
pass we will get an initial feel for it and we will see why certain complexities
need to be added on the second pass.</p>
<p>Alice needs to wrap the onion back to front: we first add the payload for Dave,
encrypt that and then add the payload for Charlie and so on. The packet we end
up giving to Bob will be a fully wrapped onion. Each hop will peel one layer of
the onion.</p>
<p>First, Alice generates a 1300 byte pseudo random stream using the session key.
This is knows as the &ldquo;padding&rdquo;.</p>
<p><img loading="lazy" src="/onion/6-padding.png#center" alt=""  />
</p>
<h3 id="wrapping-for-dave">Wrapping for Dave</h3>
<p>She then slides over the padding to make room for Dave’s payload. The HMAC that
is appended to Dave’s payload is not actually a real HMAC. Since Dave is the
last hop, this onion doesn’t need to be passed onto any other hops and so this
HMAC is made to be an empty set of zero bytes which serves as a signal to Dave
that he is the final hop on the route.</p>
<p>The packet needs to remain 1300 bytes long and so that trailing section of the
padding is chopped off.</p>
<p><img loading="lazy" src="/onion/7-wrap_dave_1.png#center" alt=""  />
</p>
<p>Alice then uses her shared key with Dave, $ss_{AD}$, along with the <code>rho</code>
constant to derive a pseudo random stream of 1300 bytes. This stream is XOR&rsquo;d
with the onion packet which produces an encrypted packet that only Dave would
be able to decrypt. Alice then uses $ss_{AD}$, the <code>mu</code> constant and the packet
contents at this point to calculate an HMAC for this packet. Dave will later
verify that this HMAC is equal to the HMAC that he produces over the packet when
he receives.</p>
<p><img loading="lazy" src="/onion/8-wrap_dave_2.png#center" alt=""  />
</p>
<h3 id="wrapping-for-charlie">Wrapping for Charlie</h3>
<p>Next, Alice will add Charlie’s payload. Note that his payload will include the
$HMAC_1$ calculated above. Once again, the packet length is kept to 1300 bytes.</p>
<p><img loading="lazy" src="/onion/9-wrap_charlie_1.png#center" alt=""  />
</p>
<p>Similarly to the encryption for Dave, Alice now uses her shared secret with
Charlie, $ss_{AC}$ to derive a pseudo random byte stream which she XORs with
the onion packet. This produces the encrypted packet destined for Charlie. Once
again, Alice calculates an appropriate HMAC for this payload.</p>
<h3 id="wrapping-for-bob">Wrapping for Bob</h3>
<p>Ok last layer! Finally, Alice slides Bob’s payload in at the start of the
packet and clips off the rest so that it is still a 1300 byte packet. She then
XORs this with a byte stream derived from her shared secret with Bob, $ss_{AB}$,
and then finally calculates the HMAC for this packet: $HMAC_3$.</p>
<p><img loading="lazy" src="/onion/10-wrap_bob_1.png#center" alt=""  />
</p>
<p>Before sending this packet to Bob, Alice wraps it with some required
information: The packet version byte, Alice’s first ephemeral key $E_{AB}$ and
finally the HMAC ($HMAC_3$) for the final onion packet.</p>
<p><img loading="lazy" src="/onion/11-final_onion.png#center" alt=""  />
</p>
<p>Alice now hands this packet to Bob.</p>
<h1 id="peeling-the-onion">Peeling the Onion</h1>
<h3 id="bob-peels-a-layer">Bob peels a layer</h3>
<p>The first thing that Bob will do is to derive the shared key between him and
Alice using the ephemeral key, $E_{AB}$. While he is at it, he can also already
compute the <em>next</em> ephemeral key that he will need to communicate with Charlie.</p>
<p><img loading="lazy" src="/onion/13-bob_keys.png#center" alt=""  />
</p>
<p>Then, Bob needs to validate the HMAC. He does this by using the derived shared
secret with Alice, $ss_{AB}$, along with the <code>mu</code> constant and the onion packet
contents to compute expected HMAC for the payload. The HMAC is valid if it is
equal to the one he received from Alice that was appended to the end of the
packet.</p>
<p><img loading="lazy" src="/onion/12-peel_bob_1.png#center" alt=""  />
</p>
<p>This HMAC should be valid because you can see that the package contents in the
above image is the same as the package contents that Alice used to create this
HMAC.</p>
<p>Great! Now Bob is ready to do some decrypting. Since he was able to derive the
secret key $ss_{AB}$, he is able to derive the same pseudo random byte stream
that Alice used to encrypt his payload. He uses this to XOR the payload which
decrypts it. Oh, but wait! remember that Bob will remove his payload before
passing it on to Charlie… but the packet needs to remain 1300 bytes long, and he
can&rsquo;t just replace the empty space with zero bytes since the next hop will be
able to glean some information about the length of the route and the length of
Bob’s payload by looking at the number of zero bytes. So instead, before
decrypting the payload, Bob first appends 1300 zero bytes to the encrypted
payload, generates  2600 bytes of pseudo random byte stream and only then does
the XOR decryption.</p>
<p><img loading="lazy" src="/onion/14-peel_bob_2.png#center" alt=""  />
</p>
<p>Now that the decryption is complete, Bob removes his payload and chops up the
packet to once again be 1300 bytes:</p>
<p><img loading="lazy" src="/onion/15-charlie_onion.png#center" alt=""  />
</p>
<p>As Alice did for Bob, Bob now packages the onion nicely for Charlie by adding
the Ephemeral key that Charlie will need along with the $HMAC_2$ that Alice
provided Bob with in his payload.</p>
<p><img loading="lazy" src="/onion/15-onion_for_charlie.png#center" alt=""  />
</p>
<p>You may have already picked up an issue here… take a moment here to see if you
can spot the issue. It will become more clear when we dive into Charlie’s
verification process in the next step. For now, let’s assume Bob hands this over
to Charlie.</p>
<h3 id="charlie-peels-a-layer">Charlie peels a layer</h3>
<p>Charlie receives the packaged onion from Bob. The first thing is does is to use
the ephemeral key $E_{AC}$ along with his own private key, <code>c</code>, to derive the
shared secret between him and Alice. He then uses this to derive the ephemeral
key for Dave too.</p>
<p><img loading="lazy" src="/onion/17-charlie_keys.png#center" alt=""  />
</p>
<p>Then, he checks to see if the HMAC is valid given the payload. Ok this is where
the issue lies! If you scroll back to see the diagram showing the message that
Alice used to create this HMAC, you will see that the packet looked different.
But now we at least know what the packet <em>should</em> look like when Alice
calculates the HMAC for Charlie.</p>
<p><img loading="lazy" src="/onion/16-peel_charlie_1.png#center" alt=""  />
</p>
<p>For the sake of completion <em>and</em> so we can find out where else things might
have gone wrong, let’s assume that Charlie continues the process.</p>
<p>Charlie uses the shared secret key to decrypt the packet similarly to how Bob
did it. He then can read his payload and reconstruct the packet for Dave.</p>
<p><img loading="lazy" src="/onion/18-peel_charlie_2.png#center" alt=""  />
</p>
<h3 id="dave-peels-a-layer">Dave peels a layer</h3>
<p>Dave receives the packet and derives his shared secret key with Alice:</p>
<p><img loading="lazy" src="/onion/20-dave_keys.png#center" alt=""  />
</p>
<p>He then attempts to do the HMAC verification. Once again, this will fail since
the packet contents does not match the packet contents that Alice used when
creating the HMAC. But again, we now know what it should look like, and we will
use this information on our second attempt.</p>
<p><img loading="lazy" src="/onion/19-peel_dave_1.png#center" alt=""  />
</p>
<p>Let&rsquo;s again assume that Dave continues and uses the shared secret to decrypt the
packet.</p>
<p><img loading="lazy" src="/onion/21-peel_dave_2.png#center" alt=""  />
</p>
<p>Dave will see that the HMAC sent to him is a zero byte array. He therefore knows
that he is the last hop on the path.</p>
<h1 id="second-attempt-at-wrapping-the-onion">Second attempt at wrapping the onion.</h1>
<p>Ok so we’ve made some mistakes, but we have also learned some lessons. Now
that we know what each packet needs to look like at the time of computing the
HMACs, we can redo the onion wrapping process correctly.</p>
<p>Let’s start by taking a look at the packet at the point Dave gets it (before
decryption):</p>
<p><img loading="lazy" src="/onion/22-filler_1.png#center" alt=""  />
</p>
<p>The difference between this packet and the one we originally used to create the
HMAC is the end bit shown in the diagram above. Luckily we have kept track of
which pseudo random byte streams and which sections of those byte streams are
involved here. So all Alice needs to do at the start is to construct this
section which is called the “filler”. The diagram below shows its construction:</p>
<p><img loading="lazy" src="/onion/23-filler_2.png#center" alt=""  />
</p>
<p>Ok cool! Let’s try this again shall we?</p>
<h3 id="wrapping-for-dave-1">Wrapping for Dave</h3>
<p>The initial padding generation remains the same:</p>
<p><img loading="lazy" src="/onion/24-padding.png#center" alt=""  />
</p>
<p>Again we slide in Dave’s payload and encrypt it:</p>
<p><img loading="lazy" src="/onion/24-wrap_dave.png#center" alt=""  />
</p>
<p>Here is where things change! We know that before Alice uses Dave’s payload to
compute the HMAC, she must first insert the filler.</p>
<p><img loading="lazy" src="/onion/25-wrap_dave_2.png#center" alt=""  />
</p>
<p>Great! Now the HMAC that Charlie ends up receiving will in fact be valid for the
payload he gets.</p>
<h3 id="wrapping-for-charlie-1">Wrapping for Charlie</h3>
<p>Alice then again slides in Charlie’s payload, encrypts it and then… do we need
to cut out some bytes and replace them with a derived filler again? Well… no,
it doesn’t seem that we do! Due to the properties of XOR, XORing the packets
existing filler contents with the byte stream that Charlie uses to decrypt the
payload, the resulting packet <em>is</em> actually equal to the packet that Charlie
will receive! Therefore, nothing special needs to be done at this point. Alice
can go ahead and calculate the HMAC as is.</p>
<p><img loading="lazy" src="/onion/26-wrap_charlie_1.png#center" alt=""  />
</p>
<h3 id="wrapping-for-bob-1">Wrapping for Bob</h3>
<p>Finally, Alice adds Bob’s payload, encrypts the packet and computes the final
HMAC.</p>
<p><img loading="lazy" src="/onion/27-wrap_bob.png#center" alt=""  />
</p>
<p>Notice that this final onion packet is identical to the one that we had at the
end of the first pass we did (except of course that the HMACs are all correct
now) and so the peeling of this packet will look exactly like the peeling of the
first pass packet.</p>
<h1 id="errors">Errors</h1>
<p>Compared to what we have already covered, understanding how errors are dealt
with should be a breeze :)</p>
<p>Let’s assume that when Charlie decodes the payload in the onion sent from Alice,
he realises that she is asking him to forward an amount that would mean that he
does not get the fee that he has advertised. Charlie will then want to fail the
payment and so instead of passing the onion on to Dave, he instead constructs a
failure message packet which will contain a message he wishes to send back to
Alice telling her what went wrong. He may choose to pad this message too. He
will use the shared secret he has with Alice, $ss_{AC}$ along with the <code>um</code>
constant to produce an HMAC over the data. He will then use $ss_{AC}$ along with
the <code>ammag</code> constant to produce a pseudo random bytes stream which he will then
XOR with the failure message packet. He will then put this encrypted message in
an <code>update_fail_htlc</code> message and send that back to Bob.</p>
<p><img loading="lazy" src="/onion/errors-1.png#center" alt=""  />
</p>
<p>Bob will simply take his shared secret with Alice, $ss_{AB}$, produce another
byte stream and re-encrypt the payload as is. He, too, will put this into an
<code>update_fail_htlc</code> message and send it back to Alice.</p>
<p><img loading="lazy" src="/onion/errors-2.png#center" alt=""  />
</p>
<p>When Alice receives this message, she does not immediately know which hop
produced the payload, but she does know in which order things would have been
encrypted. So she starts decrypting by un-peeling Bob’s encryption layer. Once
decrypted, she looks at the first 32 bytes of the payload (the size of an HMAC),
computes the HMAC for the rest of the payload and checks if those two HMACs are
equal. In this case, they will not be which means that Bob was not the erring
node.</p>
<p><img loading="lazy" src="/onion/errors-3.png#center" alt=""  />
</p>
<p>She then continues by peeling back Charlie’s encryption layer and then repeats
the process of checking the HMAC. In this case, the HMACs will be equal and so
Alice knows that Charlie is the source of the error, and so she can now read his
erring reason from the failure message.</p>
<p><img loading="lazy" src="/onion/errors-4.png#center" alt=""  />
</p>
<h3 id="one-little-edge-case">One little edge case</h3>
<p>One edge case to be aware of is where Charlie gets the onion packet from Bob but
then is not able to successfully parse it. If Charlie cannot parse it, then he
won’t know the ephemeral key to use to derive the shared secret with Alice. This
means that he would not be able to encrypt a failure message packet. So in this
case, Charlie will send Bob an <code>update_fail_malformed_htlc</code> message with some
information about the type of error that occurred. When Bob receives this, he
knows that he must do the initial encryption round for this error. He does this
and then sends the packet back to Alice in an <code>update_fail_htlc</code> message.</p>
<h1 id="conclusion">Conclusion</h1>
<p>Well if you are still here - congrats! You now understand the complexities
creating a Sphinx onion packet!</p>
<p>As always, if you think anything needs clarification or if you have any
questions - leave a comment below. If there are corrections that you think
should be made to the text, feel free to let me know or to open a pull request
on the <a href="https://github.com/ellemouton/website">website’s GitHub page</a>.</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Lightning Network Onion Routing: Preliminaries</title>
      <link>https://www.ellemouton.com/posts/onion-routing-prelims/</link>
      <pubDate>Mon, 25 Mar 2024 00:00:00 +0000</pubDate>
      
      <guid>https://www.ellemouton.com/posts/onion-routing-prelims/</guid>
      <description>This post covers the basics of choosing a path and packaging information for each hop on the path</description>
      <content:encoded><![CDATA[<h1 id="overview">Overview</h1>
<p>In this post will cover the preliminaries you need to be aware of for
pathfinding, and it also sets the scene for Sphinx packet construction which
will be covered in a <a href="../../posts/sphinx">follow-up post</a>. Specifically, we answer some
basic questions such as: &ldquo;For a node making a payment, how do I find a path to
the destination node? And how do I communicate to each node on the path what it
should do?&rdquo;</p>
<p>By the end of this post, you should understand what information the sender
needs in order to construct a path, what information it must communicate to each
node on that path and how it passes that information on to each node. For this
last point, this post covers an initial naive approach that will set you up for
understanding why Sphinx packet construction is necessary.</p>
<p>As per usual, I&rsquo;ll use a long-running example throughout the post.</p>
<h1 id="setting-the-scene">Setting the scene</h1>
<p>Meet Alice and Dave (don’t stress, Bob will appear later but today is Dave’s
time to shine) they are two nodes on the Lightning Network.</p>
<p><img loading="lazy" src="/onion_prelims/1-alice-and-dave.png#center" alt=""  />
</p>
<p>Alice wants to pay Dave for a coffee and so Dave generates an invoice and shows
it to Alice using a QR code.</p>
<p><img loading="lazy" src="/onion_prelims/2-invoice.png#center" alt=""  />
</p>
<p>As you can see, the invoice has some useful information:</p>
<ul>
<li><code>amount</code>: the number of milli-satoshis that Dave expects to receive before
giving Alice the coffee.</li>
<li><code>payment_hash</code>: this is the hash that will be used in the HTLC transactions.</li>
<li><code>memo</code>: a nice little human-readable description of what the payment is for.</li>
<li><code>payee_pub_key</code>: this is Dave’s public key that would have been announced in
his <code>node_announcement</code>.</li>
<li><code>min_final_cltv_expiry_delta</code>: This defines the amount of time (or number of
blocks rather) that Dave wants to safety be able to claim the HTLC for this
payment before it times out. This will become more clear later on.</li>
</ul>
<h1 id="finding-a-path">Finding a path</h1>
<p>With invoice in hand, Alice is one step closer to paying Dave. The
<code>payee_pub_key</code> in the invoice tells Alice where to find Dave in the network.
<a href="../../posts/open_channel_pre_taproot">Remember</a> that Alice will have collected a range of node and
channel announcements in order to construct a local graph of the network so now
all she has to do is find Dave in that network and then find paths (via
channels) that lead to Dave’s node.</p>
<p><img loading="lazy" src="/onion_prelims/3-graph.png#center" alt=""  />
</p>
<p>The diagram above shows Alice’s view of the network along with Dave’s position
within the network. Apart from the node and channel announcements that Alice
has received, she would also have received <code>channel_update</code> messages from all
these nodes for each of the channels that they own. The <code>channel_update</code>
messages contain information about the relay policy that that node will enforce
if other nodes wish to route payments over its channel. Each <code>channel_update</code>
contains the following info:</p>
<ul>
<li><code>channel_ID</code>: This identifies the channel that the update is referring to.</li>
<li><code>fee_base_msat</code>: This is the fee (in milli-satoshis) that the node will
charge for routing any payment regardless of the size of the payment.</li>
<li><code>fee_proportional_millionths</code>: Also known as the “fee rate”, this is the
number of satoshis that will be charged for every million satoshis routed
across that channel.</li>
<li><code>cltv_expiry_delta</code>: This is the delta between the incoming HTLC’s CLTV and
outgoing HTLC’s CLTV that the node requires (more on this later).</li>
</ul>
<p>Here is the updated version of Alice’s graph view showing the <code>channel_update</code>
information she has about each channel in her graph.</p>
<p><img loading="lazy" src="/onion_prelims/4-chan-updates.png#center" alt=""  />
</p>
<p>If we narrow down on the current goal which is to pay Dave, we can simplify this
diagram quite a bit to only show the relevant data. We only care about the
channels that are on a potential path between Alice and Dave and we only care
about the <code>channel_update</code> from nodes where we will potentially be sending
across their channel in the outbound direction. For example: Both Bob and
Charlie have advertised <code>channel_updates</code> referring to channel <code>BC</code>, but
because Alice only cares about the direction from Bob to Charlie, she only
needs to look at the information from Bob&rsquo;s <code>channel_update</code> for the channel
since it always refers to the outgoing direction.</p>
<p><img loading="lazy" src="/onion_prelims/5-path-choices.png#center" alt=""  />
</p>
<p>The above diagram shows the two potential paths from Alice to Dave:</p>
<pre tabindex="0"><code>1. Alice -&gt; Bob -&gt; Charlie -&gt; Dave via channels AB, BC and CD
2. Alice -&gt; Eve -&gt; Charlie -&gt; Dave via channels AE, EC and CD
</code></pre><p>If Alice is smart, she will pick the path which will cost her the least amount
of fees. Let’s do some calculations to determine which one would be more
cost-effective for her.</p>
<h3 id="path-1">Path 1</h3>
<p>To work out the total fees for a path, we have to work backwards from the
destination.</p>
<ul>
<li>We know that Dave should be paid 4999999 msats (he said so in his invoice)
which means that this is the number of sats that will be routed through
Charlie. So the amount of fees to pay to Charlie can be calculated as follows:</li>
</ul>
<pre tabindex="0"><code> = Charlie’s Base Fee + Charlie’s proportional fee in parts per million/1000000 * (The amount routed through Charlie)
 = 100 + 1000/1000000(4999999)  
 = 100 + 4999999000/1000000
 = 100 + 4999.999
 = 5099.99
 ~ 5100
</code></pre><p>So the total number of sats that should be sent to Charlie is:</p>
<pre tabindex="0"><code> = 4999999 + 5100 = 5005099 
 = 5005099 msats
</code></pre><ul>
<li>5005099 msats need to be routed through Bob, so the fee we would need to pay
to Bob is:</li>
</ul>
<pre tabindex="0"><code> = 200 + 2000/1000000(5005099)
 = 200 + 2/1000(5005099)
 = 10211
</code></pre><p>So the total number of sats to send to Bob is:</p>
<pre tabindex="0"><code> = 5005099 + 10211
 = 5015310
</code></pre><p>This means that Alice will pay the following amount in fees for the payment:</p>
<pre tabindex="0"><code> = 5015310 - 4999999 
 = 15311 msats
</code></pre><h3 id="path-2">Path 2</h3>
<p>Alice will do the same type of calculation for the path 2.</p>
<ul>
<li>Charlie’s step will be the same: He must be paid a total of 5005099 msats.</li>
<li>Then we work out what we would need to pay Eve:</li>
</ul>
<pre tabindex="0"><code>  = 300 + 3000/1000000(5005099)
  = 300 + 3/1000(5005099)
  = 15316 msats
</code></pre><p>So the total number of sats to send to Eve is:</p>
<pre tabindex="0"><code>  = 5005099 + 15316
  = 5020415 msats
</code></pre><p>Ie, the total that Alice will pay in fees is:</p>
<pre tabindex="0"><code>5020415-4999999 = 20416 msats
</code></pre><p>Aaaand the winner is: Path 1! Now we only need care about the following info:</p>
<p><img loading="lazy" src="/onion_prelims/6-path1.png#center" alt=""  />
</p>
<h1 id="hop-payloads">Hop Payloads</h1>
<p>Alice now has enough information to know what she wants to communicate to each
hop along the path.</p>
<p><img loading="lazy" src="/onion_prelims/7-last-hop-info.png#center" alt=""  />
</p>
<p>Alice wants Dave to receive an <code>update_add_htlc</code> from Charlie on the <code>CD</code>
channel. The <code>payment_hash</code> should match the one specified in the invoice
received from Dave. The <code>amount_msat</code> will be 4999999 as specified in the
invoice. Alice then also checks the current block height (height 1001) and uses
that along with the <code>min_final_cltv_expiry_delta</code>(9)  in the invoice to
calculate that the outgoing CLTV value on the HTLC should be 1010.</p>
<p>Using the fee calculation we did earlier for this path, Alice can also determine
what the <code>update_add_htlc</code>s should look like for the Bob-to-Charlie and
Alice-to-Bob steps. If the fact that the CLTVs for each HTLC increases from
right to left is confusing, check out <a href="#a-note-on-cltv-deltas">this</a> quick CLTV
delta explainer.</p>
<p><img loading="lazy" src="/onion_prelims/8-other-hop-info.png#center" alt=""  />
</p>
<p>The only part of the puzzle that is missing here is: How does Alice tell
Charlie what to forward to Dave if she is only connected to Bob? This is where
the <code>onion_routing_packet</code> field in <code>update_add_htlc</code> comes in. Alice packages
up what she wants to tell each node and essentially then wraps it with the
payload for the previous node. The diagram below should make this more clear:</p>
<p><img loading="lazy" src="/onion_prelims/9-onion-info.png#center" alt=""  />
</p>
<p>So Bob gets the information for him from Alice but also a packet that he should
forward to Charlie. Charlie gets this packet and reads the data meant for him
and sees that there is also a payload that he should forward on to Dave. Dave
gets his payload and sees that he is the final node in the path. At this point,
Dave will check if he has the pre-image for the incoming payment hash. Note that
this is where the idea of the &ldquo;onion&rdquo; comes in: each hop gets a packet that they
must &ldquo;peel&rdquo; like an onion.</p>
<h1 id="naive-onion-packet-construction">Naive Onion Packet Construction</h1>
<p>Let’s take a moment to imagine what the actual onion packets will look like.
Heads up here that this is <em>not</em> the final construction. I will build up a
possible structure here, and then I will explain why this is not the way things
actually look. The details of how this is actually done will be covered in the
<a href="../../posts/sphinx">next post</a>.</p>
<p>Ok so Alice knows what she wants to tell each of the hops. This is called the
“hop payload”. She puts together the following packet for Bob:</p>
<p><img loading="lazy" src="/onion_prelims/10-naive-bob-pkt.png#center" alt=""  />
</p>
<p>The packet has the following components:</p>
<ul>
<li>1 byte packet version byte</li>
<li>Alice’s public key</li>
<li>The payloads for each hop. Note that each payload also has an HMAC which that
hop will need to pass the packet on to the next hop (this will be more clear
in a moment).</li>
<li>Finally, an HMAC produced by Alice using her key over the packet’s hop
payloads.</li>
</ul>
<p>(What is an HMAC? I&rsquo;ll explain this better in the next post but for now, just
think of it as a digital signature used to verify the integrity of a payload)</p>
<p>Bob will receive this packet and will do the following:</p>
<ol>
<li>He will check that the HMAC is valid (in other words he checks that the
packet has not been tampered with).</li>
<li>He will read the payload meant for him along with the HMAC.</li>
<li>He will reconstruct the packet that should be passed on to Charlie. He will
append the HMAC given to him by Alice for this packet since he cannot produce
this HMAC himself.</li>
</ol>
<p><img loading="lazy" src="/onion_prelims/11-naive-charlie-pkt.png#center" alt=""  />
</p>
<p>Charlie will receive this packet and do the following:</p>
<ol>
<li>He will check that the HMAC is valid.</li>
<li>He will read the payload meant for him along with the HMAC</li>
<li>He will reconstruct the packet that should be passed on to Dave:</li>
</ol>
<p><img loading="lazy" src="/onion_prelims/12-naive-dave-pkt.png#center" alt=""  />
</p>
<p>Dave will receive this packet and do the following:</p>
<ol>
<li>He will check that the HMAC is valid.</li>
<li>He will read the payload meant for him along with the HMAC.</li>
<li>The HMAC he receives will be an empty byte array. This indicates to Dave that
he is the final hop.</li>
</ol>
<p>Ok so what are some issues with this construction?</p>
<ul>
<li>Each hop can read the payload for each hop that follows. This leaks who the
receiver is.</li>
<li>Each hop is told Alice’s public key, and so they all know who is sending to
the receiver.</li>
<li>Even if the individual payloads were encrypted, the packet gets smaller and
smaller further along the path and so intermediary nodes would be able to
guess how far they are away from the final hop based on the packet length.</li>
</ul>
<p>In other words: privacy = bad. We can’t have that. Enter Sphinx packet
construction! With Sphinx packet construction:</p>
<ul>
<li>Each payload is encrypted so that it can only be decrypted by the node it was
meant for.</li>
<li>The sender does not share their real public key but instead use a different
ephemeral key for each hop.</li>
<li>The packet size remains constant at each hop.</li>
</ul>
<p>I’ll see you in the next post for all the details on this!</p>
<h1 id="a-note-on-cltv-deltas">A note on CLTV Deltas</h1>
<p>To understand why nodes advertise a CLTV delta and how this is used by the
sender of a payment to determine which CLTV to communicate to each hop, let’s
take a step back and just look at the structure of an HTLC:</p>
<p><img loading="lazy" src="/onion_prelims/ctlv_delta_1.png#center" alt=""  />
</p>
<p>The diagram above shows the HTLC between Charlie and Dave (the last node on the
path). An HTLC has two possible spending paths: The pre-image path which will
pay the funds to Dave if he is able to produce the pre-image corresponding to
the payment hash. The other path is the timeout path which will pay the funds
back to Charlie. This timeout path is only spendable after the block height
defined by <code>CLTV A</code>. Let’s assume that the current block height is 1001. If
<code>CLTV A</code> is 1002, then there is a real chance that just as Dave is about to
reveal the pre-image to Charlie, block 1002 gets mined and Charlie quickly goes
ahead and broadcasts the transaction and spends the timeout path before Dave is
able to sweep the pre-image path. To prevent this race, Dave will want some time
where he can confidently spend the pre-image path if he needs to before the
timelock path becomes spendable. He communicates his desired buffer, 9 blocks,<br>
using the <code>min_final_cltv_expiry_delta</code> field of the invoice that he sends to
Alice. Alice then knows that if she were to send the payment right now while
the block height is 1001, that Dave will fail any incoming HTLC with a <code>CLTV A</code>
smaller than 1010 (1001 + 9).</p>
<p>Now, let’s zoom out a bit more and include the HTLC between Bob and Charlie. We
want to now figure out what an appropriate value would be for the CLTV on the
HTLC between Bob and Charlie, <code>CLTV B</code>.</p>
<p><img loading="lazy" src="/onion_prelims/cltv_delta_2.png#center" alt=""  />
</p>
<p>Let’s assume that Dave waits until the very last minute to reveal the pre-image
to Charlie. In other words, he waits until just before block 1010 is mined.
Charlie now needs to turn around and present this pre-image to Bob. In the case
that Bob goes on-chain with the HTLC, Charlie requires some time where he can
spend the pre-image path without worrying about Bob being able to spend the
timeout path. This buffer that Charlie requires between receiving the pre-image
from Dave and being able to spend the pre-image path safely from the HTLC with
Bob is Charlie’s CLTV delta. He will advertise this value in his
<code>channel_update</code> and he expects Alice to use that value when constructing her
payment path. If a payment comes through to Bob and the difference between
<code>CLTV_B</code> and <code>CLTV_A</code> value  is less than the delta that he advertised, he will
fail the payment. He requires that <code>CLTV_B</code> be equal to at least <code>CLTV_A</code> plus
his advertised CLTV delta.</p>
<h1 id="bonus-section-hop-hints">Bonus Section: Hop Hints</h1>
<p>This post is a good place to quickly cover what you need to know about hop
hints and how they affect the process of path finding.</p>
<p>If we go back to the image of Alice’s view of the graph based on the
<code>channel_announcement</code>s that she has received, there is a chance that Alice
actually doesn’t know about the channel between Charlie and Dave (Channel
<code>CD</code>). This is because it might be a private channel that Charlie and Dave
chose not to announce to the network.</p>
<p><img loading="lazy" src="/onion_prelims/13-graph-private-hop.png#center" alt=""  />
</p>
<p>In this case, Alice will not be able to find a path to Dave’s node unless he
provides her with more information in the invoice he sends her. The extra
information that Dave may provide is made up of one or more “Hop Hints”. These
hints need to make up for any information that Alice would have received from a
<code>channel_announcement</code> and <code>channel_update</code> for the channel. This information
includes Charlie’s public key, the SCID of the channel and then all the routing
policy rules for the channel.</p>
<p><img loading="lazy" src="/onion_prelims/14-invoice-hop-hint.png#center" alt=""  />
</p>
<p>The rest of the path finding process is the same :)</p>
<h1 id="conclusion">Conclusion</h1>
<p>Alrighty! I hope things are making a bit more sense now and that you understand
both how a sender goes about finding a path to a destination node along with
what the sender needs to communicate to each node on the path. In the
<a href="../../posts/sphinx">next post</a> we will take a deep dive into exactly how the onion packet
carrying the hop payloads is constructed to maintain maximum privacy.</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Normal operation and closure of a pre-taproot LN channel</title>
      <link>https://www.ellemouton.com/posts/normal-operation-pre-taproot/</link>
      <pubDate>Wed, 14 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://www.ellemouton.com/posts/normal-operation-pre-taproot/</guid>
      <description>A deep-dive into the normal operation and closure of a pre-taproot Lightning Network channel</description>
      <content:encoded><![CDATA[<p>I’ve <a href="../../posts/open_channel_pre_taproot">previously written</a> in depth about how Lightning channels
are opened, but I’ve never gone into the details of the normal operations and
closures of channels. Since I promised in my <a href="../../posts/taproot-chan-txs">previous post</a> about
Taproot channel transactions that I would write a follow-up explaining how all
the channel messages need to be updated in order to support the new MuSig2
signing required by Taproot channels, I think now is the time to finally dive
into the normal channel operations and closures so that the follow-up post on
how Taproot channels affect these operations is easier to parse.</p>
<h1 id="overview">Overview</h1>
<p>In this blog post, I will talk about the normal operations of a channel. This
involves understanding how HTLCs are added to a channel and how channel peers
commit to a new state including these HTLCs. Then I will cover how a channel’s
normal flow is re-established after a disconnection and finally, the cooperative
channel closure flow will be covered. All of these topics are covered in
<a href="https://github.com/lightning/bolts/blob/master/02-peer-protocol.md">Bolt 2</a>, but I thought a diagram or two could help with understanding.
I plan on doing all of this with a long-running example.</p>
<h1 id="preliminaries">Preliminaries</h1>
<p>Here are a few links that cover some preliminaries that might be useful for
understanding this blog post:</p>
<ul>
<li>Why channel peers have an asymmetric state and how they go about updating this
state in a trust-less way: <a href="../../posts/updating-state">Updating State</a>.</li>
<li>What HTLC outputs look like on a commitment transaction: <a href="../../posts/htlc-deep-dive">HTLC
deep-dive</a>.</li>
<li>How two nodes go about opening a channel: <a href="../../posts/open_channel_pre_taproot">Opening and announcing a
pre-taproot LN channel</a>.</li>
</ul>
<h1 id="normal-channel-operation">Normal Channel Operation</h1>
<h2 id="setting-the-scene">Setting the scene</h2>
<p>Alice and Bob (hello old friends!) have successfully opened their channel. They
have both seen that the funding transaction has confirmed, and they have
exchanged the <code>channel_ready</code> message with each other to indicate that they are
ready to use the channel. The state of their asymmetric commitment transactions
currently look as follows:</p>
<p><img loading="lazy" src="/normalChanOp/1-initial.png#center" alt=""  />
</p>
<p>Both commitment transactions spend the 2-of-2 multi-sig funding transaction
output. Spending from this output requires a signature from both parties. The
signatures are represented by the two boxes at the top of the commitment
transactions. You can see from the diagram that Alice’s commitment transaction
has a signature from Bob represented by the blue box (say it with me: “Bob is
blue!”) and Bob has a signature from Alice for his commitment transaction
represented by the green box (“Alice is green” doesn’t have quite the same ring
to it). Each commitment transaction also has the <code>to_local</code> and <code>to_remote</code>
outputs which pay the respective parties their current channel balance. Both
Alice and Bob have the ability to sign their own commitment transaction at any
time and broadcast it to the Bitcoin network. This would be a force close.</p>
<p>For the sake of making the next few diagrams in this article a bit simpler, I
am going to ignore the funding transaction along with the <code>to_local</code> and
<code>to_remote</code> outputs for a while since our initial focus is going to be on adding
and removing HTLC outputs. So the above diagram can instead be represented as
follows:</p>
<p><img loading="lazy" src="/normalChanOp/2-simplified.png#center" alt=""  />
</p>
<p>A red coloured commitment transaction, as shown below, represents past, revoked
commitment transactions. If Alice or Bob were to sign and broadcast one of their
older revoked commitment transactions then the other side would be able to sweep
all their funds. So these revoked transactions can effectively be considered
invalid. The yellow commitment transactions represent the latest, valid set of
commitment transactions. These are the commitment transactions that would be
broadcast in a force close. Then finally, each side has what can be thought of
as a “staging area” where changes to the commitment transaction can be proposed.
Later on, either side can decide when it wants its counterparty to commit to the
changes in their staging commitment transaction. For those of you who love a
good analogy - this is very much like a git workflow: past commits are out of
date, but they tell a nice story of what has happened, your latest committed
changes represent the current state of your project and any changes that are not
yet committed are in staging.</p>
<p><img loading="lazy" src="/normalChanOp/3-legend.png#center" alt=""  />
</p>
<h2 id="adding-an-htlc">Adding an HTLC</h2>
<p>When either Alice or Bob want to send a payment across the channel in question
(which would happen if either of them wanted to send a payment themselves or if
they are routing another node’s payment) then they would need to propose the
inclusion of the HTLC to their channel peer. This is done with the
<code>update_add_htlc</code> message:</p>
<p><img loading="lazy" src="/normalChanOp/update_add_htlc.png#center" alt=""  />
</p>
<p>The <code>channel_id</code> is used to communicate which channel this change should take
place on, the <code>id</code> is an always-incrementing identifier for this proposed
change from the sender. The <code>amount_msat</code> is the amount that should be attached
to the HTLC output, the <code>cltv_expiry</code> is the block height that the HTLC should
expire at and finally the <code>onion_routing_packet</code> and optional <code>blinding_point</code>
both contain data that the recipient will use to determine where next to send
the payment.</p>
<p>Something that definitely took me a while to wrap my head around is the fact
that the sender of this message does not put this update in their own staging
area commitment transaction yet. This is because the update is still &ldquo;pending
on the receiver&rdquo; because the sender has not yet received any acknowledgement
from receiver for the new update. This is to allow for the case where one peer
sends an update and then immediately receives a <code>commitment_signed</code> message
(more details on this later). In that case, there should be no ambiguity around
which updates are included in the transaction being signed. Hopefully this makes
more sense as we work through the example.</p>
<h3 id="-step-1-alice---bob-update_add_htlca1">⚙️ Step 1: Alice -&gt; Bob: <code>update_add_htlc(A1)</code></h3>
<p>Ok so let’s say that Alice sends Bob an <code>update_add_htlc</code>. Let’s call this
HTLC <code>A1</code> since it is the first one that Alice (<code>A</code>) is sending to Bob. If Bob
is happy with all the fields in the message, then he adds the HTLC to his
staging area commitment transaction and Alice marks the HTLC as pending on
Bob&rsquo;s side but does not yet add it to her staging commitment transaction:</p>
<p><img loading="lazy" src="/normalChanOp/4-add_a1.png#center" alt=""  />
</p>
<p>Note that neither side has actually committed to this HTLC and so if Bob is a
routing node for this payment, he should not yet send <code>update_add_HTLC</code> to the
next hop in the route until <code>A1</code> has been <em>irrevocably</em> committed. An HTLC
addition or removal is only considered irrevocably committed once both
parties in the channel have committed to the commitment transaction with or
without it respectively.</p>
<p>Something that the more simplified diagram fails to show is that Alice&rsquo;s main
output in Bob&rsquo;s staging commitment transaction (ie, the <code>to_remote</code> output)
will now have the value of the added HTLC subtracted (along with the fees to
cover the extra output). If the HTLC ends up succeeding then this amount will be
added to Bob&rsquo;s output and if it ends up failing, then it will be re-added to
Alice&rsquo;s output.</p>
<h3 id="-step-2-alice---bob-update_add_htlca2">⚙️ Step 2: Alice -&gt; Bob: <code>update_add_htlc(A2)</code></h3>
<p>Even if they have not committed to HTLC <code>A1</code> yet, that does not stop them from
adding more changes to the staging area. So Alice is more than welcome to
propose a new HTLC, <code>A2</code>, to Bob:</p>
<p><img loading="lazy" src="/normalChanOp/5-add_a2.png#center" alt=""  />
</p>
<h3 id="-step-3-bob---alice-update_add_htlcb1">⚙️ Step 3: Bob -&gt; Alice <code>update_add_htlc(B1)</code></h3>
<p>Similarly, Bob can suggest a change <code>B1</code> to Alice:</p>
<p><img loading="lazy" src="/normalChanOp/6-add_b1.png#center" alt=""  />
</p>
<h2 id="committing-to-the-current-state">Committing to the current state</h2>
<p>At some point, one of the peers will want to make sure that the other peer has
committed to the latest set of changes and revoke the previous valid state. This
is done by sending the <code>commitment_signed</code> message:</p>
<p><img loading="lazy" src="/normalChanOp/commitment_signed.png#center" alt=""  />
</p>
<p>The <code>channel_id</code> once again refers to the channel in question. The <code>signature</code>
is the sender&rsquo;s signature for the remote party’s staging area commitment
transaction. <code>num_htlcs</code> refers to the number of HTLCs that the sender expects
to be on the remote commitment transaction and this is then followed by
<code>htlc_signatures</code> which is an array of <code>num_hltcs</code> signatures which are the
sender’s signatures for each of the second-level HTLC transactions that the
remote party would need to broadcast if they were ever to force close the
channel. If you need a reminder about why the second-level HTLC transactions are
needed, give this <a href="../../posts/htlc-deep-dive">post</a> a read.</p>
<h3 id="-step-4-alice---bob-commitment_signed">⚙️ Step 4: Alice -&gt; Bob: <code>commitment_signed</code></h3>
<p>Let’s say that Alice sends this message to Bob. Bob will now have all the
required signatures from Alice to broadcast his staging-area commitment
transaction:</p>
<p><img loading="lazy" src="/normalChanOp/7-commit_sign_1.png#center" alt=""  />
</p>
<p>Notice that Alice knew that her signature would need to cover the <code>A1</code> and <code>A2</code>
HTLCs. This is fine because the <a href="https://github.com/lightning/bolts/blob/master/08-transport.md">underlying transport</a> is guaranteed to
be reliable and ordered meaning that if Bob was to receive Alice&rsquo;s
<code>commitment_signed</code> message then it means that he definitely received her
<code>update_add_htlc</code> messages for <code>A1</code> and <code>A2</code>. Alice and Bob both know that the
signature should not cover the <code>B1</code> HTLC since Alice has not sent an
acknowledgement for it yet.</p>
<p>Another thing to notice is that Bob now actually has two valid commitment
transactions since he has not yet revoked his previous state. He is, however,
incentivised at this point to revoke his previous commitment transaction since
the HTLCs on the new state are either:</p>
<ul>
<li>Payments to Bob himself meaning that he gains from committing to the new
state. If he doesn’t commit to the new state, then Alice won&rsquo;t either and so
there would still exist a version of a commitment transaction that does not
pay Bob his incoming funds.</li>
<li>Similarly to the above point, if Bob is routing a payment, then he is also
incentivised to try to get the HTLC irrevocably committed since he would earn
routing fees if the payment succeeds.</li>
<li>Finally, if Bob is making the payment himself, then the first state would in
fact be more desirable to him since he strictly has less funds in the second
state. However, the merchant that Bob is making the payment to won&rsquo;t release
the goods being purchased unless funds come through which won&rsquo;t happen if
Alice does not pass on the HTLC which she won&rsquo;t do unless it has been
irrevocably committed to. So again, Bob is incentivised to revoke his previous
state.</li>
</ul>
<h3 id="-step-5-bob---alice-revoke_and_ack">⚙️ Step 5: Bob -&gt; Alice: <code>revoke_and_ack</code></h3>
<p>In response to Alice’s <code>commitment_signed</code>, Bob sends the <code>revoke_and_ack</code>
message:</p>
<p><img loading="lazy" src="/normalChanOp/revoke_and_ack.png#center" alt=""  />
</p>
<p>The <code>per_commitment_secret</code> provides Alice with the information she needs in
order to be able to spend any revocation path on Bob’s previously valid state.
See <a href="../../posts/revocation">this</a> post for more details about how revocation works.
The <code>next_per_commitment_point</code> gives Alice the information she needs in order
to derive the revocation public key that will be used in Bob’s next commitment
transaction. Once Alice receives this message, Bob’s previous commitment
transaction has successfully been revoked. Note that this message explicitly
acknowledges the <code>commitment_signed</code> message sent by Alice and by extension,
since messages delivery is reliable and ordered, it also implicitly acknowledges
the <code>update_add_htlc</code> messages that Alice sent for <code>A1</code> and <code>A2</code>. Alice can
therefore finally add <code>A1</code> and <code>A2</code> to her staging area commitment transaction
since they are no longer pending on Bob&rsquo;s side:</p>
<p><img loading="lazy" src="/normalChanOp/8-revoke_1.png#center" alt=""  />
</p>
<p>Let’s clean up the diagram a bit…</p>
<p><img loading="lazy" src="/normalChanOp/9-clean_up_1.png#center" alt=""  />
</p>
<p>That’s better.</p>
<p>From the above diagram, notice that Alice&rsquo;s and Bob’s latest commitment
transactions are actually out of sync. This is fine since none of the updates
have been irrevocably committed yet. That might seem hard to believe since the
commitment transactions look so different so let’s walk through the consequences
of either of these transactions ending up on-chain from the perspective of both
sides.</p>
<ul>
<li>
<p>From Alice’s perspective:</p>
<ul>
<li>if her commitment transaction is broadcast, she gets back her original
<code>to_local</code> amount.</li>
<li>if Bob’s commitment transaction is broadcast, then Alice&rsquo;s offered HTLCs
(such as <code>A1</code> and <code>A2</code>) will be on-chain. For offered HTLCs, Alice is
sending sats <em>out</em> meaning that her <code>to_local</code> would be lower. But, if
Bob was a router node for these HTLCs then he would not have forwarded
them as they are not yet irrevocably committed meaning that he won&rsquo;t
receive the pre-images required to claim these HTLCs and Alice would be
able to get her funds back via the timeout path. If Bob was the recipient
of these HTLCs, then he would be able to produce the pre-image to claim
the HTLCs, but then Alice would see the pre-image on-chain and would be
able to claim the incoming HTLCs from their incoming channel and would
thus have earned routing fees.</li>
</ul>
</li>
<li>
<p>From Bob’s perspective (very similar to the logic for Alice):</p>
<ul>
<li>if Alice’s commitment transaction is broadcast, Bob gets back his funds via
the <code>to_remote</code> output.</li>
<li>If Bob had to force close via his commitment transaction, then HTLCs offered
to him (like <code>A1</code> and <code>A2</code>) would be on-chain, if Bob was routing these,
then he would not have forwarded them on since they are not yet irrevocably
committed. He thus won&rsquo;t be able to claim the success path but that is fine
since the funds for these did not come out of his balance. If Bob was the
final destination for these, then he would be able to claim them via the
success path.</li>
</ul>
</li>
</ul>
<h3 id="-step-6-alice---bob-update_add_htlca3">⚙️ Step 6: Alice -&gt; Bob: <code>update_add_htlc(A3)</code></h3>
<p>I want to really nail down the point that the commitment transactions can remain
out of sync indefinitely and that Bob does not need to send <code>commitment_signed</code>
just because Alice did. So, for the sake of the example, let’s say that Alice at
this point sends yet another HTLC, <code>A3</code>, to Bob:</p>
<p><img loading="lazy" src="/normalChanOp/10-add_a3.png#center" alt=""  />
</p>
<h3 id="-step-7-bob---alice-commitment_signed">⚙️ Step 7: Bob -&gt; Alice: <code>commitment_signed</code></h3>
<p>Bob wants to irrevocably commit some of the HTLCs so that he can forward them
on, so he finally sends Alice a <code>commitment_signed</code> of his own. This will
include his signature for Alice’s staging-area commitment transaction along with
all the signatures required from him for the second-level HTLC outputs.</p>
<p><img loading="lazy" src="/normalChanOp/11-commit_sign_2.png#center" alt=""  />
</p>
<h3 id="-step-8-alice---bob-revoke_and_ack">⚙️ Step 8: Alice -&gt; Bob: <code>revoke_and_ack</code></h3>
<p>Just like Bob did previously, Alice responds to the <code>commitment_signed</code> with
a <code>revoke_and_ack</code> in order to revoke her previous state. This also serves as
an acknowledgement to Bob that Alice has received and committed to <code>B1</code> and so
Bob can now add <code>B1</code> to his staging area commitment transaction.</p>
<p><img loading="lazy" src="/normalChanOp/12-revoke_2.png#center" alt=""  />
</p>
<p>Allow me to clean that up real quick…</p>
<p><img loading="lazy" src="/normalChanOp/13-clean_up_2.png#center" alt=""  />
</p>
<p>Much better.</p>
<p>At last, we have some irrevocably committed HTLCs! <code>A1</code> and <code>A2</code> have
been irrevocably committed. <code>B1</code> and <code>A3</code>, however, have not since they have not
yet been committed to by both parties.</p>
<p>Let&rsquo;s quickly irrevocably commit <code>B1</code> and <code>A3</code>.</p>
<h3 id="-step-8-alice---bob-commitment_signed">⚙️ Step 8: Alice -&gt; Bob: <code>commitment_signed</code></h3>
<p><img loading="lazy" src="/normalChanOp/14-commit_sign_3.png#center" alt=""  />
</p>
<h3 id="-step-9-bob---alice-revoke_and_ack">⚙️ Step 9: Bob -&gt; Alice: <code>revoke_and_ack</code></h3>
<p><img loading="lazy" src="/normalChanOp/15-revoke_3.png#center" alt=""  />
</p>
<h3 id="-step-10-bob---alice-commitment_signed">⚙️ Step 10: Bob -&gt; Alice: <code>commitment_signed</code></h3>
<p><img loading="lazy" src="/normalChanOp/17-commit_sign_4.png#center" alt=""  />
</p>
<h3 id="-step-11-alice---bob-revoke_and_ack">⚙️ Step 11: Alice -&gt; Bob: <code>revoke_and_ack</code></h3>
<p><img loading="lazy" src="/normalChanOp/18-revoke_4.png#center" alt=""  />
</p>
<p>Another clean-up:</p>
<p><img loading="lazy" src="/normalChanOp/19-clean_up_4.png#center" alt=""  />
</p>
<p>Ok cool! Now all the HTLCs have been irrevocably committed.</p>
<h3 id="removing-htlcs">Removing HTLCs</h3>
<p>You probably get the idea of adding HTLCs now. But how about removing them?
HTLCs are removed if a payment succeeds or if it fails. Note that HTLC removal
messages can only be sent by the peer who did not send the original
<code>update_add_htlc</code> and that HTLC’s are only removable once they have been
irrevocably committed to. Luckily for us, all the HTLCs have been irrevocably
committed, and so we can start removing them now.</p>
<h3 id="-step-12-bob---alice-update_fulfill_htlca2">⚙️ Step 12: Bob -&gt; Alice: <code>update_fulfill_htlc(A2)</code></h3>
<p>In the best case scenario, an HTLC is removed because it is being fulfilled
meaning that its pre-image is being passed back. This is done with the
<code>update_fulfilled_htlc</code> message which looks as follows:</p>
<p><img loading="lazy" src="/normalChanOp/update_fulfill_htlc.png#center" alt=""  />
</p>
<p>In our example, Bob sends Alice the <code>update_fulfill_htlc</code> message for HTLC <code>A2</code>.
This also demonstrates that the HTLCs don’t need to be removed in the same order
they were added.</p>
<p><img loading="lazy" src="/normalChanOp/20-fulfill_a2.png#center" alt=""  />
</p>
<p>Notice that just like the updates for adding an HTLC, updates for removing an
HTLC will also initially be pending on the receiver side until they have been
acknowledged by a <code>revoke_and_ack</code>. So in our case, Alice removes <code>A2</code> from her
staging area transaction when she receives the <code>update_fulfill_htlc</code> (and
allocates the HTLC amount to Bob&rsquo;s output) but Bob does not yet remove the HTLC
from his staging area transaction.</p>
<p>Unlike other update messages, there is no need to wait for an HTLC removal to be
irrevocably committed if you receive the pre-image for it. You can immediately
send the pre-image upstream in order to claim any HTLCs there.</p>
<h3 id="-step-13-bob---alice-update_fail_htlca1">⚙️ Step 13: Bob -&gt; Alice: <code>update_fail_htlc(A1)</code></h3>
<p>HTLCs can also be removed due to payment failures such as HTLCs timing out or if
there was some sort of routing failure such as a specific channel on the path
no longer existing, a hop’s fee requirements not being met, a link not having
sufficient balance etc. Such failures are communicated with the
<code>update_fail_htlc</code> message:</p>
<p><img loading="lazy" src="/normalChanOp/update_fail_htlc.png#center" alt=""  />
</p>
<p>The <code>reason</code> field is an encrypted blob for the sender of the payment in order
to inform them of the failure reason.</p>
<p>After Bob sends Alice the <code>update_fail_htlc</code> message for <code>A1</code>, the state looks
as follows:</p>
<p><img loading="lazy" src="/normalChanOp/21-fail_a1.png#center" alt=""  />
</p>
<h3 id="-step-14-bob---alice-update_fail_malformed_htlca3">⚙️ Step 14: Bob -&gt; Alice: <code>update_fail_malformed_htlc(A3)</code></h3>
<p>The final message that can be used to remove an HTLC is the
<code>update_fail_malformed_htlc</code> message:</p>
<p><img loading="lazy" src="/normalChanOp/update_fail_malformed_htlc.png#center" alt=""  />
</p>
<p>This is sent back if any hop was unable to parse the <code>onion_routing_packet</code> it
received in <code>update_add_htlc</code>. If Bob sends Alice this message for <code>A3</code>, then
the state now looks as follows:</p>
<p><img loading="lazy" src="/normalChanOp/22-fail_a3.png#center" alt=""  />
</p>
<h3 id="-step-15-alice---bob-update_fulfill_htlcb1">⚙️ Step 15: Alice -&gt; Bob: <code>update_fulfill_htlc(B1)</code></h3>
<p>Alice also initiates the removal of <code>B1</code> by sending an <code>update_fulfill_htlc</code>
to Bob.</p>
<p><img loading="lazy" src="/normalChanOp/23-fulfill_b1.png#center" alt=""  />
</p>
<p>Let’s now clean-up the HTLC removals by irrevocably committing them. This will
require a few <code>commitment_signed</code>-<code>revoke_and_ack</code> flows:</p>
<h3 id="-step-16-bob--alice-commitment_signed">⚙️ Step 16: Bob-&gt; Alice: <code>commitment_signed</code></h3>
<p><img loading="lazy" src="/normalChanOp/24-commit_sign_5.png#center" alt=""  />
</p>
<h3 id="-step-17-alice---bob-revoke_and_ack">⚙️ Step 17: Alice -&gt; Bob: <code>revoke_and_ack</code></h3>
<p><img loading="lazy" src="/normalChanOp/25-revoke_5.png#center" alt=""  />
</p>
<h3 id="-step-18-alice---bob-commitment_signed">⚙️ Step 18: Alice -&gt; Bob: <code>commitment_signed</code></h3>
<p><img loading="lazy" src="/normalChanOp/26-commit_sig_6.png#center" alt=""  />
</p>
<h3 id="-step-19-bob---alice-revoke_and_ack">⚙️ Step 19: Bob -&gt; Alice: <code>revoke_and_ack</code></h3>
<p><img loading="lazy" src="/normalChanOp/27-revoke_6.png#center" alt=""  />
</p>
<h3 id="-step-20-bob---alice-commitment_signed">⚙️ Step 20: Bob -&gt; Alice: <code>commitment_signed</code></h3>
<p><img loading="lazy" src="/normalChanOp/29-commit_sign_7.png#center" alt=""  />
</p>
<h3 id="-step-21-alice---bob-revoke_and_ack">⚙️ Step 21: Alice -&gt; Bob: <code>revoke_and_ack</code></h3>
<p><img loading="lazy" src="/normalChanOp/30-revoke_7.png#center" alt=""  />
</p>
<p>The two valid states now look nice and clean once again:</p>
<p><img loading="lazy" src="/normalChanOp/31-clean_up_7.png#center" alt=""  />
</p>
<h2 id="updating-fees">Updating fees</h2>
<p>There is one more <code>update_*</code> message that we need to cover and that is
the <code>update_fee</code> message. This message is used to update the fee-rate that the
peers should use when constructing their commitment transactions. The original
fee-rate is decided in the open-channel flow but if the average mempool fee-rate
increases, the channel funder might decide to update the fee of the commitment
transactions so that they have a better chance of getting confirmed in a timely
manner in a force close situation. It could also be that when the channel was
opened, a very high fee-rate was chosen and perhaps a lower fee-rate would be
desired.</p>
<p>This message follows similar rules to other <code>update_*</code> messages in that it must
also be irrevocably committed before it takes effect. The only other extra rule
that applies to this message is that only the channel funder may send this
message.</p>
<p><img loading="lazy" src="/normalChanOp/update_fee.png#center" alt=""  />
</p>
<p>One thing to note is that with anchor channels, the need to use the <code>update_fee</code>
message is becoming less and less since nodes will be able to use CPFP on the
force-close transaction if required.</p>
<h2 id="message-retransmission">Message Retransmission</h2>
<p>Something that you may have picked up on while walking through the add/remove
HTLC flow is that explicit acknowledgements for the <code>update_*</code> messages is
delayed until the <code>commitment_signed</code>/<code>revoke_and_ack</code> exchange. That is ok
most of the time since we assume that the underlying transport between the two
nodes (see <a href="https://github.com/lightning/bolts/blob/master/08-transport.md">Bolt 8</a>) is ordered and reliable. However, if the connection
needs to be re-established for some reason, there will be doubt regarding
whether our peer has received the last message that we sent. This is where the
<code>channel_reestablish</code> message comes in. Upon reconnection, before continuing with
the normal operation flow, the peers will exchange this message to make sure
they are on the same page and to determine which messages they possibly need to
re-send to their peer.</p>
<p><img loading="lazy" src="/normalChanOp/channel_reestablish.png#center" alt=""  />
</p>
<p>Each peer in the channel has their version of the commitment transaction and the
two commitment transactions can be updated independently meaning that the number
of times that one side’s commitment transaction state has been updated (through
the <code>commitment_signed</code> and <code>revoke_and_ack</code> flow) could be completely different
to that of the other side. The <code>next_commitment_number</code> field in the
<code>channel_reestablish</code> message allows us to communicate with our peer the next
<code>commitment_signed</code> that we expect to receive from them. This way, they will
know if we have perhaps missed a <code>commitment_signed</code> from them that they
previously sent before the disconnection. In other words,
<code>next_commitment_number</code> tells the remote peer what we see our latest committed
state to be. Similarly, <code>next_revocation_number</code> is the commitment number of the
next <code>revoke_and_ack</code> that we expect to receive. In other words, this indicates
to our peer which commitment number we think is their latest one. The
<code>your_last_per_commitment_secret</code> is the last per-commitment secret received
from the remote peer which will give the remote peer an idea of the state it has
definitely revoked. <code>my_current_per_commitment_point</code> is the commitment point of
the local party on its last commitment transaction signed by the remote peer (in
other words, the commitment transaction that has not yet been revoked). There
are a lot of checks that a node should do when receiving a <code>channel_reestablish</code>
in order to make sure that all necessary updates are re-sent so that the channel
can continue as normal. There are also some checks that ensure that nodes are
not tricked into revoking a state that should not yet be revoked or tricked into
broadcasting a state that <em>has</em> been revoked. If you are interested in the
details around these checks, see <a href="https://github.com/lightning/bolts/blob/master/02-peer-protocol.md#message-retransmission">bolt 2</a>.</p>
<p>Note that when a connection re-establish happens, both sides must remove any
un-committed updates from their staging area. If we stick with the git analogy,
they should hit <code>git stash</code> when a reconnection occurs. This means that both
sides will need to re-transmit any <code>update_*</code> messages that were not yet
committed on the other side’s commitment transaction.</p>
<h1 id="closing-a-channel-cooperatively">Closing a channel cooperatively</h1>
<p>Alice and Bob sure had some good times together but all good things must come to
an end. Closing a channel in a cooperative way requires the two peers to decide
on a final closing transaction that will spend from the funding transaction and
will pay each of them their final channel balance immediately.</p>
<h3 id="-step-22-bob---alice-shutdown">⚙️ Step 22: Bob -&gt; Alice: <code>shutdown</code></h3>
<p>Bob has decided that it is time to cut ties and sends Alice the <code>shutdown</code>
message.</p>
<p><img loading="lazy" src="/normalChanOp/shutdown.png#center" alt=""  />
</p>
<p>The <code>shutdown</code> message contains the <code>scriptpubkey</code> that Bob would like his final
channel balance to be sent to in the closing transaction. Once Bob has sent this
message, he may no longer send any new <code>update_add_htlc</code> messages. He may only
send HTLC removal and <code>update_fee</code> messages. When Alice receives this message
from Bob, she must respond with her own <code>shutdown</code> message and may also no
longer send any new <code>update_add_htlc</code> messages. Alice and Bob now need to wait
until all remaining HTLCs have been cleared from both commitment transactions.
Since the closing transaction will spend from the funding transaction and
explicitly looks different from the commitment transactions, I’ll re-introduce
some of the details in to the state diagram:</p>
<p><img loading="lazy" src="/normalChanOp/1-initial.png#center" alt=""  />
</p>
<p>Once all the HTLCs have been cleared, which in our example is already the case,
they can start negotiating a fee to use for the final closing transaction. The
funder of the channel must start this negotiation. Let’s assume that the funder
of this channel was Alice.</p>
<h3 id="-step-23-alice---bob-closing_signed">⚙️ Step 23: Alice -&gt; Bob: <code>closing_signed</code></h3>
<p>Alice will first choose a fee-rate that she thinks is appropriate for the
closing transaction. She will then use that fee-rate to complete the
construction of the closing transaction and will sign it. She then sends the
<code>closing_signed</code> message to Bob:</p>
<p><img loading="lazy" src="/normalChanOp/closing_signed.png#center" alt=""  />
</p>
<p>The <code>fee_satoshis</code> field tells Bob the fee in satoshis that Alice used to
construct the first closing transaction proposal and the <code>signature</code> contains
Alice’s signature for this proposal. She may optionally also include the
<code>min_fee_satoshis</code> and <code>max_fee_satoshis</code> fields in order to let Bob know that
if he disagrees with her proposed <code>fee_satoshis</code>, then he may send a
counterproposal as long as his counterproposal lies between the provided
minimum and maximum values.</p>
<p>At this point, the channel state looks as follows:</p>
<p><img loading="lazy" src="/normalChanOp/32-closing-alice-prop.png#center" alt=""  />
</p>
<p>There are two valid commitment transactions that can be signed at any time by
each party to perform a force close, and there is one closing transaction
proposal that uses a fee-rate of <code>x</code> sats-per-byte. This closing transaction
currently only has Alice’s signature and so is not yet valid.</p>
<p>If at this point, Bob is happy with Alice&rsquo;s proposal, he could go ahead and
sign the closing transaction using the fee-rate proposed by Alice and could
broadcast it and that would be the end of it. But for the sake of the example,
let&rsquo;s say that Bob isn&rsquo;t quite happy yet.</p>
<h3 id="-step-24-bob---alice-closing_signed">⚙️ Step 24: Bob -&gt; Alice: <code>closing_signed</code></h3>
<p>Bob may decide that the fee rate that Alice used is too low. So he sends a
counterproposal with a new fee rate, <code>y</code> sats-per-byte, along with his
signature for this counterproposal.</p>
<p><img loading="lazy" src="/normalChanOp/33-closing-bob-prop.png#center" alt=""  />
</p>
<h3 id="-step-25-alice---bob-closing_signed">⚙️ Step 25: Alice -&gt; Bob: <code>closing_signed</code></h3>
<p>If Alice is happy with Bob’s counterproposal, then she signs the closing
transaction using the fee-rate suggested by Bob. She may then broadcast the
transaction and call it a day. However, it is recommended in the spec that
Alice send one more <code>closing_signed</code> message to Bob but this time with the
<code>fee_satoshis</code> field set to <code>y</code> sats-per-byte along with her signature for the
transaction. Both parties will now have both signature required in order to
broadcast the final closing transaction that uses the <code>y</code> sats-per-byte fee rate.</p>
<p><img loading="lazy" src="/normalChanOp/34-closing-alice-agree.png#center" alt=""  />
</p>
<p>Either or both parties may now broadcast the closing transaction to the Bitcoin
network. Eventually it will be confirmed, and the channel will officially be
closed.</p>
<p><img loading="lazy" src="/normalChanOp/35-closed.png#center" alt=""  />
</p>
<p>If this channel was a public channel, then any node in the network that had this
channel in their routing graph will be able to see that the channel’s funding
output has been spent and so will remove the channel from their graph at this
point.</p>
<p>The beauty of the channel is that Alice and Bob could have sent millions of
HTLCs back and forth throughout the lifetime of the channel and in the end, all
that showed up on-chain was the opening and closing transaction.</p>
<p>Alice and Bob lived happily ever after.</p>
<p>Thanks for reading! As always, if anything is unclear or incorrect, feel free
to leave a comment down below.</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Taproot Channel Transactions</title>
      <link>https://www.ellemouton.com/posts/taproot-chan-txs/</link>
      <pubDate>Tue, 25 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://www.ellemouton.com/posts/taproot-chan-txs/</guid>
      <description>A deep-dive into the structure of Taproot channel transactions</description>
      <content:encoded><![CDATA[<p>Hold on to your hats folks, things are about to get real.</p>
<h1 id="overview">Overview</h1>
<p>In this post, I will dive into the structure of Taproot channel funding and
commitment transactions. If you missed my <a href="../../posts/taproot-prelims">previous post</a> about
Taproot and MuSig2, it might be a good idea to read that one first for a recap
of the building blocks that will be used throughout this post. If you perhaps
also need a re-cap of the general structure of commitment transactions then
check out <a href="../../posts/htlc-deep-dive">this</a> post where I cover why each output in a
commitment transaction looks the way it does.</p>
<p>Note that Taproot Channels are still in the design phase and so until
the <a href="https://github.com/lightning/bolts/pull/995">proposal</a> by the one and only <a href="https://twitter.com/roasbeef">Roasbeef</a> is
merged, this blog post will be a living document that I will update if any
changes are made to the proposal. This is currently up-to-date as of commit
<a href="https://github.com/lightning/bolts/pull/995/commits/e95e7acbda14e07fa53c1389f952481b822db795">e95e7a</a>.</p>
<p>If you have read some of my previous blog posts, you might have noticed that I
love to make use of diagrams. Well this post is diagrams on steroids. To help
with understanding, here is a legend showing what each colour generally
represents:</p>
<p><img loading="lazy" src="/taprootChanTxs/colour-legend.png#center" alt=""  />
</p>
<p>Ok, ready? Let&rsquo;s dive in!</p>
<h1 id="a-quick-note-on-nums-points">A quick note on NUMS points</h1>
<p>A NUMS point, or a nothing-up-my-sleeves point, is a public key that no one
knows the private key to and that is derived from a string binding it to the
context that it is being used in. The NUMS point used in taproot channels is
derived from the string “Lightning Simple Taproot” using <a href="https://github.com/lightninglabs/lightning-node-connect/tree/master/mailbox/numsgen">this NUMS generation
tool</a>. Since no one knows the private key for the NUMS point, it
can be used as the internal key for a Taproot output in order to effectively
cancel out the possibility of a key-path spend since no one would be able to
create a valid signature for it.</p>
<h1 id="funding-transaction-output">Funding Transaction Output</h1>
<p>The funding transaction output is the output that defines the opening of the
channel. In pre-taproot channels, this output pays into a 2-of-2 multisig
meaning that any transaction (commitment or closing transaction) spending from
the output must be signed by both channel peers. Since the output is a P2SH,
once it is spent, the underlying 2-of-2 multisig is revealed in the witness and
so it becomes pretty clear to anyone observing the chain that the transaction
was for a Lightning channel.</p>
<p>In the case of Taproot channels, this output is now a 2-of-2 MuSig2. Both
parties will still need to sign each transaction that spends from the output,
however, the signatures will now be aggregated via the MuSig2 protocol into a
single signature. This means that in the ideal case where the channel is closed
in a cooperative manner, the channel will look no different from any other P2TR
key-path spend. This is a huge privacy improvement for unannounced channels
since there is no way to tell that the transaction was for a Lightning channel,
and it never gets advertised to the network through the gossip protocol. As for
announced Taproot channels, the gossip protocol will actually need to be
completely re-designed to support the new channel type and there is currently an
ongoing debate around if this new gossip version should advertise the channel&rsquo;s
funding transaction at all or not. More on Taproot channel gossip in a future
post.</p>
<p>Here is a diagram showing how a Taproot channel funding output is
constructed:</p>
<p><img loading="lazy" src="/taprootChanTxs/funding-output.png#center" alt=""  />
</p>
<p>The two parties in a channel, the local and remote peer, use the MuSig2
protocol to aggregate their individual funding keys, <code>P_a</code> and <code>P_b</code>, into the
aggregate key, <code>P_agg</code>, which is also the internal key. This internal key is
then tweaked with a BIP86 tweak. You might recall from the previous post that a
BIP86 tweak gives the channel owners the ability to prove to other nodes on the
network that this funding output does not have a hidden script path.</p>
<h2 id="spending-from-the-funding-transaction">Spending from the funding transaction</h2>
<p>The funding output can only ever be spent via the key path. Since the internal
key is an aggregate key produced via MuSig2, to spend it requires both parties
to produce partial signatures for the message being signed. These signatures are
then aggregated using the MuSig2 <code>PartialSigAgg</code> function and finally tweaked
with the tweak, <code>T</code>, to produce the signature that would validly spend the
funding output.</p>
<p><img loading="lazy" src="/taprootChanTxs/funding-keypath.png#center" alt=""  />
</p>
<p>Notice that unlike in pre-taproot channels where spending from the funding
output would require two signatures created completely independently of each
other, in Taproot channels, the signatures are created in an interactive manner
between the peers. I will cover the details of how exactly this affects the
interaction between the peers in a future blog post.</p>
<h1 id="commitment-transaction-outputs">Commitment Transaction Outputs</h1>
<p>There are six different outputs that a commitment transaction can have. These
are: the <code>to_local</code> and <code>to_remote</code> outputs, the local and remote anchor
outputs, the offered htlc output and the accepted htlc output. Let’s dive in.</p>
<h2 id="the-to_local-output">The <code>to_local</code> output</h2>
<p>The <code>to_local</code> output is responsible for paying the local peer their channel
balance. The output must be revocable by the remote party at all times and only
after <code>to_self_delay</code> blocks should the local party be able to spend from the
output. As you can see in the diagram below, both these paths are added as Taproot
leaves in the Taproot tree and a public NUMS point is used as the internal key
which effectively cancels out the key-spend path. You might be asking yourself
why the revocation pub key is not used as the internal key and this is a good
question since that is in fact how the output was in the original design. But
you can see from the diagram below that the revocation script does not only
contain the revocation public key but also strangely contains the
<code>P_local_delay</code> key. Notice also that the key is not followed by <code>OP_CHECKSIG</code>
but rather just by an <code>OP_DROP</code> which means that a signature is not required for
the key. All that is required is that the key is revealed in the script. This
reveal of <code>P_local_delay</code> in the revocation path is the only reason why the
revocation public key could not be used as the internal key for the output. The
reason for this design will be made more clear in the section describing the
<a href="#local-anchor-output">local anchor output</a>. There is a good reason, I promise
;)</p>
<p><img loading="lazy" src="/taprootChanTxs/to-local-output.png#center" alt=""  />
</p>
<h3 id="script-path-spends">Script path spends</h3>
<p>Since the internal key of the output is a public NUMS point, it is only possible
to spend this output via a script path.</p>
<h4 id="revocation-path">Revocation path</h4>
<p>If this commitment transaction ends up on-chain and is for a state that has
already been revoked, then the remote party will be able to sweep the funds via
the revocation path. They can do so with the following witness:</p>
<p><img loading="lazy" src="/taprootChanTxs/to-local-revocation-script.png#center" alt=""  />
</p>
<p>It contains a signature for the revocation public key, the revocation script
(which includes a reveal of the <code>P_local_delay</code> key) and finally it contains a
control block which contains the internal key (the <code>NUMS</code> key) along with an
inclusion proof for the revocation script.</p>
<h4 id="to-local-delay-path">To-local delay path</h4>
<p>If this commitment transaction ends up on-chain as part of an honest force-close
scenario then the remote party will not be able to spend via the revocation
path. In this case, the transaction will be spendable by the local party via the
local delay script path after <code>to_self_delay</code> blocks have been confirmed. The
following diagram shows the witness that will be required to spend this path:</p>
<p><img loading="lazy" src="/taprootChanTxs/to-local-delay-script-path.png#center" alt=""  />
</p>
<p>It contains a witness for the local-delayed script which is a valid signature
from the local party for their key, <code>P_local_delayed</code>. The script itself must
also be revealed and finally, the control block must be specified. In this case,
the control block only contains the parity bit of <code>to_local</code> output’s output
key, the internal key (which is the NUMS point) and the inclusion proof for the
to-local delay script.</p>
<h2 id="the-to_remote-output">The <code>to_remote</code> output</h2>
<p>This output pays the remote party their channel balance. As with all anchor
channels, any non-anchor outputs must have a CSV of at least one to not break
the <a href="https://bitcoinops.org/en/topics/cpfp-carve-out/">CPFP carve out</a> rule. Therefore, the remote party is only allowed
access to their funds after one confirmation. This type of requirement can only
be added in a script and so this output also makes use of the Taproot script
tree.</p>
<p><img loading="lazy" src="/taprootChanTxs/to-remote-output.png#center" alt=""  />
</p>
<p>Similarly to the <code>to_local</code> output, we use the NUMS point for the internal key
here so that a key path spend is not possible.</p>
<h3 id="script-path-spend">Script path spend</h3>
<p>Once the commitment transaction has one confirmation, the remote peer can spend
it via the script path using the following witness:</p>
<p><img loading="lazy" src="/taprootChanTxs/to-remote-script-path.png#center" alt=""  />
</p>
<h2 id="remote-anchor-output">Remote Anchor Output</h2>
<p>This is the output that the remote party will be able to use to CPFP the
commitment transaction if required. The remote party’s public key is thus used
as the internal key. To ensure that this output (a very small output of only 330
satoshis) is definitely cleaned up at some point from the UTXO set, another
output path is added which allows anyone to spend the output after it has been
confirmed for 16 blocks. This extra path is added as a script in the script
tree.</p>
<p><img loading="lazy" src="/taprootChanTxs/remote-anchor-output.png#center" alt=""  />
</p>
<h3 id="key-path-spend">Key path spend</h3>
<p>Spending via the key path just requires a signature from the remote party which
they will tweak with the TapTweak.</p>
<p><img loading="lazy" src="/taprootChanTxs/remote-anchor-key-path.png#center" alt=""  />
</p>
<h3 id="script-path-spend-1">Script path spend</h3>
<p>Once the output has been confirmed for 16 blocks, it becomes fair game. Anyone
is allowed to spend from this output as long as they can produce the following
spending script:</p>
<p><img loading="lazy" src="/taprootChanTxs/remote-anchor-script-path.png#center" alt=""  />
</p>
<p>Notice anything here? If you were a third party trying to sweep some expired
anchor outputs for some free sats, would you be able to produce the above
spending script? The answer is: yes, but only if you know what <code>P_remote</code> is!
Before reading on, I suggest taking some time to think about how you could
possibly come to know what <code>P_remote</code> is. It is not present in the funding
transaction, nor is it present in the commitment transaction. Scroll up through
the diagrams to see if you can see where it is revealed.</p>
<p>Ok ready? It is only revealed if the <code>to_remote</code> output is spent as it appears
in the witness required to spend that output. This means that the remote anchor
is spendable by anyone after 16 blocks only when the <code>to_remote</code> output has been
spent.</p>
<h2 id="local-anchor-output">Local Anchor Output</h2>
<p>This is the output that you, the local party, will be able to use to CPFP the
commitment transaction. And just like the remote anchor, it is spendable by
anyone after 16 blocks. So the internal key is <code>P_local_delayed</code> and the “anyone
can spend after 16 blocks” script is put in the script tree.</p>
<p><img loading="lazy" src="/taprootChanTxs/local-anchor-output.png#center" alt=""  />
</p>
<h3 id="key-path-spend-1">Key path spend</h3>
<p>Spending via the key path just requires a signature from the local party which
they will tweak with the TapTweak.</p>
<p><img loading="lazy" src="/taprootChanTxs/local-anchor-key-spend.png#center" alt=""  />
</p>
<h3 id="script-path-spend-2">Script path spend</h3>
<p>Just like the remote anchor, the parties wanting to spend via the “anyone can
spend” path require the <code>P_local_delayed</code> public key to first be revealed. This
is revealed when the <code>to_local</code> output is spent by the local party via the
script path <em>and</em> importantly this is also revealed even if the revocation path
is taken in the <code>to_local</code> output! This is the whole reason why the internal key
for the <code>to_local</code> output could not just be the revocation key and why we have
to instead force a script path spend that also reveals the <code>P_local_delayed</code>
key. From the witness below, you can see why knowledge of the <code>P_local_delay</code>
key is required for someone to spend this anchor output via the script path. If
it was not revealed then there is a chance that the output would remain floating
in the UTXO set forever since third parties would not know how to spend it.</p>
<p><img loading="lazy" src="/taprootChanTxs/local-anchor-script-path.png#center" alt=""  />
</p>
<h2 id="offered-htlc-output">Offered HTLC Output</h2>
<p>An offered HTLC pays out to the remote party if they reveal the pre-image to a
given hash before a certain CLTV timeout. After the timeout, the local party
will be able to claim the output via the htlc-timeout transaction (details on
that <a href="#htlc-timeout-and-success-transactions">below</a>). If the commitment
transaction is a revoked state, then the remote party should be able to sweep
the output at any time.</p>
<p><img loading="lazy" src="/taprootChanTxs/offered-htlc-output.png#center" alt=""  />
</p>
<h3 id="key-path-spend-2">Key path spend</h3>
<p>The internal key is set to the revocation key which is spendable only by the
remote party and only if the commitment transaction is for a revoked state. If
this is the case, then the remote party can sweep the output with the following
signature:</p>
<p><img loading="lazy" src="/taprootChanTxs/offered-htlc-key-spend.png#center" alt=""  />
</p>
<h3 id="script-path-spends-1">Script path spends</h3>
<p>The other two spend paths, the success and timeout paths, are placed in the
script tree and spending either of them requires providing a valid witness for
the script, the script itself and a control block which this time does include
an inclusion proof since more than one script is present in the tree.</p>
<h4 id="success-path">Success Path</h4>
<p>To spend via the success path, the following witness is required.</p>
<p><img loading="lazy" src="/taprootChanTxs/offered-htlc-success.png#center" alt=""  />
</p>
<h4 id="timeout-path">Timeout Path</h4>
<p>The following witness is required to spend via the timeout path. The transaction
that will spend the timeout path is the htlc-timeout transaction - more details
on that transaction later on. If you need a recap on the reason why second-stage
htlc transactions are necessary, check out <a href="../../posts/htlc-deep-dive">this</a> post.</p>
<p><img loading="lazy" src="/taprootChanTxs/offered-htlc-timeout.png#center" alt=""  />
</p>
<h2 id="accepted-htlc-output">Accepted HTLC Output</h2>
<p>The accepted HTLC output pays out to an htlc-success transaction if we (the
local party) are able to provide the pre-image for the given payment hash.
Otherwise, after a certain <code>cltv_expiry</code>, the remote party will be able to sweep
the funds back via the timeout path. If the commitment transaction is a revoked
state, then the remote party should be able to sweep the output at any time.</p>
<p><img loading="lazy" src="/taprootChanTxs/accepted-htlc-output.png#center" alt=""  />
</p>
<h3 id="key-path-spend-3">Key path spend</h3>
<p>The internal key is set to the revocation key which is spendable only by the
remote party and only if the commitment transaction is for a revoked state. If
this is the case, then the remote party can sweep the output with the following
signature:</p>
<p><img loading="lazy" src="/taprootChanTxs/accepted-htlc-key-path.png#center" alt=""  />
</p>
<h3 id="script-path-spends-2">Script path spends</h3>
<p>The other two spend paths, the success and timeout paths, are placed in the
script tree and spending either of them requires providing a valid witness for
the script, the script itself and a control block which this time does include
an inclusion proof since more than one script is present in the tree.</p>
<h4 id="success-path-1">Success Path</h4>
<p>To spend via the htlc-success transaction, the following witness must be
provided:</p>
<p><img loading="lazy" src="/taprootChanTxs/accepted-htlc-success.png#center" alt=""  />
</p>
<h4 id="timeout-path-1">Timeout Path</h4>
<p>To spend via the timout path, the remote party must provide the following
witness:</p>
<p><img loading="lazy" src="/taprootChanTxs/accepted-htlc-timeout.png#center" alt=""  />
</p>
<h2 id="htlc-timeout-and-success-transactions">HTLC Timeout and Success Transactions</h2>
<p>The htlc-timeout and htlc-success transactions look mostly identical so here is
one diagram to describe both:</p>
<p><img loading="lazy" src="/taprootChanTxs/htlc-txs.png#center" alt=""  />
</p>
<p>The first difference between the htlc-success and htlc-timeout transactions is
the input they are spending and hence, the witness required for spending
that input. The htlc-timeout transaction spends the timeout path of the offered
HTLC output and the htlc-success transaction spends the success path of the
accepted HTLC output. The other difference is the <code>Locktime</code>: the htlc-timeout
transaction has a <code>Locktime</code> of <code>cltv_expiry</code> and the htlc-success transaction
has a <code>Locktime</code> of zero.</p>
<p>The outputs of the htlc-success and htlc-timeout transactions are identical:
they are immediately spendable by the remote party via the revocation path if
the associated commitment transaction is for a revoked state. Otherwise, they
are spendable by the local party after <code>to_self_delay</code> blocks have been
confirmed.</p>
<p>The key path and script path spend scripts are exactly the same as for
the <code>to_local</code> output.</p>
<h1 id="wrap-up">Wrap Up</h1>
<p>If you have made it all the way through that, congrats! You should now have a
pretty solid understanding of the structure of Taproot channel commitment
transactions. A future blog post will cover how the various channel peer
messages will need to be updated to support MuSig2 signing. I expect it to be a
short and sweet one.</p>
<p>As always, if you have any questions, comments or corrections, please feel free
to leave a comment down below :)</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Taproot and MuSig2 recap</title>
      <link>https://www.ellemouton.com/posts/taproot-prelims/</link>
      <pubDate>Tue, 18 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://www.ellemouton.com/posts/taproot-prelims/</guid>
      <description>A recap of the building blocks required for Taproot channels</description>
      <content:encoded><![CDATA[<p>In my <a href="../../posts/open_channel_pre_taproot">last</a> blog post, I promised a follow-up post on the
workings of Taproot channels. However, when I started working on it, I realised
that it might be a good idea to first dedicate a post to recap the preliminaries
that will be required in order to understand the follow-up Taproot channel
articles. So here you go!</p>
<h1 id="overview">Overview</h1>
<p>This post will cover some basics around Taproot outputs and how to spend them
via either the key or script paths. It will also cover the MuSig2 flow between
two signing parties. Note that I won’t go into extreme detail for either of
these topics. Instead, this post is aimed at refreshing your memory on these
topics or giving you enough of an understanding of how Taproot outputs and
MuSig2 work so that the follow-up articles are more easily digestible. There are
better articles out there for you if you want to get into the nitty-gritty of
these topics and of course you can always go check out the BIPs if you are
brave: <a href="https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki">Schnorr signatures</a>, <a href="https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki">Taproot</a>, <a href="https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki">Tapscript</a> and
<a href="https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki">MuSig2</a>.</p>
<p>Ok, enough chit-chat. Onto the good stuff!</p>
<h1 id="a-quick-note-on-bip340-public-keys">A quick note on BIP340 public keys</h1>
<p>Public keys will mostly be encoded as 32-byte arrays instead of the usual
33-byte compressed public key representation that you might be used to. If the
secp256k1 curve is plotted over a non-finite field (as shown below) then you can
see that for every x-coordinate, there are two possible y-coordinates. Since the
curve is actually over a finite field with an odd order, one y-coordinate for a
given x-coordinate will always be even and the other one will be odd. The
assumption for 32-byte encoded public keys is that the y-coordinate is always
the even one. This means that if you want to create a valid BIP340 signature but
your private key, <code>d</code>, produces a public key, <code>P</code>, with an odd y-coordinate,
then all you need to do is <em>negate</em> your private key. This will produce public
key <code>P’</code> which has the same x-coordinate as your original public key but with an
even y-coordinate. For more information regarding BIP340 public keys and
signatures (also known as Schnorr signatures), check out the <a href="https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki">BIP</a>
itself.</p>
<p><img loading="lazy" src="/taprootPrelims/curve.png#center" alt=""  />
</p>
<h1 id="taproot-outputs">Taproot Outputs</h1>
<p>A Taproot output shows up in the <code>scriptPubKey</code> section of a transaction (just
like all other outputs) and has the following form:</p>
<p><img loading="lazy" src="/taprootPrelims/tr-output.png#center" alt=""  />
</p>
<p>The <code>OP_1</code> indicates that this is a SegWit Version 1 output (a.k.a. Taproot
output) and what follows are 32 bytes that represent the output key (see
<a href="#a-quick-note-on-bip340-public-keys">BIP340 public keys</a> above). I will often
use <code>Q</code> to refer to this key. To give the full picture, here is a Taproot
output in a transaction:</p>
<p><img loading="lazy" src="/taprootPrelims/tr-output-in-tx.png#center" alt=""  />
</p>
<p>Ok cool. But what exactly is in this output? Is it just like a P2PK output? No.
That would be lame. The truth is that this simple-looking output could be a huge
variety of different things. It could be a simple single public key (yes, like
a P2PK). It could be an n-of-n MuSig2 public key. It could also have a bunch of
script branch options, or it could even be a combination of all the above! Let’s
break these options down a bit.</p>
<h2 id="single-key-or-n-of-n-musig2-outputs">Single Key or n-of-n MuSig2 outputs</h2>
<p>If you wanted to just create an output that sends to a single public key, <code>P</code>,
then this is easy to do. In this case, your output key, <code>Q</code>, just becomes your
key, <code>P</code>, which is often called the <em>internal key</em>.</p>
<p><img loading="lazy" src="/taprootPrelims/tr-single-key.png#center" alt=""  />
</p>
<p>To spend this output, all you need is to provide a BIP340 signature in the
witness which you would calculate using the private key, <code>d</code>, used to derive
<code>P</code>. See the note explained in the <a href="#a-quick-note-on-bip340-public-keys">BIP340 Public
Keys</a> section about possibly needing to
negate your private key first.</p>
<p><img loading="lazy" src="/taprootPrelims/tr-single-key-spend.png#center" alt=""  />
</p>
<p>Now, what if you instead wanted to use an n-of-n aggregate MuSig2 public key?
Turns out that this will look <em>exactly</em> the same on-chain as for the single key
case explained above! All that changes is the steps that you and your fellow
signers need to take to set up the aggregate public key and then to calculate
the final signature. But once all that is complete, what ends up on-chain looks
no different.</p>
<p><img loading="lazy" src="/taprootPrelims/musig-output.png#center" alt=""  />
</p>
<h2 id="script-paths">Script Paths</h2>
<p>Here is where the magic really happens. You can also have the option of
spending your Taproot output via a script <em>and</em> each output can have multiple
scripts from which it can be spent. Another cool thing is that if you choose to
include script paths in your Taproot output, you can still add a regular key
path like before. Let’s say, for example, that you want to be able to spend your
output at any time, but you also want to add three script paths so that it can
also be spent in other scenarios: perhaps after 30 days you want your partner to
be able to spend the output. That would be one script path. If you also have two
other script paths (perhaps one is a 2-of-3 multi-sig and the other requires a
pre-image reveal), then your Taproot output would be constructed as follows:</p>
<p><img loading="lazy" src="/taprootPrelims/tr-whole-thing.png#center" alt=""  />
</p>
<p>Let’s walk through the above diagram a bit:</p>
<p>First, the three scripts (<code>Script A</code>, <code>Script B</code> and <code>Script C</code>) are all put
into a <a href="https://en.wikipedia.org/wiki/Merkle_tree">Merkle tree</a> as shown bottom right. The root of this Merkle tree
is then hashed along with our internal key, <code>P</code>, to get the 32-byte tweak, <code>t</code>.
This tweak is converted to its elliptic curve point form by multiplying it with
the generator point, <code>G</code>, to get <code>T</code> which is then added to our internal key,
<code>P</code>, to get the final output key, <code>Q</code>. I have skipped over some things here such
as the details of the script encodings and also how the scripts are hashed in
the Merkle tree so check out the relevant BIPs if you are interested.</p>
<p>Alrighty - our fancy Taproot output has been set up! But now… how do we spend
it? There are two ways of spending this transaction: the first is via the
internal key, <code>P</code>. We call this a <a href="#key-path-spends"><em>key path spend</em></a>. The
other way is via one of the scripts in the tree. This type of spend is called a
<a href="#script-path-spends"><em>script path spend</em></a>.</p>
<h3 id="key-path-spends">Key Path Spends</h3>
<p>Spending via the key path is very simple and is similar to spending the output
if it was just a normal un-tweaked key as described <a href="#single-key-or-n-of-n-musig2-outputs">earlier
on</a>. The only difference is that you will
need to tweak your private key, <code>d</code>, with the tweak, <code>t</code>. In other words, your
new private key becomes <code>d + t</code> which is what you will use to calculate your
signature. That’s it! If you spend the output via the key path, there is no
need to reveal any of the scripts and so anyone looking at the spend on-chain
will have no clue that the output even had the potential to be spent via a
script path.</p>
<p><img loading="lazy" src="/taprootPrelims/tr-tweaked-pk.png#center" alt=""  />
</p>
<h3 id="script-path-spends">Script Path Spends</h3>
<p>To spend via one of the script paths requires a slightly more complicated
witness. Let’s say we want to spend via <code>Script B</code>. We will need to do a few
things to convince a verifier that we have the right to spend the output:</p>
<ol>
<li>We must provide a valid spending script for <code>Script B</code>.</li>
<li>We need to prove that <code>Script B</code> is actually embedded in the output.</li>
</ol>
<p>Step 1 is pretty simple: just provide the valid witness script for <code>Script B</code>
along with <code>Script B</code> itself. Step 2 is slightly more involved. To prove that
<code>Script B</code> is embedded in <code>Q</code>, we need to give the verifier all the building
blocks required in order to actually construct <code>Q</code>. These building blocks are
put in what is called the “control block”. The first thing in the control block
is the internal key, <code>P</code>. It also contains the Merkle proof that allows the
verifier to compute the Merkle tree root. The witness already includes
<code>Script B</code> itself (it was required for step 1), so the verifier can compute
<code>hB</code> (see the diagram above showing the Merkle tree construction) themselves,
and so we just need to provide <code>hA</code> and <code>hC</code>. The validator will use these
hashes to calculate the <code>script_root</code> and then hash this along with the
internal key, <code>P</code>, in order to arrive at the tweak, <code>t</code>. The validator can then
compute the corresponding tweak point, <code>T</code>, add that to the internal key, <code>P</code>,
to get the output key, <code>Q</code>. The final thing that the control block must include
is a bit indicating if the final <code>Q</code> point has an odd or even y-coordinate so
that the validator can check if the <code>Q</code> they computed does have the correct
y-coordinate.</p>
<p><img loading="lazy" src="/taprootPrelims/script-spending-witness.png#center" alt=""  />
</p>
<p>It is important to note that no knowledge of <code>d</code> (the private key for the
internal key, <code>P</code>) was required for spending via <code>Script B</code> (assuming of course
that <code>Script B</code> itself does not involve <code>P</code>). Another cool thing is that we did
not need to reveal the contents of the other scripts in the tree, only their
hashes.</p>
<h3 id="bip86-tweaks">BIP86 Tweaks</h3>
<p>There is a clever trick that can be used if you would like to create an output
with no script path that allows you to also prove to a third party that there
is no script path. All you do is construct <code>Q</code> as if you were constructing an
output with script paths <em>but</em> the script root is left empty.</p>
<p><img loading="lazy" src="/taprootPrelims/bip86-tweak.png#center" alt=""  />
</p>
<p>Spending this output can now only be done via the key spend path using private
key <code>d + t</code>. Then, <code>P</code> can be provided to any third parties who want proof that
there is no script path. They would use <code>P</code> to compute <code>t</code> and <code>T</code> and then
would verify that <code>P + T</code> is equal to the output key, <code>Q</code>. More info about this
can be found in <a href="https://github.com/bitcoin/bips/blob/master/bip-0086.mediawiki#address-derivation">BIP86</a>.</p>
<h1 id="musig2">MuSig2</h1>
<p>With the Taproot soft fork, bitcoin nodes now have an understanding of BIP340
signatures (or Schnorr signatures). The beauty of these signatures is their
linearity: the owner of public key <code>P_1</code> can create a partial signature,
<code>sig_1</code> for the message <code>msg</code> and the owner of public key <code>P_2</code> can create
<code>sig_2</code> for the same message. The two parties will then be able to combine their
signatures such that <code>sig</code> where <code>sig = sig_1 + sig_2</code> is a valid signature for
the aggregate of their public keys: <code>P = P_1 + P_2</code>.</p>
<p>This is really cool because it means that instead of needing to create a long
n-of-n multisig script and then needing to pay for the blockchain space to store
each of the <code>n</code> signatures, only one signature will be needed and no long script
will be required at all. Instead, only a single public key (which is actually an
<em>aggregate</em> public key) needs to appear on-chain.</p>
<p>The tricky part here is everything that needs to happen <em>off-chain</em> during the
setup of this aggregate public key as well as for the creation of the final
signature. <a href="https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki">MuSig2</a> is the protocol that defines how this should be
done. The various steps have been carefully thought through in order to keep
the process trust-less and to protect parties from attacks such as key
cancellation.</p>
<p><a href="https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki">BIP327</a> defines the MuSig2 protocol along with a bunch of algorithms
that should be used for the various steps of the process. Since the aim of this
article is to provide all the building blocks required for understanding
Lightning Taproot channels, I will only talk about MuSig2 at an API level using
the defined algorithms and will focus more on how it will be used in Lightning.
If you would like to dig into it more you can check out the BIP itself. I have
also implemented all the MuSig2 methods from scratch <a href="https://github.com/ellemouton/schnorr/tree/master/musig2">here</a> if you
are the type of person who prefers looking at code.</p>
<h2 id="musig2-vs-n-of-n-multisig">MuSig2 vs n-of-n Multisig</h2>
<p>An important thing to keep in mind is that with n-of-n multisig outputs, parties
can generate their signatures completely independently of the other parties. As
long as they have the message to be signed along with their private key, they
can create a signature. This signature can then safely be distributed to the
other parties and eventually the transaction witness will have all <code>n</code>
signatures. In other words: no interaction is required between parties at
signing time. With n-of-n <em>MuSig2</em> this is not the case since there is one
public key on-chain and thus one signature needs to be produced. The <code>n</code> parties
have to interact with each other in order to produce this final signature.</p>
<h2 id="explanation-by-example">Explanation by example</h2>
<p>Let’s walk through the case where two parties, Alice and Bob, want to set up a
2-of-2 MuSig2 output and then create a signature to spend from it.</p>
<p>This first diagram shows the initial state: Alice and Bob both have private keys
and the corresponding public keys and currently the two parties have no shared
knowledge.</p>
<p><img loading="lazy" src="/taprootPrelims/musig-1.png#center" alt=""  />
</p>
<p>When the two parties decide to construct an output together, they will first
need to exchange public keys. Both parties will then use the MuSig2 <code>KeySort</code>
algorithm to sort the keys and then the <code>KeyAgg</code> algorithm to aggregate the
keys. This will produce the aggregate key, <code>P_agg</code>, which would be the key that
would appear in the transaction output.</p>
<p><img loading="lazy" src="/taprootPrelims/musig-2.png#center" alt=""  />
</p>
<p>Once Alice and Bob have a shared message that they want to sign (which would
most likely be the spending transaction), they can move onto the signing phase.</p>
<p><img loading="lazy" src="/taprootPrelims/musig-3.png#center" alt=""  />
</p>
<p>Step one of the signing phase involves each party generating nonces. They will
each generate a secret nonce, called the <code>secnonce</code>, and from the <code>secnonce</code> the
associated public nonce, called the <code>pubnonce</code>, can be determined. Note that
each <code>secnonce</code> is actually made up of two private keys and each <code>pubnonce</code> is
made up of the two public keys associated with those private keys. The details
of why there are two nonces is outside the scope of this post. Alice and Bob
will then need to exchange the public nonces and then both parties will use the
MuSig2 <code>NonceAgg</code> function to determine the aggregate nonce: <code>aggnonce</code>. Note
that this step had nothing to do with the message to be signed meaning that this
step can actually take place before the message to be signed is known.</p>
<p><img loading="lazy" src="/taprootPrelims/musig-4.png#center" alt=""  />
</p>
<p>When the public nonces have been exchanged and both parties know the message to
be signed then each party can use the MuSig2 <code>Sign</code> function to produce partial
signatures.</p>
<p><img loading="lazy" src="/taprootPrelims/musig-5.png#center" alt=""  />
</p>
<p>The final step is for the parties to exchange their partial signatures. Each
party can then use the MuSig2 <code>PartialSigAgg</code> function to calculate the final
signature. This signature will be a valid signature for <code>P_agg</code> over the
message, <code>msg</code>.</p>
<p><img loading="lazy" src="/taprootPrelims/musig-6.png#center" alt=""  />
</p>
<p>It is important to become familiar with the above MuSig2 flow because it will be
used very often in the next few articles. In Taproot channels the funding output
of a channel will be a MuSig2 aggregate public key. This means that every
commitment transaction created that spends from the funding output will need to
go through this signing flow. Since channel states in Lightning are asymmetric,
this also means that this flow will need to happen twice per state update: once
to sign the local commitment transaction and once to sign the remote one. But
more on that in the next blog post :)</p>
<p>Thanks for reading! I hope that was useful. If you think there is anything that
could use clarification or that is incorrect then please don’t hesitate to reach
out to let me know.</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Opening and announcing a pre-taproot LN channel</title>
      <link>https://www.ellemouton.com/posts/open_channel_pre_taproot/</link>
      <pubDate>Mon, 23 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://www.ellemouton.com/posts/open_channel_pre_taproot/</guid>
      <description>A deep dive into opening a pre-taproot Lightning Network channel</description>
      <content:encoded><![CDATA[<p>In this article, I will go over the process of opening a Lightning Network
channel as it works today (pre taproot channels). I will start with the
<code>channel_open</code> message and will talk in detail about it and all the messages
involved in “opening” the channel ending with the <code>channel_announcement</code>
message.</p>
<p>My goal for this article is to recap today’s channel open flow so that we can
later focus only on the changes required for opening a taproot
channel<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>.</p>
<p>This article replaces my previous <a href="../creating-a-channel">short article on channel opens</a>. It includes
more detail and more diagrams (yay diagrams!). I will assume that the reader
understands the structure of a commitment transaction and understands why they
are asymmetric. If you feel a bit rusty in this area, please check out my
articles explaining these <a href="../updating-state">concepts in detail</a>.</p>
<h2 id="the-end-goal">The end goal</h2>
<p>Before we dig into the first step, I think it is useful to illustrate the goal
we are trying to reach. I will once again use our trusty peers, Alice and Bob,
to tell the story.</p>
<p>Alice and Bob are both Lightning Network nodes. Alice’s node ID (ie, the public
key used to identify her node) is <code>alice_node_id</code> and Bob’s node ID is
<code>bob_node_id</code>. Their main two goals are:</p>
<ol>
<li>They want to open a channel between themselves in a trustless way.</li>
<li>They want to be able to advertise their new channel so that the rest of the
network can use it for routing.</li>
</ol>
<h2 id="opening-the-channel">Opening the channel</h2>
<p>A channel is opened once both parties have the ability to fully sign their
respective commitment transactions and once the funding transaction is on chain.
Throughout this explanation, I will use diagrams and colours to illustrate the
process. In the diagrams, a white background means that the field of the
transaction is not yet known. A coloured-in field indicates that the field value
is known. Any green fields are used to highlight any of Alice’s public keys or
signatures and any blue fields are used to show Bob’s.</p>
<p>There are three transactions in play for the opening of a channel. The first
is the funding transaction which will need to go on chain. The other two are the
first commitment transactions held by Alice and Bob describing the initial state
of the channel.</p>
<p>Here are the diagrams used to describe the three transactions. Note that at the
moment we still don’t know anything about the parameters of the channel and so
all fields still have a white background. Remember that our end goal is to have
all these fields coloured in.</p>
<p><img loading="lazy" src="/openChanPt1/fntx_1.png#center" alt=""  />

<img loading="lazy" src="/openChanPt1/1a_1.png#center" alt=""  />

<img loading="lazy" src="/openChanPt1/1b_1.png#center" alt=""  />
</p>
<h3 id="the-open_channel-message">The <code>open_channel</code> message</h3>
<p>The first step of the process is Alice deciding that she wants to open a channel
with Bob. In doing so, she also becomes the funder of the channel. Let’s say
that Alice decides that she wants to open a 1 BTC channel and wants to
immediately give Bob half of the channel’s capacity (0.5 BTC). Alice will now
put together an <code>open_channel</code> message that she will send to Bob. Let’s take a
look at the relevant <code>open_channel</code> parameters (I am leaving out any parameters
that don’t have anything to do with the channel-open phase). You can skip this
table if you want. It is just a reference for incase you want to check what the
meaning of a field is.</p>
<p><img loading="lazy" src="/openChanPt1/open_channel_params.png#center" alt=""  />
</p>
<p>Let’s now fill in Alice’s values for these fields:</p>
<p><img loading="lazy" src="/openChanPt1/open_chan.png#center" alt=""  />
</p>
<p>Alice sends this message over to Bob.</p>
<p>Since Alice has decided on the type of channel she wants to open (default
channel type as opposed to an anchors, taproot etc) as well as the channel
capacity, she can already piece together quite a large part of the funding
transaction:</p>
<p><img loading="lazy" src="/openChanPt1/fntx_2.png#center" alt=""  />
</p>
<p>Since she knows the capacity of the channel she wants to open, she can choose
some of her UTXOs to be inputs to the funding transaction. Since Alice does not
yet know which pub key Bob would want to use for the channel, she cannot yet
finalise the channel funding output and hence can also not yet produce
signatures for the inputs.</p>
<p>Since Alice has decided on the channel type (and hence the commitment
transaction structure), she can also start putting together the pieces of the
commitment transactions. If we assume that Bob is delighted by this
channel-opening proposal from Alice, then from this <code>open_channel</code> message, he
can also start putting together the pieces. Remember that both parties will need
to construct both commitment transactions since they will both need to be able
to sign their peer’s transactions. Let’s take a look at what pieces they are now
both able to fill in:</p>
<p><img loading="lazy" src="/openChanPt1/1a_2.png#center" alt=""  />
</p>
<p>Alice’s commitment transaction has filled in quite nicely. It has the structure
of a default, non-anchor channel transaction and all her public keys have been
filled in (<code>alice_local_delayed_pk_1</code> is derived using her
<code>delayed_payment_basepoint</code> and her <code>first_commitment_point</code>). Since she hasn’t
received any messages from Bob yet, she has not yet been able to fill in any of
his pub keys and since the funding transaction is still incomplete, she also
can’t yet know the TXID to point the input of this commitment transaction to.</p>
<p>Bob’s commitment transaction (from his perspective) is looking a bit more
complete:</p>
<p><img loading="lazy" src="/openChanPt1/1b_2.png#center" alt=""  />
</p>
<p>Like Alice, he also cannot yet fill in the funding transaction’s TXID, but he
can fill in a few other things:</p>
<ul>
<li>The <code>alice_pubkey_1</code>, <code>alice_to_self_delay</code>, <code>push_amt</code> and <code>local_amt</code> values
are taken as is from the <code>open_channel</code> message</li>
<li><code>alice_payment_key_1</code> is derived using Alice’s <code>payment_basepoint</code> and
<code>first_commitment_point</code></li>
<li><code>revoke_pubkey_1b</code> is derived using Alice’s <code>revocation_basepoint</code> and Bob’s
<code>first_per_commitment</code> point (at this point Alice cannot derive this point yet
since she has not received his <code>first_per_commitment_point</code>)</li>
</ul>
<p>Ok cool! Time for Bob to indicate to Alice his acceptance of the request by
sending the next message: <code>accept_channel</code></p>
<h3 id="the-accept_channel-message">The <code>accept_channel</code> message</h3>
<p>The message shares many of the fields from <code>open_channel</code>. Here is the message
that Bob will put together:</p>
<p><img loading="lazy" src="/openChanPt1/accept_channel.png#center" alt=""  />
</p>
<p>When Alice gets this message from Bob, she can now complete the funding
transaction’s output and can create the signatures for the inputs. Since
everything is filled in, the TXID for the funding tx is now also known.</p>
<p><img loading="lazy" src="/openChanPt1/fntx_3.png#center" alt=""  />
</p>
<p>Alice can now also further fill in her own commitment transaction:</p>
<ul>
<li>she is now able to use the values sent by Bob to fill in <code>bob_pubkey_1</code>,
<code>bob_payment_key_1</code>, <code>bob_to_self_delay</code> and <code>revoke_pubkey_1a</code></li>
<li>since the TXID for the funding tx is now known, she can complete the input too.</li>
</ul>
<p>She now knows everything she needs to know in order to sign this transaction
herself <em>but</em> she is still missing Bob’s signature for this transaction.</p>
<p><img loading="lazy" src="/openChanPt1/1a_3.png#center" alt=""  />
</p>
<p>Bob’s view of his commitment transaction is still the same as before since he
learned no new info after sending the <code>accept_channel</code> message.</p>
<p>Now that Alice knows the txid for the funding transaction, she is also able to
complete her view of Bob’s commitment transaction and so she can produce her
signature for his transaction. This is where the next message comes in:
<code>funding_created</code>.</p>
<h3 id="the-funding_created-message">The <code>funding_created</code> message</h3>
<p>Alice will now use the <code>funding_created</code> message to tell Bob the TXID and index
of the funding transaction along with her signature for Bob’s commitment
transaction. Note that he still wont be able to broadcast his transaction since
Alice has not yet broadcast the funding transaction.</p>
<p><img loading="lazy" src="/openChanPt1/funding_created.png#center" alt=""  />
</p>
<p>Once the funding message has been received, Bob can fill in the rest of his
commitment transaction:</p>
<p><img loading="lazy" src="/openChanPt1/1b_3.png#center" alt=""  />
</p>
<p>Alice won’t broadcast the funding transaction until she has a valid signature
from Bob for her commitment transaction. Enter <code>funding_signed</code>:</p>
<p><img loading="lazy" src="/openChanPt1/funding_signed.png#center" alt=""  />
</p>
<p>Notice that this is the first message to use the real channel ID instead of the
temporary one.</p>
<p>This was the last piece of the puzzle for Alice. She now has all the info she
needs to be able to sign her commitment transaction if ever needed.</p>
<p><img loading="lazy" src="/openChanPt1/a1_4.png#center" alt=""  />
</p>
<p>Alice can now safely broadcast the funding transaction. Both she and Bob will
watch the chain for the confirmation of the funding transaction. Once it has
reached the <code>minimum_depth</code> specified by Bob in <code>accept_channel</code>, both sides
will exchange the <code>channel_ready</code> message (previously named <code>funding_locked</code>).
This message serves as both a signal to the peer to indicate to them that the
channel is ready for use (and that the channel announcement process can now
start if the peers decided on an announced channel) and also to send across each
peer’s <code>second_per_commitment_point</code> that they should use in their second
commitment transaction.</p>
<p><img loading="lazy" src="/openChanPt1/channel_ready.png#center" alt=""  />
</p>
<p>Ok cool! We have completed our first goal: Alice and Bob have opened a channel
between themselves in a trust-less way. Now we move on to step 2: announcing
this channel to the network!</p>
<h2 id="announcing-the-channel">Announcing the channel</h2>
<p>This part is fairly painless. Basically there is just one message,
<code>channel_announcement</code>, that Alice and Bob need to construct together and once
it is complete, then they can broadcast it to the network. Other nodes will use
this message to prove a few things:</p>
<ul>
<li>That the channel funding tx is actually an existing, unspent UTXO with an
acceptable number of confirmations.</li>
<li>That the funding transaction output actually looks like a lightning channel
funding transaction</li>
<li>That the channel is actually owned by the keys that Alice and Bob say they
used to construct the channel.</li>
<li>That Alice and Bob both agree on the message being broadcast.</li>
</ul>
<p>An incomplete version of the <code>channel_announcement</code> message looks as follows:</p>
<p><img loading="lazy" src="/openChanPt1/channel_announcement.png#center" alt=""  />
</p>
<p><code>h</code> is the hash of all the data that will be covered by the signatures. In order
to complete the message, Alice and Bob both compute a signature over <code>h</code> using
the private keys associated with their node IDs and the pubkeys they used in the
funding transaction. They then both exchange the <code>announcement_signatures</code>
message in order to communicate these signatures to each other:</p>
<p><img loading="lazy" src="/openChanPt1/announcement_sigs.png#center" alt=""  />
</p>
<p>Now both nodes can put together the complete <code>channel_announcement</code> message:</p>
<p><img loading="lazy" src="/openChanPt1/channel_announcement_2.png#center" alt=""  />
</p>
<p>Let’s go over the steps that a node (Charlie) receiving this message will go
through in order to verify the new channel that Alice and Bob claimed to have
opened.</p>
<ol>
<li>First, Charlie will use the <code>short_channel_id</code> included in the message to make sure
that the channel’s funding transaction actually exists on-chain, that it has a
sufficient number of confirmations and that it is in fact unspent.</li>
<li>Then, Charlie will also check that the unspent output actually does look like a
Lightning channel owned by <code>alice_pubkey_1</code> and <code>bob_pubkey_1</code>. He will do this
by using the advertised pubkeys to reconstruct the P2WSH and ensure that it is
the same as the one found on-chain.</li>
<li>Now, Charlie will want to confirm that the nodes owning the pubkeys found in the
channel funding output do in fact belong to the nodes owning the node ID
pubkeys. This is done by verifying the <code>alice_pubkey_1_sig</code> and
<code>bob_pubkey_1_sig</code> signatures. If these signatures are valid, then it is clear
that the owners of <code>alice_pubkey_1</code> and <code>bob_pubkey_1</code> agree to being associated
with <code>alice_node_ID</code> and <code>bob_node_ID</code> since the message signed includes these
nodes IDs.</li>
<li>Finally, Charlie will also want to ensure that owners of the node ID pubkeys
agree to being associated with the new channel. This is done by verifying the
<code>alice_node_ID_sig</code> and <code>bob_node_ID_sig</code> signatures. If these signatures are
valid, then it is clear that the owners of <code>alice_node_ID_sig</code> and
<code>bob_node_ID_sig</code> agree to being associated with <code>alice_pubkey_1</code> and
<code>bob_pubkey_1</code> since the message signed includes these pubkeys.</li>
</ol>
<p>Alice and Bob are done! Their channel is open and other nodes in the network,
like Charlie, will happily use the new channel.</p>
<p>In the next post, I will dive into how the above process will change with
taproot channels (given the current proposal). The main thing that will need to
change is how signatures are dealt with. In all the above cases, Alice and Bob
didn&rsquo;t really need to do anything special when they were generating their
signatures since they each would need to provide their own signature to sign for
the 2-of-2 funding transaction. But with taproot, the funding output will use
Musig2 to combine the pubkeys of Alice and Bob and so any signatures will need
to involve the Musig2 signing protocol… But let’s leave the details of that for
next time :)</p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p><a href="https://github.com/lightning/bolts/pull/995">https://github.com/lightning/bolts/pull/995</a>&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>
]]></content:encoded>
    </item>
    
    <item>
      <title>BIP158: Compact Block Filters Deep Dive</title>
      <link>https://www.ellemouton.com/posts/bip158/</link>
      <pubDate>Mon, 01 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.ellemouton.com/posts/bip158/</guid>
      <description>What even is Golomb-Rice Coding?</description>
      <content:encoded><![CDATA[<p>In this post, I will briefly describe the needs of a bitcoin light client and
why compact block filters satisfy these needs better than Bloom filters do. Then
I will dive into exactly how compact block filters work and will follow this
with a step by step guide for constucting such a filter from a testnet block.</p>
<h3 id="the-purpose-of-block-filters">The purpose of block filters</h3>
<p>A bitcoin light client is software that can back a bitcoin wallet without storing the blockchain. This means that it needs to be able to broadcast transactions to the network but most importantly it must be able to pick up when there is a new transaction that is relevant to the wallet it is backing. There are two ways a transaction becomes relevant to a wallet: either it is sending money to the wallet (creating a new output to a wallet address) or it is spending one of the UTXOs that the wallet owns.</p>
<h3 id="what-was-wrong-with-bloom-filters">What was wrong with Bloom filters?</h3>
<p>Before <a href="https://github.com/bitcoin/bips/blob/master/bip-0158.mediawiki">BIP 158</a> came along, the most widely used method for light clients was to use Bloom filters<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup> as described in <a href="https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki">BIP 37</a>. With a bloom filter, you take all the objects you are interested in (script pub keys spent or created), hash them a couple times and add the result of each to a bit map called a Bloom filter. This filter represents what you are interested in. You would then send this filter to a trusted bitcoin node and ask them to send you anything that matches your filter. The problem with this is that it is not very private since you are revealing some information to the bitcoin node you are sending this filter too. They can start getting an idea of the transactions you are interested in as well as the ones you are definitely not interested in. They can also just decide not to send you a transaction that matches the filter. So as you can see, it isn’t great for the light client. But it is also not great for the bitcoin node serving the light client. Each time you send them a filter, they have to load the relevant block from disk and determine which transactions match your filter. You could just spam them with fake filters and effectively DOS them. It takes very little energy to create a filter and lots to respond to it.</p>
<h3 id="introducing-compact-block-filters">Introducing Compact Block Filters:</h3>
<p>Ok, take two. What we want is:</p>
<ul>
<li>More privacy</li>
<li>Less asymmetry in the client - server work load. Ie, the server should be required to do way less work.</li>
<li>Less trust. The light client shouldn&rsquo;t need to worry about the server holding back relevant transactions.</li>
</ul>
<p>With compact block filters, the server (full node) will for each block construct a deterministic filter that includes all the objects in the block. This filter can be calculated once and persisted. If light clients request a filter for a block, there is no asymmetry since the server wont have to do any more work than the client had to do when making the request.  A light client can also choose to download the filters from multiple sources to ensure they match and can always download the full block and check for itself if the filter that the server provided was indeed correct given the blocks contents. Another bonus is that this is way more private. The light client no longer sends a fingerprint of the data it is interested in to the server. And so it becomes way more difficult to analyse the light client&rsquo;s activity. The light client gets these filters from the server and checks for itself if any of its objects match what is seen in the filter and if it does match, then the light client asks for the full block. One thing to note with this way of doing things is that full nodes serving the light clients will need to persist these filters and the light clients might also want to persist a few filters and so it is important that the filters are as small as possible (hence the name, compact block filters).</p>
<p>Cool! Now we get to the cool stuff. How is this filter created? What does it look like?</p>
<p>What do we want?</p>
<ul>
<li>We want to put fingerprints of certain objects in the filter so that when clients are looking to see if a block maybe contains info relevant to them, they can take all their objects and check if the filter matches on those objects.</li>
<li>We want the filters to be as small as possible.</li>
<li>Effectively we want to sort of summarise some of the block info… in a size much much smaller than the block.</li>
</ul>
<p>The info included in the basic filter is: every transaction&rsquo;s input&rsquo;s scriptPubKey being spent and every transaction&rsquo;s output&rsquo;s scriptPubKey being created. So something like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">objects</span> = {<span style="color:#a6e22e">spk1</span>, <span style="color:#a6e22e">spk2</span>, <span style="color:#a6e22e">spk3</span>, <span style="color:#a6e22e">spk4</span>, <span style="color:#f92672">...</span>, <span style="color:#a6e22e">spkN</span>} <span style="color:#75715e">// A list of N scriptPubKeys.
</span></span></span></code></pre></div><p>Technically we could just stop here and say this list of scriptPubKeys is our filter. It is a condensed version of what is in the block chain and contains the info the light client needs. With this list they could tell with 100% certainty if something they are interested in is in the block. But it is still pretty big. So the next step is all about making this list as compact as possibly. This is where things get insanely cool.</p>
<p>First we convert each object into a number in a range such that the object numbers are uniformly distributed in that range:
Let&rsquo;s say we have 10 objects (N = 10), then we have some function that turns each of the objects into a number. Let’s say we chose the range [0, 10] since we have 10 objects. Now the hashing-plus-convert-to-number function we use will take each object and produce a number in the space from [0, 10]. It is uniformly distributed in this space. That means that, after ordering them, we will get (in the very very ideal case) something like this:</p>
<p><img loading="lazy" src="/bip158/dense.jpeg#center" alt=""  />
</p>
<p>First of all, wow that is so great cause we have drastically decreased the size of an objects finger print. Each one is just a number now. Ok so, let this be our new filter:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">numbers</span> <span style="color:#f92672">:=</span> {<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">5</span>,<span style="color:#ae81ff">6</span>,<span style="color:#ae81ff">7</span>,<span style="color:#ae81ff">8</span>,<span style="color:#ae81ff">9</span>,<span style="color:#ae81ff">10</span>}
</span></span></code></pre></div><p>Now a light client downloads the filter and wants to see if one of the objects they are looking for is matched in this filter. All they need to do is take their objects and do the same hashing-plus-convert-to-number scheme and check if any of the numbers are in the filter. What is the problem? The filter has a number for each possible number in the space! Meaning that absolutely any object will match on this filter. In other words, the false-positive rate of this filter is 1. This is no good. We have lost too much info on our quest to compress the data in the filter. What we need is a higher false-positive (fp) rate. Ok so let’s say we want a false positive rate of 5. Then what we want is to have our objects be mapped uniformly to a space of [0, 50]:</p>
<p><img loading="lazy" src="/bip158/sparse.png#center" alt=""  />
</p>
<p>This is starting to look a bit better. If I am a client downloading this filter and I check if my objects are maybe in the filter, there will be a 1/5 chance that if it matches, it is a false positive. Great so now we have mapped 10 objects to numbers between 0 &amp; 50. This new list of numbers is our filter. Again, we could stop here… but we can compress this even further!!</p>
<p>We have this list of ordered numbers that we know are distributed uniformly across this space between [0, 50]. We know that there are 10 items in the list. What this means is that we can deduce that the most likely <em>difference</em> between each of the numbers in this ordered list is about 5. In general, if we have N items and a false positive rate of M, then the space will be of size N * M. So the numbers in the space can range from 0 to N * M, but the difference between each number (once ordered) will be roughly M. M will definitely be a smaller number to store than a number in the N * M space. So what we can do is instead of storing each number, we can instead store the difference of each successive number. In the above case, this would mean that instead of storing <code>[0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50]</code>, we just store <code>[0, 5, 5, 5, 5, 5, 5, 5, 5, 5]</code> and then it is trivial to reconstruct the original list. As you can gather, storing the number 50 requires way more bits than storing the number 5. But why stop there? We can compress this even further!</p>
<p>This is where Golomb-Rice Coding comes in. This encoding works well for a list of numbers that will all very likely be close to some number. This is what we have! We have a list of numbers that will all very likely be close to 5 (or, in general, close to our FP rate of M) and so taking the quotient of any number in the list with that number (dividing each number by 5 and ignoring the remainder) will very likely be 0 (if the number is slightly less than 5) or 1 if the number is slight more than 5. The quotient could be 2, 3 etc but the likelihood decreases a lot. Great! So we can take advantage of this knowledge and say that we will encode a small quotient with the smallest number of bits that we can and use more bits to encode larger, unlikely, quotients. Then we also need to encode the remainders (since we want to be able to reconstruct the values exactly) and these will always be numbers between [0, M-1] (in our case, [0, 4]). For encoding the quotients, we use the following mapping:</p>
<p><img loading="lazy" src="/bip158/quotient.png#center" alt=""  />
</p>
<p>The mapping above is easy to read: The number of <code>1</code>s indicates the quotient we are encoding and the <code>0</code> indicates the end of the quotient encoding. So for each number in our list, we encode the quotient using the above table and then we convert the remainder to binary using the number of bits needed to encode the maximum of M-1. In our case, that is 3 bits. Here is a table showing the encoding of the possible remainders in our example:</p>
<p><img loading="lazy" src="/bip158/remainder.png#center" alt=""  />
</p>
<p>So, in our ideal case example, our list of <code>[0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]</code> can be encoded as follows:</p>
<pre tabindex="0"><code>0000 10000 10000 10000 10000 10000 10000 10000 10000 10000
</code></pre><p>Before we move on to a more realistic example, let’s see if we can reconstruct our original list from this filter.</p>
<p>Ok so we have: “0000100001000010000100001000010000100001000010000”. We know the how Golomb-Rice Coding encodes quotients and we also know that M is 5 (since this will be public knowledge known to everyone using this filter construction). Since we know M is 5, we know that 3 bits will be used to encode the remainders. So we can take our filter and produce the following quotient-remainder tuples:</p>
<pre tabindex="0"><code>[(0, 0), (1, 0), (1, 0), (1, 0), (1, 0), (1, 0), (1, 0), (1, 0), (1, 0), (1, 0)]
</code></pre><p>We know that the quotients were produced by dividing number by M (5), so we can reconstruct these:</p>
<pre tabindex="0"><code>[0, 5, 5, 5, 5, 5, 5, 5, 5, 5]
</code></pre><p>And we know that this list represents differences of numbers, so we can reconstruct the OG list:</p>
<pre tabindex="0"><code>[0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50]
</code></pre><h3 id="a-more-realistic-example">A more realistic example</h3>
<p>We will now try to construct a filter from an actual Bitcoin testnet block. I&rsquo;m going to use block <a href="https://blockstream.info/testnet/block/000000000000002c06f9afaf2b2b066d4f814ff60cfbc4df55840975a00e035c">2101914</a>. Let’s see what it’s actual filter is:</p>
<pre tabindex="0"><code>$ bitcoin-cli getblockhash 2101914
000000000000002c06f9afaf2b2b066d4f814ff60cfbc4df55840975a00e035c

$ bitcoin-cli getblockfilter 000000000000002c06f9afaf2b2b066d4f814ff60cfbc4df55840975a00e035c
{
  &#34;filter&#34;: &#34;5571d126b85aa79c9de56d55995aa292de0484b830680a735793a8c2260113148421279906f800c3b8c94ff37681fb1fd230482518c52df57437864023833f2f801639692646ddcd7976ae4f2e2a1ef58c79b3aed6a705415255e362581692831374a5e5e70d5501cdc0a52095206a15cd2eb98ac980c22466e6945a65a5b0b0c5b32aa1e0cda2545da2c4345e049b614fcad80b9dc9c903788163822f4361bbb8755b79c276b1cf7952148de1e5ee0a92f6d70c4f522aa6877558f62b34b56ade12fa2e61023abf3e570937bf379722bc1b0dc06ffa1c5835bb651b9346a270&#34;,
  &#34;header&#34;: &#34;8d0cd8353342930209ac7027be150e679bbc7c65cc62bb8392968e43a6ea3bfe&#34;
}
</code></pre><p>Ok shweeeeeet, let’s see if we can reconstruct this filter from the block.</p>
<p>The full code for this can be found in this <a href="https://github.com/ellemouton/bip158Example">github repo</a>. I will just show some pseudo code snippets here. The beef of the code is the function called <code>constructFilter</code> which takes in a bitcoin client that can be used to make calls to bitcoind and the block in question. The function looks something like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">constructFilter</span>(<span style="color:#a6e22e">bc</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">bitcoind</span>.<span style="color:#a6e22e">Bitcoind</span>, <span style="color:#a6e22e">block</span> <span style="color:#a6e22e">bitcoind</span>.<span style="color:#a6e22e">Block</span>) ([]<span style="color:#66d9ef">byte</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 1. Collect all the objects from the block that we want to add to the filter
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 2. Convert all the objects to numbers and sort them. 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 3. Get the differences between the sorted numbers
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 4. Encode these differences using Golomb-Rice Coding
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>Ok so step 1 is to collect all the objects from the block that we want to add to the filter. From the BIP, we know that these objects are all the scriptPubKeys being spent as well as all the scriptPubKeys of each output. Some extra rules from the BIP are that we skip the input for the coinbase transaction (since it is empty and meaningless) and we skip any OP_RETURN outputs. We also de-duplicate the data. So if there are two identical scriptPubKeys, we only include one in the filter.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// The list of objects we want to include in our filter. These will be
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// every scriptPubKey being spent as well as each output&#39;s scriptPubKey.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// We use a map so that we can dedup any duplicate scriptPubKeys.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">objects</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>] <span style="color:#66d9ef">struct</span>{})
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Loop over every transaction in the block.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">tx</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">block</span>.<span style="color:#a6e22e">Tx</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Add the scriptPubKey of each of the transaction&#39;s outputs
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// and add those to our list of objects.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">txOut</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">tx</span>.<span style="color:#a6e22e">Vout</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">scriptPubKey</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">txOut</span>.<span style="color:#a6e22e">ScriptPubKey</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">scriptPubKey</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// We don&#39;t add the output if it is an OP_RETURN (0x6a).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">spk</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x6a</span> {
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">objects</span>[<span style="color:#a6e22e">skpStr</span>] = <span style="color:#66d9ef">struct</span>{}{}
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// We don&#39;t add the inputs of the coinbase transaction.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// For each input, go and fetch the scriptPubKey that it is
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// spending.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">txIn</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">tx</span>.<span style="color:#a6e22e">Vin</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">prevTx</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">bc</span>.<span style="color:#a6e22e">GetRawTransaction</span>(<span style="color:#a6e22e">txIn</span>.<span style="color:#a6e22e">Txid</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">scriptPubKey</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">prevTx</span>.<span style="color:#a6e22e">Vout</span>[<span style="color:#a6e22e">txIn</span>.<span style="color:#a6e22e">Vout</span>].<span style="color:#a6e22e">ScriptPubKey</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">scriptPubKey</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">objects</span>[<span style="color:#a6e22e">spkStr</span>] = <span style="color:#66d9ef">struct</span>{}{}
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Ok great, we have all the objects we care about. And now we can also define the variable N to be the length of the <code>objects</code> map. In this example, N is 85.</p>
<p>The next step is to convert each of the objects to numbers spread uniformly across a range. Remember that this range depends on the false-positive rate we want. BIP158 defines the constant M to be 784931. This means that we want every 1/784931 matches to be a false-positive. As we did in our earlier example, we take this fp rate of M and multiply it by N to get the range that we want all our numbers to lie in. We define this as F where F = M*N. In our case, we have 85 objects and so F=66719135. I am not going to go into the details of the function used to map our objects to numbers (you can check out the details of this in the code in the linked repo). All you need to know for now is that it takes in an object, the constant F which defines the range that it needs to map the object to, and a key which is the block hash. Once we have all the numbers, we sort the list in ascending order and then we also create a new list called <code>differences</code> which will hold the differences between each sequential number in the sorted <code>numbers</code> list.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">numbers</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">uint64</span>, <span style="color:#ae81ff">0</span>, <span style="color:#a6e22e">N</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Iterate over all the objects, convert them to numbers lying uniformly in the range [0, F]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// and add them to the `numbers` list.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> <span style="color:#a6e22e">o</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">objects</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Using the given key, max number (F) and object bytes (o),
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// convert the object to a number between 0 and F.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">convertToNumber</span>(<span style="color:#a6e22e">b</span>, <span style="color:#a6e22e">F</span>, <span style="color:#a6e22e">key</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">numbers</span> = append(<span style="color:#a6e22e">numbers</span>, <span style="color:#a6e22e">v</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Sort the numbers.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">sort</span>.<span style="color:#a6e22e">Slice</span>(<span style="color:#a6e22e">numbers</span>, <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">j</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">bool</span> { <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">numbers</span>[<span style="color:#a6e22e">i</span>] &lt; <span style="color:#a6e22e">numbers</span>[<span style="color:#a6e22e">j</span>] })
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Convert the list of numbers to a list of differences.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">differences</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">uint64</span>, <span style="color:#a6e22e">N</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">num</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">numbers</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">differences</span>[<span style="color:#a6e22e">i</span>] = <span style="color:#a6e22e">num</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">differences</span>[<span style="color:#a6e22e">i</span>] = <span style="color:#a6e22e">num</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">numbers</span>[<span style="color:#a6e22e">i</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Awesome! Here is a graph showing the values in the <code>numbers</code> and <code>differences</code> lists:</p>
<p><img loading="lazy" src="/bip158/bitcoinExample.png#center" alt=""  />
</p>
<p>As you can see, the 85 numbers are really nicely uniformly distributed across the space! And this results in the values in the <code>differences</code> list being pretty small.</p>
<p>The last step now is to use Golomb-Rice Coding to encode this <code>differences</code>
list. Recall from the earlier explanation that we need to divide each difference
by it’s most likely value and then we encode that quotient along with the
remainder. In my earlier example I said that this most-likely value would be the
M that we choose and that the remainder would then lie in the range [0, M].
However, this is not what is done in the BIP as it was found<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup> that
this is in fact not the ideal way to choose the Golomb-Rice coder parameter when
trying to optimize for the smallest possible size of the final encoded filter.
And so instead of using M, a new constant of P is defined and P^2 is used as the
Golomb-Rice parameter. P is defined as 19. This means that each difference value
is divided by 2^19 to get the quotient and remainder and the remainder is then
encoded in binary in 19 bits.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">filter</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">bstream</span>.<span style="color:#a6e22e">NewBStreamWriter</span>(<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// For each number in the differences list, calculate the quotient and
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// remainder after dividing by 2^P.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">d</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">differences</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">q</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Floor</span>(float64(<span style="color:#a6e22e">d</span>)<span style="color:#f92672">/</span><span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Exp2</span>(float64(<span style="color:#a6e22e">P</span>)))
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">r</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">d</span> <span style="color:#f92672">-</span> uint64(<span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Exp2</span>(float64(<span style="color:#a6e22e">P</span>))<span style="color:#f92672">*</span><span style="color:#a6e22e">q</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Encode the quotient.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; int(<span style="color:#a6e22e">q</span>); <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>               <span style="color:#a6e22e">filter</span>.<span style="color:#a6e22e">WriteBit</span>(<span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">filter</span>.<span style="color:#a6e22e">WriteBit</span>(<span style="color:#66d9ef">false</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">filter</span>.<span style="color:#a6e22e">WriteBits</span>(<span style="color:#a6e22e">r</span>, <span style="color:#a6e22e">P</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Great stuff! Now when we print out this filter, we get:</p>
<pre tabindex="0"><code>71d126b85aa79c9de56d55995aa292de0484b830680a735793a8c2260113148421279906f800c3b8c94ff37681fb1fd230482518c52df57437864023833f2f801639692646ddcd7976ae4f2e2a1ef58c79b3aed6a705415255e362581692831374a5e5e70d5501cdc0a52095206a15cd2eb98ac980c22466e6945a65a5b0b0c5b32aa1e0cda2545da2c4345e049b614fcad80b9dc9c903788163822f4361bbb8755b79c276b1cf7952148de1e5ee0a92f6d70c4f522aa6877558f62b34b56ade12fa2e61023abf3e570937bf379722bc1b0dc06ffa1c5835bb651b9346a270
</code></pre><p>Apart from the first two bytes, this matches the filter we got from bitcoind exactly! Why the 2 byte difference? The BIP says that the N value needs to be encoded in CompactSize format and appended to the front of the filter so that it can be decoded by the receiver. This is done as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">fd</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">filter</span>.<span style="color:#a6e22e">Bytes</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">buffer</span> <span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">Buffer</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">buffer</span>.<span style="color:#a6e22e">Grow</span>(<span style="color:#a6e22e">wire</span>.<span style="color:#a6e22e">VarIntSerializeSize</span>(uint64(<span style="color:#a6e22e">N</span>)) <span style="color:#f92672">+</span> len(<span style="color:#a6e22e">fd</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">wire</span>.<span style="color:#a6e22e">WriteVarInt</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">buffer</span>, <span style="color:#ae81ff">0</span>, uint64(<span style="color:#a6e22e">N</span>))
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">buffer</span>.<span style="color:#a6e22e">Write</span>(<span style="color:#a6e22e">fd</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>If we print out the filter now, we get one that matches the one we got from bitcoind exactly:</p>
<pre tabindex="0"><code>5571d126b85aa79c9de56d55995aa292de0484b830680a735793a8c2260113148421279906f800c3b8c94ff37681fb1fd230482518c52df57437864023833f2f801639692646ddcd7976ae4f2e2a1ef58c79b3aed6a705415255e362581692831374a5e5e70d5501cdc0a52095206a15cd2eb98ac980c22466e6945a65a5b0b0c5b32aa1e0cda2545da2c4345e049b614fcad80b9dc9c903788163822f4361bbb8755b79c276b1cf7952148de1e5ee0a92f6d70c4f522aa6877558f62b34b56ade12fa2e61023abf3e570937bf379722bc1b0dc06ffa1c5835bb651b9346a270
</code></pre><p>Yay!</p>
<p>However, from my understanding, there is no need to add N to the filter. If you know the value of P, then you can figure out the value of N. Let’s do this now by seeing if we can take the filter above, and reconstruct the original list of numbers:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">bstream</span>.<span style="color:#a6e22e">NewBStreamReader</span>(<span style="color:#a6e22e">filter</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">numbers</span> []<span style="color:#66d9ef">uint64</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">prevNum</span> <span style="color:#66d9ef">uint64</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Read a quotient from the stream. Read until we encounter
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// a &#39;0&#39; bit indicating the end of the quotient. The number of 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// &#39;1&#39;s we encounter before reaching the &#39;0&#39; defines the 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// quotient.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">q</span> <span style="color:#66d9ef">uint64</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">c</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">ReadBit</span>()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">c</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">q</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">c</span>, <span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">ReadBit</span>()
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">errors</span>.<span style="color:#a6e22e">Is</span>(<span style="color:#a6e22e">err</span>, <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">EOF</span>) {
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>                } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// The following P bits are the remainder encoded as binary.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">r</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">ReadBits</span>(<span style="color:#a6e22e">P</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">errors</span>.<span style="color:#a6e22e">Is</span>(<span style="color:#a6e22e">err</span>, <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">EOF</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">n</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">q</span><span style="color:#f92672">*</span>uint64(<span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Exp2</span>(float64(<span style="color:#a6e22e">P</span>))) <span style="color:#f92672">+</span> <span style="color:#a6e22e">r</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">num</span> <span style="color:#f92672">:=</span>  <span style="color:#a6e22e">n</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">prevNum</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">numbers</span> = append(<span style="color:#a6e22e">numbers</span>, <span style="color:#a6e22e">num</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">prevNum</span> = <span style="color:#a6e22e">num</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">numbers</span>)
</span></span></code></pre></div><p>The above produces the same list of numbers that we had before and we were able to reconstruct this without the knowledge of N. So I am not sure why it was decided that N should be added to the filter. If anyone knows why it was required to add N to the filter, please let me know!</p>
<p>Cool, that was fun! Thanks for reading. Yeeeeet!</p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p><a href="https://en.wikipedia.org/wiki/Bloom_filter">https://en.wikipedia.org/wiki/Bloom_filter</a>&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p><a href="https://gist.github.com/sipa/576d5f09c3b86c3b1b75598d799fc845">https://gist.github.com/sipa/576d5f09c3b86c3b1b75598d799fc845</a>&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>
]]></content:encoded>
    </item>
    
    <item>
      <title>LN Things Part 5: HTLC Deep Dive</title>
      <link>https://www.ellemouton.com/posts/htlc-deep-dive/</link>
      <pubDate>Sat, 27 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.ellemouton.com/posts/htlc-deep-dive/</guid>
      <description>Day 7 of #7DaysOfBitcoin</description>
      <content:encoded><![CDATA[<p>In previous post gave a simplified overview of HTLCs. This post will look in more detail at what these HTLCs actually look like and how they fit in the commitment transactions.</p>
<p>From <a href="/updating-state"><em>Part 2</em></a> on the Update layer, we learned a few things about how commitment transactions are done:</p>
<p>First of all, they are asymmetric: Alice and Bob (the two participants of a channel) each hold their own commitment transactions.
The commitment transactions that each participant holds looks slightly different to that of their peer in that any output going to the local node must be encumbered by a relative time lock of <code>to_self_delay</code>. This is to give the other party a chance to spend along the revocation path of the output if they need.</p>
<p>Given the above requirements of a commitment transaction, let’s look at how HTLC’s will fit into all of this. To do this, let’s use the example from the previous post where Alice is sending 2 BTC to a recipient and is using her channel with Bob as the first hop in the route (he might even be the final recipient). Remember that Alice has been given a hash, <code>H</code>, to which she needs to pay. In this example, Alice is the HTLC offerer and Bob is the HTLC receiver.</p>
<h3 id="zooming-in-on-alice">Zooming in on Alice:</h3>
<p>Let’s zoom in on how Alice will construct her commitment transaction to now include the HTLC. The commitment transaction will have three outputs:</p>
<ul>
<li>One 5 BTC output to Bob (spendable immediately).</li>
<li>One 3 BTC output with two possible spending paths: One spendable by Alice after a <code>to_self_delay</code> and one immediately spendable by Bob if he has the required revocation key (see post 2 and post 3 for more details on revocation).</li>
<li>One 2 BTC output with…. ok so here is where it gets tricky. Let’s think about what needs to be here a bit.</li>
</ul>
<p><img loading="lazy" src="/lnThings/day7_1.png#center" alt=""  />
</p>
<p>This output is where the HTLC magic must happen. We need the following spending paths on this output:</p>
<ul>
<li>It needs to be spendable by Bob if he has the pre-image of <code>H</code> (hash-locked path)</li>
<li>Or spendable by Alice after <code>cltv_expiry</code></li>
<li>Or spendable by Bob immediately if he has the revocation key</li>
</ul>
<p>BUT remember that Alice’s outputs to herself must always have a relative timelock of <code>to_self_delay</code> even after <code>cltv_expiry</code>. Knowing this, let’s update the HTLC spending paths a bit:</p>
<ul>
<li>It needs to be spendable by Bob if he has the pre-image of <code>H</code> (hash-locked path)</li>
<li>Or spendable by Alice after absolute time <code>cltv_expiry</code> AND after relative delay <code>to_self_delay</code></li>
<li>Or spendable by Bob immediately if he has the revocation key</li>
</ul>
<p>There is still a problem: Making the output to Alice encumbered by both these timelocks could in the worst case extend the HTLC’s timeout by <code>to_self_delay</code>. In other words, Bob could have an extra <code>to_self_delay</code> blocks in order to sweep the hash-locked output even though the HTLC is technically expired. So what is done instead is that instead having this output being locked by both timelock conditions, it is instead only locked by just the <code>cltv_expiry</code> one and then instead of sending funds to Alice directly, the funds are instead sent to a separate HTLC-timeout transaction (signed by both Alice and Bob) and this separate time out transaction then enforces the <code>to_self_delay</code>. This allows Alice to definitively lock in the fact that the HTLC has expired and removes Bob’s ability to claim the hash-locked output all while still ensuring that Alice can only get her funds after <code>to_self_delay</code> and thus still allow Bob to spend from the revocation path (of the HTLC-timeout transaction) if needed.</p>
<p>The final state of the commitment transaction’s HTLC output spending paths is as follows:</p>
<ul>
<li>One spending path to Bob if he pre-image of <code>H</code> (hash-locked path)</li>
<li>One spending path to Bob if he has the revocation key.</li>
<li>One spending path to a second-state HTLC-timeout transaction.</li>
</ul>
<p>The HTLC-timeout transaction has the following construction:</p>
<ul>
<li>The transaction itself is timelocked with <code>nLocktime</code> set to <code>cltv_expiry</code>. Thus the spending path in the original commitment transaction that sends to this HTLC-timeout transaction is effectively time delayed by <code>cltv_expiry</code>.</li>
<li>The transaction has one output with two possible spending paths:
<ul>
<li>one to Alice after <code>to_self_delay</code></li>
<li>one to Bob if he can provide the revocation key.</li>
</ul>
</li>
</ul>
<p><img loading="lazy" src="/lnThings/day7_2.png#center" alt=""  />
</p>
<p>The Script for Alices (the HTLC offerer) commitment transaction’s HTLC output looks as follows:</p>
<pre tabindex="0"><code># To remote node with revocation key
OP_DUP OP_HASH160 &lt;RIPEMD160(SHA256(revocationpubkey))&gt; OP_EQUAL
OP_IF
    OP_CHECKSIG
OP_ELSE
    &lt;remote_htlcpubkey&gt; OP_SWAP OP_SIZE 32 OP_EQUAL
    OP_NOTIF
        # To local node via HTLC-timeout transaction (timelocked).
        OP_DROP 2 OP_SWAP &lt;local_htlcpubkey&gt; 2 OP_CHECKMULTISIG
    OP_ELSE
        # To remote node with preimage.
        OP_HASH160 &lt;RIPEMD160(payment_hash)&gt; OP_EQUALVERIFY
        OP_CHECKSIG
    OP_ENDIF
OP_ENDIF
</code></pre><p>You can see in the script above that the first path is the revocation path, the second is the path to the HTLC-timeout transaction (the time-locked path) and the third is the hash-locked spending path.</p>
<p>The HTLC-timeout transaction output script looks as follows:</p>
<pre tabindex="0"><code>OP_IF
    # Penalty transaction
    &lt;revocationpubkey&gt;
OP_ELSE
    `to_self_delay`
    OP_CHECKSEQUENCEVERIFY
    OP_DROP
    &lt;local_delayedpubkey&gt;
OP_ENDIF
OP_CHECKSIG
</code></pre><h3 id="zooming-in-on-bob">Zooming in on Bob:</h3>
<p>Let’s now zoom in on how Bob (the HTLC receiver) will construct his commitment transaction to include the HTLC. The commitment transaction will have three outputs:</p>
<ul>
<li>One 3 BTC output to Alice (spendable immediately).</li>
<li>One 5 BTC output with two possible spending paths: One spendable by Bob after a <code>to_self_delay</code> and one immediately spendable by Alice if she has the required revocation key</li>
<li>Again the 2 BTC output on Bob’s commitment transaction is a bit complicated. Let’s dive in.</li>
</ul>
<p><img loading="lazy" src="/lnThings/day7_3.png#center" alt=""  />
</p>
<p>Let’s again think about what spending paths this output should have:</p>
<ul>
<li>There should be a spending path that Bob can claim if he has the pre-image of <code>H</code> (hash-locked path) but since it is an output to himself it needs to have a <code>to_self_delay</code>.</li>
<li>One spending path should be spendable by Alice immediately by Alice if she has the necessary revocation key.</li>
<li>One spending path also needs to be spendable by Alice after <code>cltv_expiry</code> (time-locked output).</li>
</ul>
<p>The problem with having all the above spending paths in the same script is that if Bob knows the pre-image but now has to wait <code>to_self_delay</code> blocks in order to spend from the hash-locked path then there is a chance that this <code>to_self_delay</code> is longer than the <code>cltv_expiry</code> that Alice must wait in order to claim the time-locked path. So Alice could potentially spend along the time-locked even though Bob does have the pre-image. Similar to the situation with Alices commitment transaction, Bob needs a way to lock in the fact that the hash-locked path will be used while still delaying his redemption of the funds by <code>to_self_delay</code>. So, a separate HTLC-success transaction is used for this thus allowing Bob to spend from the hash-locked path to this HTLC-success transaction which will then separately enforce the <code>to_self_delay</code> condition.</p>
<p>The final state of the commitment transaction’s HTLC output spending paths is as follows:</p>
<ul>
<li>One spending path to Alice if she has the revocation key (revocation path)</li>
<li>One spending path to Alice after <code>cltv_expiry</code> (time-locked path)</li>
<li>One spending path to the HTLC-success transaction IF Bob can reveal the pre-image of <code>H</code> (hash-locked path).</li>
</ul>
<p>The HTLC-timeout transaction has the following construction:</p>
<ul>
<li>The transaction is not time locked (unlike in Alice’s case).</li>
<li>The transaction has one output with two possible spending paths:
<ul>
<li>one to Bob after <code>to_self_delay</code></li>
<li>one to Alice if she can provide the revocation key.</li>
</ul>
</li>
</ul>
<p><img loading="lazy" src="/lnThings/day7_4.png#center" alt=""  />
</p>
<p>The Script for Bob’s (the HTLC receiver) commitment transaction’s HTLC output looks as follows:</p>
<pre tabindex="0"><code># To remote node with revocation key
OP_DUP OP_HASH160 &lt;RIPEMD160(SHA256(revocationpubkey))&gt; OP_EQUAL
OP_IF
    OP_CHECKSIG
OP_ELSE
    &lt;remote_htlcpubkey&gt; OP_SWAP OP_SIZE 32 OP_EQUAL
    OP_IF
        # To local node via HTLC-success transaction.
        OP_HASH160 &lt;RIPEMD160(payment_hash)&gt; OP_EQUALVERIFY
        2 OP_SWAP &lt;local_htlcpubkey&gt; 2 OP_CHECKMULTISIG
    OP_ELSE
        # To remote node after timeout.
        OP_DROP &lt;cltv_expiry&gt; OP_CHECKLOCKTIMEVERIFY OP_DROP
        OP_CHECKSIG
    OP_ENDIF
OP_ENDIF
</code></pre><p>You can see in the script above that the first path is the revocation path, the second is the path to the HTLC-timeout transaction (and is also the hash-locked path) and the third is the time-locked spending path.</p>
<p>The HTLC-timeout transaction output script looks as follows:</p>
<pre tabindex="0"><code>OP_IF
    # Penalty transaction
    &lt;revocationpubkey&gt;
OP_ELSE
    `to_self_delay`
    OP_CHECKSEQUENCEVERIFY
    OP_DROP
    &lt;local_delayedpubkey&gt;
OP_ENDIF
OP_CHECKSIG
</code></pre><h3 id="all-together-now">All together now:</h3>
<p>The final construction looks as follows:</p>
<p><img loading="lazy" src="/lnThings/day7_5.png#center" alt=""  />
</p>
<p>Yeeeeet!</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>LN Things Part 4: HTLC Overview</title>
      <link>https://www.ellemouton.com/posts/htlc/</link>
      <pubDate>Fri, 26 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.ellemouton.com/posts/htlc/</guid>
      <description>Day 6 of #7DaysOfBitcoin</description>
      <content:encoded><![CDATA[<p>The previous 2 posts were all about sending funds between the two participants of a channel (agreeing on current state and invalidating older state). This post will give an overview of HTLCs and how they allow multi-hop payments to be made. The next post will be a deep dive into exactly what these HTLCs look like and how they fit into the commitment transactions of a channel.</p>
<p>Let’s look at a simple example.</p>
<h3 id="simple-3-node-2-hop-network">Simple 3 node, 2 hop network:</h3>
<p>In this example, the network is make up of three nodes (Alice, Bob and Charlie) and there are two channels set up: One between Alice and Bob and another between Bob and Charlie. Each channel has a capacity of 10 BTC and to start with the funds of each channel will be divided equally between the participants.</p>
<p><img loading="lazy" src="/lnThings/htlc1.png#center" alt=""  />
</p>
<p>For the purposes of this overview of HTLCs, the commitment transactions describing the channels will be shown as they are in the diagram above, with one commitment transaction spending from the funding transaction and hence determining the channel state. This is not accurately representing the asymmetric construction described in post 2 but it will make the overview easier to understand. A more accurate description will be given in a later post.</p>
<p>Suppose that Alice would like to pay Charlie. She cant pay him directly since they do not have a shared channel and it is costly (in terms of time and money) to open a channel just for the purposes of a quick transaction. Instead, Alice can use her channel with Bob to route a payment to Charlie since Bob has a channel with Charlie.</p>
<h3 id="step-1--generating-and-sharing-the-pre-image-hash">Step 1:  Generating and sharing the pre-image hash</h3>
<p>Alice first needs to tell Charlie that she wants to pay him. Charlie will then generate a random secret, <code>S</code>, and get the hash of <code>S</code> which we will call <code>H</code>. Charlie then sends <code>H</code> to Alice.</p>
<p><img loading="lazy" src="/lnThings/htlc2.png#center" alt=""  />
</p>
<p>Step 2: Setting up the chain of HTLCs</p>
<p>Let’s say that Alice wants to pay Charlie 1 BTC. She will then find a route to Charlie (A-B-C) and will see that in order to use this route she will need to incentivise Bob to help her out by paying him a routing fee. In this example Bob charges a flat fee of 1 BTC for routing payments and so Alice will be paying a total of 2 BTC: 1 BTC for routing and 1 BTC for the recipient, Charlie. Alice then communicates with Bob that she would like to route a payment through him and does this by suggesting that they update their channel’s commitment transaction to have the following outputs (remember this is overly simplified and in reality both Alice and Bob will have their own commitment transactions):</p>
<ul>
<li>An output of 3 BTC back to Alice</li>
<li>An output of 5 BTC to Bob</li>
<li>An output of 2 BTC to a special script that has 2 possible spending paths: The first path can be spent by Bob if he has the pre-image of <code>H</code>. The second path can be spent by Alice after an absolute time <code>cltv_expiry_AB</code>. This special script that locks up the 2 BTC is called a Hash and Time Locked Contract (HTLC) because it has one hash-locked path and one time-locked path.</li>
</ul>
<p>Bob will be happy to update to this new channel state because he can see that he is not loosing money (if the transaction goes on-chain and he still does not have the pre-image then he still gets back his original funds). And he can see that if he co-operates and continues with the payment forwarding process then he will be rewarded with a routing fee if the payment is successful because he will be able to claim the hash-locked output on the transaction.</p>
<p><img loading="lazy" src="/lnThings/htlc3.png#center" alt=""  />
</p>
<p>Bob then goes ahead and locks up some of his funds in a similar way in his channel with Charlie. He updates the channel commitment transaction to have the following outputs:</p>
<ul>
<li>An output of 4 BTC to Bob</li>
<li>An output of 5 BTC to Charlie</li>
<li>An output of 1 BTC to an HTLC script that again has 2 spending paths: one spendable by Charlie if he can reveal the pre-image of <code>H</code> and one to Bob spendable after <code>cltv_expiry_BC</code>.</li>
</ul>
<p>Bob is confident in locking his liquidity up in this way because if the payment fails then he will be able to claim his funds back along the HTLC’s time-locked path and if the payment is successful and the pre-image is revealed by Charlie when he spends along the hash-locked path then Bob will see this pre-image and will be able to claim the hashed-lock output in HTLC output from the commitment transaction he has with Alice.</p>
<p><img loading="lazy" src="/lnThings/htlc4.png#center" alt=""  />
</p>
<p>When Charlie receives this HTLC offer from Bob, he can see that he in fact does know the pre-image, <code>S</code>, that hashes to <code>H</code> and so he knows that he can claim the hash-locked path of the commitment transactions HTLC output if it were to go on-chain. Ideally, channels should remain open though so instead of publishing the transaction on-chain and sweeping the hash-locked contract there, Charlie instead just sends the pre-image, <code>S</code>, to Bob. This proves to Bob that Charlie would be able to claim the HTLC output if they were to broadcast the commitment transaction on-chain and so now the two parties can agree to just update their commitment transaction to reflect that Charlie now has the 1 BTC extra:</p>
<p><img loading="lazy" src="/lnThings/htlc5.png#center" alt=""  />
</p>
<p>Now that Bob has <code>S</code>, he can turn around and reveal <code>S</code> to Alice and thus prove to Alice that if their commitment transaction were to go on-chain, that Bob would be able to claim the hash-locked output. So as Bob and Charlie did in their channel, Alice and Bob similarly update their commitment transaction by removing the HTLC output and just reflecting the new balances:</p>
<p><img loading="lazy" src="/lnThings/htlc6.png#center" alt=""  />
</p>
<p>Alice has now effectively paid Charlie 1 BTC and Bob has earned a routing fee of 1 BTC.</p>
<h3 id="some-extra-details">Some extra details:</h3>
<p>What if things go wrong? Perhaps Charlie goes offline and doesn’t respond to Bob with a pre-image. If this happens then Bob will need to broadcast the commitment transaction so that he can claim his funds back via the time-locked path of the HTLC. If he does broadcast the transaction but then Charlie comes back online before <code>cltv_expiry_BC</code> has been reached and goes and spends via the HTLC’s hash-locked path then Bob will be able to see the pre-image on the blockchain and will then be able to turn around to Alice and reveal the pre-image to her as per usual. From this example, you can see that it is important for the <code>cltv_expiry</code> values to decrease along the path from the sender to the receiver. This is because in the worst case, Charlie only reveals <code>S</code> to Bob just before <code>cltv_expiry_BC</code> and then Bob still needs time to turn around and reveal <code>S</code> to Alice before she is able to spend along the <code>ctlv_expiry_AB</code> path. Therefor <code>cltv_expiry_BC</code> must be before <code>ctlv_expiry_AB</code>.</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>LN Things Part 3: Revocation in more detail</title>
      <link>https://www.ellemouton.com/posts/revocation/</link>
      <pubDate>Tue, 23 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.ellemouton.com/posts/revocation/</guid>
      <description>Day 3 of #7DaysOfBitcoin</description>
      <content:encoded><![CDATA[<p>In Part 2 I gave an overview of how two participants of a payment channel go about agreeing on a state and how they update their state. In this post we will look at the scripts used in the commitment transactions and dig into the revocation key process a bit more.</p>
<p>Taking a look at Alice’s commitment transaction again: it spends from the funding transaction and has two outputs: a <code>to_local</code> output and a <code>to_remote</code> output.</p>
<h3 id="to_remote">to_remote</h3>
<p>This output is simply a P2WPKH send to a public key belonging to Bob.</p>
<pre tabindex="0"><code>&lt;remotepubkey&gt;
</code></pre><h3 id="to_local">to_local</h3>
<p>This output has 2 spending paths:</p>
<ol>
<li>the first is to a <code>&lt;revocationpubkey&gt;</code></li>
<li>the second is to a Public key belonging to Alice but is only spendable after a relative delay of <code>to_self_delay</code> blocks.</li>
</ol>
<pre tabindex="0"><code>OP_IF
    # Penalty transaction
    &lt;revocationpubkey&gt;
OP_ELSE
    `to_self_delay`
    OP_CHECKSEQUENCEVERIFY
    OP_DROP
    &lt;local_delayedpubkey&gt;
OP_ENDIF
OP_CHECKSIG
</code></pre><p>In Part 2, the revocation key system was described as follows:</p>
<ol>
<li>Alice generates a temporary private key <code>dA1</code> and its corresponding public key <code>PA1</code> and sends the public key to Bob.</li>
<li>Then Alice creates a commitment transaction where the <code>to_local_output</code> output has a spending path that is immediately spendable by Bob if he has the private ket <code>dA1</code>.</li>
<li>If Alice and Bob agree to update their channel state, then the private keys for the previous state will be swapped (ie: Alice will send Bob <code>dA1</code>).</li>
</ol>
<p>This description is mostly correct but not complete. If you take a look at the <code>to_self_delay</code> script above, you can see that the revocation path doesn’t have any condition that makes it seem like only Bob can spend it. It just looks like anyone with the private key corresponding the revocation public key can spend the output. This makes it seem like Alice can also spend the output since she is the one who derived the temporary private key in the first place. After diving into the LND code a bit to try and figure this out, I found that a very cool trick is used to ensure that only Bob can spend via the revocation path. (See function <code>DeriveCommitmentKeys</code>).</p>
<p>Before construction the commitment transactions, both Alice and Bob derive <strong>two</strong> temporary keys and the associated public keys. They will both derive a <code>revocation_basepoint</code> (r -&gt; R) and a <code>per_commitment_point</code> (c -&gt; C).</p>
<ul>
<li>Alice will have her revocation_basepoint key pair: <code>rA1</code> -&gt; <code>RA1</code> and her per-commitment key pair: <code>cA1</code> -&gt; <code>CA1</code>.</li>
<li>Bob will have his revocation_basepoint key pair: <code>rB1</code> -&gt; <code>RB1</code> and his per-commitment key pair: <code>cB1</code> -&gt; <code>CB1</code>.</li>
</ul>
<p>Now, in order to create her commitment transaction, Alice will send Bob her commitment point public key, <code>CA1</code> and Bob will send Alice his revocation_basepoint public key, <code>RB1</code>. Alice then derives the following Revocation key <code>RevA1</code> as follows:</p>
<pre tabindex="0"><code>Rev_A1 = R_B1 * sha256( R_B1 || C_A1 ) + C_A1 * sha256( C_A1 || R_B1 )
</code></pre><p>Alice’s <code>to_local</code> output script now looks as follows:</p>
<pre tabindex="0"><code>OP_IF
     &lt;Rev_A1&gt;
OP_ELSE
    `to_self_delay`
    OP_CHECKSEQUENCEVERIFY
    OP_DROP
    &lt;alice_delayedpubkey&gt;
OP_ENDIF
OP_CHECKSIG
</code></pre><p>Now when the times comes for Alice and Bob to update their state and invalidate this old state, Alice sends Bob her private key for her per-commitment key pair, <code>c_A1</code>. With this key, Bob will be able to derive the private key corresponding the the public key <code>Rev_A1</code> and will therefore be able to spend via the revocation output. He can do this because he has private key <code>r_B1</code> that corresponds to public key <code>R_B1</code>. So he can calculate the private key as follows:</p>
<pre tabindex="0"><code>rev_A1 = r_B1 * sha256( R_B1 || C_A1 ) + c_A1 * sha256( C_A1 || R_B1 )
</code></pre><p>Alice will not be able to derive this private key because she does not and will never have the private key <code>r_B1</code>.</p>
<h3 id="updated-diagrams-from-post-2">Updated Diagrams from Post 2:</h3>
<h4 id="state-1">State 1:</h4>
<p><img loading="lazy" src="/lnThings/state1V2.png#center" alt=""  />
</p>
<h4 id="state-2">State 2:</h4>
<p><img loading="lazy" src="/lnThings/state2V2.png#center" alt=""  />
</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>LN Things Part 2: Updating State</title>
      <link>https://www.ellemouton.com/posts/updating-state/</link>
      <pubDate>Mon, 22 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.ellemouton.com/posts/updating-state/</guid>
      <description>Day 2 of #7DaysOfBitcoin</description>
      <content:encoded><![CDATA[<p>Today’s post is more of a set up for the next one. It describes the basics of the Lightning Network update layer using LN-Penalty. The next post will introduce HTLCs and then will dive into how the HTLCs fit into commitment transactions and how this plays along with the update layer.</p>
<p>The previous post described how Alice and Bob set up a channel. It mentioned that both Alice and Bob had commitment transactions that spent from the on-chain funding transaction and that the commitment transactions were both valid and could be published on the blockchain and pay the recipients what they are owed.</p>
<p>This post will describe the commitment transactions in more detail and will also show how the participants of the channel can agree on a new division of funds. In other words: how they create new commitment transaction that splits the funds differently and at the same time invalidate the older commitment transactions that they have.</p>
<h3 id="asymmetric-commitment-transactions">Asymmetric commitment transactions:</h3>
<p>In LN-penalty, each party in the channel will hold a commitment transaction representing the state of the channel. Why? To assigning blame. The commitment transactions held by each party vary slightly (details to follow) and this makes it clear which party broadcasted their commitment transaction and makes it possible for the correct party to be punished if they broadcast an invalid state. This concept will be made more clear in this post.</p>
<h3 id="setting-up-state-1">Setting up state 1:</h3>
<p>Let’s assume that Alice and Bob start out each owning 5 BTC in a 10 BTC channel. To set up their initial commitment transactions, each party will first create temporary private keys (<code>dA1</code> for Alice and <code>dB1</code> for Bob) and calculate their associated public key (<code>PA1</code> and <code>PB1</code>). Alice and Bob will then send each other the temporary public keys. At this point, both parties can construct their own commitment transaction. Alice’s will look as follows:</p>
<ol>
<li>It will spend from the funding transaction.</li>
<li>It will have 2 outputs. (or more. HTLC outputs to come!)</li>
<li>The <code>to_remote</code> output will send Bob his 5 BTC immediately.</li>
<li>the <code>to_local</code> output is fancier: It either sends Alice her 5 BTC after an OP_CSV <code>to_self_delay</code> or it can immediately be spent by Bob if he is able to prove that he has Alices temporary private key <code>dA1</code>.</li>
</ol>
<p>Bob will be able to construct Alice’s commitment transaction too and will thus be able to provide her with his signature for the input of her transaction (the one that spends from the channel’s funding transaction). And so Alice will have this valid transaction with Bob’s signature and so she can at any point sign it her self and broadcast it to the network to be confirmed in a block.</p>
<p>Bob will create his commitment transaction in a similar way. See the diagram below:</p>
<p><img loading="lazy" src="/lnThings/state1.png#center" alt=""  />
</p>
<p>Note that at this point, either party can broadcast their commitment transactions to the network. For example, let’s say Alice broadcasts her’s. Bob will get his 5 BTC immediately and Alice will need to wait <code>to_self_delay</code> blocks before she is able to use her 5 BTC. She doesn’t need to worry about Bob spending her output though because she knows that she never shared her secret private key with him.</p>
<h3 id="setting-up-state-2">Setting up state 2:</h3>
<p>Now Alice wants to send Bob 1 BTC using their channel. So just like for stage 1, both parties will now generate new temporary private keys (<code>dA2</code> for Alice and <code>dB2</code> for Bob), calculate their associated public key (<code>PA2</code> and <code>PB2</code>) and share the public keys with each other. And again, both parties will create commitment transactions to reflect this new state where Alice has transferred one of the BTC to Bob. The problem is that Alice still has the valid commitment transaction from before which is more profitable for her. To invalidate this old state and to prove to Bob that she is committing to this new state where she has paid him, Alice will send Bob her initial temporary private key (<code>dA1</code>). Since Bob now has this key, if Alice ever posts the old state, Bob will be able to spend Alice’s <code>to_local</code> output before she is able to claim it. Bob also sends Alice his old key (<code>dB1</code>) in order to invalidate his old state. He has no reason not to do this since the new state is more profitable to him.</p>
<p><img loading="lazy" src="/lnThings/state2.png#center" alt=""  />
</p>
<p>That’s it! Alice and Bob can now update their shared channel state and invalidate old states.</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>LN Things Part 1: Creating a channel</title>
      <link>https://www.ellemouton.com/posts/creating-a-channel/</link>
      <pubDate>Sun, 21 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.ellemouton.com/posts/creating-a-channel/</guid>
      <description>Day 1 of #7DaysOfBitcoin</description>
      <content:encoded><![CDATA[<h3 id="what-is-a-channel">What is a channel?</h3>
<p>It is literally just a transaction sending funds to a 2-of-2 multisig
transaction. This creates an unspent UTXO and the channel is open until that
UTXO is spent (crazy to think that the current state of the LN is just a subset
of the current UTXO set). During the lifetime of the channel, a bunch of
transactions are created that double spend the funding tx and eventually one of
those (and only one. No double spends bro) will go on-chain and the channel will
be closed. Ideally you only see these two on-chain transactions: one to open the
channel and one to close it.</p>
<h3 id="creating-a-channel">Creating a channel:</h3>
<p>To create a channel we need to somehow get this initial funding channel
on-chain. How this is done can be gleaned from <a href="https://github.com/lightningnetwork/lightning-rfc/blob/master/02-peer-protocol.md">BOLT2</a> but I will go through my
understanding of it here. The following screenshot is from the bolt and shows
the various messages sent between two nodes during channel creation. I will go
through each of these.</p>
<p><img loading="lazy" src="/lnThings/open_chan_msg.png#center" alt="name"  />
</p>
<p>Since commitment transactions are part of the update layer (and ie will be
analysed in a future post) I wont get into those details now but the important
thing to know is that once a funding transaction is established and confirmed,
commitment transactions are used to define the state that the channel is in (how
the funds are distributed between the participants in the channel). So each
commitment transaction pretty much just spends the funding transaction (uses the
funding tx as its input) and then has outputs that define the division of funds
between the participants.</p>
<p>The funding transaction for a channel between Alice and Bob is simply a
transaction that has an output of the following form:</p>
<pre tabindex="0"><code>2 &lt;pubkeyA&gt; &lt;pubkeyB&gt; 2 OP_CHECKMULTISIG 
</code></pre><p>Where <code>&lt;pubkeyA&gt;</code> is the Alice’s public key and <code>&lt;pubkeyB&gt;</code> Bob’s. Currently in
the Lightning Network a channel is always funded by one side. So in our example
lets say that Alice wants to open, and hence fund, the channel. The question is:
how does she do this? Can she simply just send funds to the above script? No she
cant because there is a chance that Bob might disappear and never be around to
sign any transaction that attempts to spend from the funding transaction and
this would mean that Alice’s funds would be stuck in this UTXO forever. Let’s go
through each of the messages shown in the above diagram to see how it is done
then.</p>
<h4 id="open_channel">open_channel:</h4>
<p>Alice sends this message to Bob to indicate that she wants to open a channel
with him. This message includes various details regrading Alice’s requirements
of the channel but the important one is the <code>funding_pubkey</code>. This is the public
key that Alice intends to use as her public key in the funding transaction
script.</p>
<p><img loading="lazy" src="/lnThings/open_chan.png#center" alt=""  />
</p>
<h4 id="accept_channel">accept_channel:</h4>
<p>If Bob is happy with the terms that Alice has put forward in her channel offer,
then he can send back the <code>accept_channel</code> message which also contains some of
his requirements along with the <code>funding_pubkey</code> that he intends to use.</p>
<p><img loading="lazy" src="/lnThings/accept_chan.png#center" alt=""  />
</p>
<p>At this point, Alice has all that she needs to construct the funding
transaction. However, she at this moment still does not broadcast the funding
transaction because she still has no guarantee that Bob will not disappear. So
what she needs is a commitment transaction signed by Bob that spends from the
funding transaction and divides the channel balance accordingly. It could be the
case that the initial division of funds allocates some funds to Bob too and so
Bob would also want a valid commitment transaction that he can broadcast in case
Alice disappears (the concept of asymmetric commitment transactions will be
discussed in detail in a future post. For now, just know that both sides have a
commitment transaction) . What Alice does now is construct the funding
transaction (using Segwit inputs only so that the TXID of the transaction can
not be changed due to script sig field malleation) but she does not broadcast
the transaction. She sends bob the following message:</p>
<h4 id="funding_created">funding_created:</h4>
<p><img loading="lazy" src="/lnThings/funding_created.png#center" alt=""  />
</p>
<p>This message contains the TXID of the funding transaction, the relevant output
index of the funding transaction along with a signature for Bob’s commitment
transaction (if Bob is following the rule then Alice is able construct the exact
commitment transaction that he is holding and is thus able to provide her
signature for it). Note that Bob cannot yet do anything with his commitment
transaction since it is spending from a transaction that is not on the
blockchain yet.</p>
<h4 id="funding_signed">funding_signed:</h4>
<p>If Bob is happy then he can send Alice a <code>funding_signed</code> message.</p>
<p><img loading="lazy" src="/lnThings/funding_signed.png#center" alt=""  />
</p>
<p>This message will contain a Bob’s signature for Alice’s commitment transaction.</p>
<p>At this point, Alice now has a valid commitment transaction signed by Bob that
spends from the funding transaction that sends her funds back to her. It is thus
safe for her to now broadcast the funding transaction.</p>
<h4 id="channel_ready">channel_ready:</h4>
<p>Both parties will be monitoring the blockchain at this point waiting for the
funding transaction to be confirmed. Once each party sees it, they will send the
other party the <code>channel_ready</code> message which contains the channel ID of the
channel.</p>
<p>The channel is now open. YEET!</p>
<p><img loading="lazy" src="/lnThings/channel_ready.png#center" alt=""  />
</p>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
