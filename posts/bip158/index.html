<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>BIP158: Compact Block Filters Deep Dive | Elle Mouton</title><meta name=keywords content><meta name=description content="What even is Golomb-Rice Coding?"><meta name=author content="map[email:elle.mouton@gmail.com name:Elle Mouton]"><link rel=canonical href=https://www.ellemouton.com/posts/bip158/><link crossorigin=anonymous href=/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe+FVUFzPh7U=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://www.ellemouton.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.ellemouton.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.ellemouton.com/favicon-32x32.png><link rel=apple-touch-icon href=https://www.ellemouton.com/apple-touch-icon.png><link rel=mask-icon href=https://www.ellemouton.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-PMLX8P6J9S"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-PMLX8P6J9S',{anonymize_ip:!1})}</script><meta property="og:title" content="BIP158: Compact Block Filters Deep Dive"><meta property="og:description" content="What even is Golomb-Rice Coding?"><meta property="og:type" content="article"><meta property="og:url" content="https://www.ellemouton.com/posts/bip158/"><meta property="og:image" content="https://www.ellemouton.com/bip158/bip158.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-11-01T00:00:00+00:00"><meta property="article:modified_time" content="2021-11-01T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.ellemouton.com/bip158/bip158.png"><meta name=twitter:title content="BIP158: Compact Block Filters Deep Dive"><meta name=twitter:description content="What even is Golomb-Rice Coding?"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://www.ellemouton.com/posts/"},{"@type":"ListItem","position":3,"name":"BIP158: Compact Block Filters Deep Dive","item":"https://www.ellemouton.com/posts/bip158/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"BIP158: Compact Block Filters Deep Dive","name":"BIP158: Compact Block Filters Deep Dive","description":"What even is Golomb-Rice Coding?","keywords":[],"articleBody":"In this post, I will briefly describe the needs of a bitcoin light client and why compact block filters satisfy these needs better than Bloom filters do. Then I will dive into exactly how compact block filters work and will follow this with a step by step guide for constucting such a filter from a testnet block.\nThe purpose of block filters A bitcoin light client is software that can back a bitcoin wallet without storing the blockchain. This means that it needs to be able to broadcast transactions to the network but most importantly it must be able to pick up when there is a new transaction that is relevant to the wallet it is backing. There are two ways a transaction becomes relevant to a wallet: either it is sending money to the wallet (creating a new output to a wallet address) or it is spending one of the UTXOs that the wallet owns.\nWhat was wrong with Bloom filters? Before BIP 158 came along, the most widely used method for light clients was to use Bloom filters1 as described in BIP 37. With a bloom filter, you take all the objects you are interested in (script pub keys spent or created), hash them a couple times and add the result of each to a bit map called a Bloom filter. This filter represents what you are interested in. You would then send this filter to a trusted bitcoin node and ask them to send you anything that matches your filter. The problem with this is that it is not very private since you are revealing some information to the bitcoin node you are sending this filter too. They can start getting an idea of the transactions you are interested in as well as the ones you are definitely not interested in. They can also just decide not to send you a transaction that matches the filter. So as you can see, it isn’t great for the light client. But it is also not great for the bitcoin node serving the light client. Each time you send them a filter, they have to load the relevant block from disk and determine which transactions match your filter. You could just spam them with fake filters and effectively DOS them. It takes very little energy to create a filter and lots to respond to it.\nIntroducing Compact Block Filters: Ok, take two. What we want is:\n More privacy Less asymmetry in the client - server work load. Ie, the server should be required to do way less work. Less trust. The light client shouldn’t need to worry about the server holding back relevant transactions.  With compact block filters, the server (full node) will for each block construct a deterministic filter that includes all the objects in the block. This filter can be calculated once and persisted. If light clients request a filter for a block, there is no asymmetry since the server wont have to do any more work than the client had to do when making the request. A light client can also choose to download the filters from multiple sources to ensure they match and can always download the full block and check for itself if the filter that the server provided was indeed correct given the blocks contents. Another bonus is that this is way more private. The light client no longer sends a fingerprint of the data it is interested in to the server. And so it becomes way more difficult to analyse the light client’s activity. The light client gets these filters from the server and checks for itself if any of its objects match what is seen in the filter and if it does match, then the light client asks for the full block. One thing to note with this way of doing things is that full nodes serving the light clients will need to persist these filters and the light clients might also want to persist a few filters and so it is important that the filters are as small as possible (hence the name, compact block filters).\nCool! Now we get to the cool stuff. How is this filter created? What does it look like?\nWhat do we want?\n We want to put fingerprints of certain objects in the filter so that when clients are looking to see if a block maybe contains info relevant to them, they can take all their objects and check if the filter matches on those objects. We want the filters to be as small as possible. Effectively we want to sort of summarise some of the block info… in a size much much smaller than the block.  The info included in the basic filter is: every transaction’s input’s scriptPubKey being spent and every transaction’s output’s scriptPubKey being created. So something like this:\nobjects = {spk1, spk2, spk3, spk4, ..., spkN} // A list of N scriptPubKeys. Technically we could just stop here and say this list of scriptPubKeys is our filter. It is a condensed version of what is in the block chain and contains the info the light client needs. With this list they could tell with 100% certainty if something they are interested in is in the block. But it is still pretty big. So the next step is all about making this list as compact as possibly. This is where things get insanely cool.\nFirst we convert each object into a number in a range such that the object numbers are uniformly distributed in that range: Let’s say we have 10 objects (N = 10), then we have some function that turns each of the objects into a number. Let’s say we chose the range [0, 10] since we have 10 objects. Now the hashing-plus-convert-to-number function we use will take each object and produce a number in the space from [0, 10]. It is uniformly distributed in this space. That means that, after ordering them, we will get (in the very very ideal case) something like this:\nFirst of all, wow that is so great cause we have drastically decreased the size of an objects finger print. Each one is just a number now. Ok so, let this be our new filter:\nnumbers := {1,2,3,4,5,6,7,8,9,10} Now a light client downloads the filter and wants to see if one of the objects they are looking for is matched in this filter. All they need to do is take their objects and do the same hashing-plus-convert-to-number scheme and check if any of the numbers are in the filter. What is the problem? The filter has a number for each possible number in the space! Meaning that absolutely any object will match on this filter. In other words, the false-positive rate of this filter is 1. This is no good. We have lost too much info on our quest to compress the data in the filter. What we need is a higher false-positive (fp) rate. Ok so let’s say we want a false positive rate of 5. Then what we want is to have our objects be mapped uniformly to a space of [0, 50]:\nThis is starting to look a bit better. If I am a client downloading this filter and I check if my objects are maybe in the filter, there will be a 1/5 chance that if it matches, it is a false positive. Great so now we have mapped 10 objects to numbers between 0 \u0026 50. This new list of numbers is our filter. Again, we could stop here… but we can compress this even further!!\nWe have this list of ordered numbers that we know are distributed uniformly across this space between [0, 50]. We know that there are 10 items in the list. What this means is that we can deduce that the most likely difference between each of the numbers in this ordered list is about 5. In general, if we have N items and a false positive rate of M, then the space will be of size N * M. So the numbers in the space can range from 0 to N * M, but the difference between each number (once ordered) will be roughly M. M will definitely be a smaller number to store than a number in the N * M space. So what we can do is instead of storing each number, we can instead store the difference of each successive number. In the above case, this would mean that instead of storing [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50], we just store [0, 5, 5, 5, 5, 5, 5, 5, 5, 5] and then it is trivial to reconstruct the original list. As you can gather, storing the number 50 requires way more bits than storing the number 5. But why stop there? We can compress this even further!\nThis is where Golomb-Rice Coding comes in. This encoding works well for a list of numbers that will all very likely be close to some number. This is what we have! We have a list of numbers that will all very likely be close to 5 (or, in general, close to our FP rate of M) and so taking the quotient of any number in the list with that number (dividing each number by 5 and ignoring the remainder) will very likely be 0 (if the number is slightly less than 5) or 1 if the number is slight more than 5. The quotient could be 2, 3 etc but the likelihood decreases a lot. Great! So we can take advantage of this knowledge and say that we will encode a small quotient with the smallest number of bits that we can and use more bits to encode larger, unlikely, quotients. Then we also need to encode the remainders (since we want to be able to reconstruct the values exactly) and these will always be numbers between [0, M-1] (in our case, [0, 4]). For encoding the quotients, we use the following mapping:\nThe mapping above is easy to read: The number of 1s indicates the quotient we are encoding and the 0 indicates the end of the quotient encoding. So for each number in our list, we encode the quotient using the above table and then we convert the remainder to binary using the number of bits needed to encode the maximum of M-1. In our case, that is 3 bits. Here is a table showing the encoding of the possible remainders in our example:\nSo, in our ideal case example, our list of [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5] can be encoded as follows:\n0000 10000 10000 10000 10000 10000 10000 10000 10000 10000 Before we move on to a more realistic example, let’s see if we can reconstruct our original list from this filter.\nOk so we have: “0000100001000010000100001000010000100001000010000”. We know the how Golomb-Rice Coding encodes quotients and we also know that M is 5 (since this will be public knowledge known to everyone using this filter construction). Since we know M is 5, we know that 3 bits will be used to encode the remainders. So we can take our filter and produce the following quotient-remainder tuples:\n[(0, 0), (1, 0), (1, 0), (1, 0), (1, 0), (1, 0), (1, 0), (1, 0), (1, 0), (1, 0)] We know that the quotients were produced by dividing number by M (5), so we can reconstruct these:\n[0, 5, 5, 5, 5, 5, 5, 5, 5, 5] And we know that this list represents differences of numbers, so we can reconstruct the OG list:\n[0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50] A more realistic example We will now try to construct a filter from an actual Bitcoin testnet block. I’m going to use block 2101914. Let’s see what it’s actual filter is:\n$ bitcoin-cli getblockhash 2101914 000000000000002c06f9afaf2b2b066d4f814ff60cfbc4df55840975a00e035c $ bitcoin-cli getblockfilter 000000000000002c06f9afaf2b2b066d4f814ff60cfbc4df55840975a00e035c { \"filter\": \"5571d126b85aa79c9de56d55995aa292de0484b830680a735793a8c2260113148421279906f800c3b8c94ff37681fb1fd230482518c52df57437864023833f2f801639692646ddcd7976ae4f2e2a1ef58c79b3aed6a705415255e362581692831374a5e5e70d5501cdc0a52095206a15cd2eb98ac980c22466e6945a65a5b0b0c5b32aa1e0cda2545da2c4345e049b614fcad80b9dc9c903788163822f4361bbb8755b79c276b1cf7952148de1e5ee0a92f6d70c4f522aa6877558f62b34b56ade12fa2e61023abf3e570937bf379722bc1b0dc06ffa1c5835bb651b9346a270\", \"header\": \"8d0cd8353342930209ac7027be150e679bbc7c65cc62bb8392968e43a6ea3bfe\" } Ok shweeeeeet, let’s see if we can reconstruct this filter from the block.\nThe full code for this can be found in this github repo. I will just show some pseudo code snippets here. The beef of the code is the function called constructFilter which takes in a bitcoin client that can be used to make calls to bitcoind and the block in question. The function looks something like this:\nfunc constructFilter(bc *bitcoind.Bitcoind, block bitcoind.Block) ([]byte, error) { // 1. Collect all the objects from the block that we want to add to the filter  // 2. Convert all the objects to numbers and sort them.  // 3. Get the differences between the sorted numbers  // 4. Encode these differences using Golomb-Rice Coding } Ok so step 1 is to collect all the objects from the block that we want to add to the filter. From the BIP, we know that these objects are all the scriptPubKeys being spent as well as all the scriptPubKeys of each output. Some extra rules from the BIP are that we skip the input for the coinbase transaction (since it is empty and meaningless) and we skip any OP_RETURN outputs. We also de-duplicate the data. So if there are two identical scriptPubKeys, we only include one in the filter.\n// The list of objects we want to include in our filter. These will be // every scriptPubKey being spent as well as each output's scriptPubKey. // We use a map so that we can dedup any duplicate scriptPubKeys. objects := make(map[string] struct{}) // Loop over every transaction in the block. for i, tx := range block.Tx { // Add the scriptPubKey of each of the transaction's outputs  // and add those to our list of objects.  for _, txOut := range tx.Vout { scriptPubKey := txOut.ScriptPubKey if len(scriptPubKey) == 0 { continue } // We don't add the output if it is an OP_RETURN (0x6a).  if spk[0] == 0x6a { continue } objects[skpStr] = struct{}{} } // We don't add the inputs of the coinbase transaction.  if i == 0 { continue } // For each input, go and fetch the scriptPubKey that it is  // spending.  for _, txIn := range tx.Vin { prevTx, err := bc.GetRawTransaction(txIn.Txid) if err != nil { return nil, err } scriptPubKey := prevTx.Vout[txIn.Vout].ScriptPubKey if len(scriptPubKey) == 0 { continue } objects[spkStr] = struct{}{} } } Ok great, we have all the objects we care about. And now we can also define the variable N to be the length of the objects map. In this example, N is 85.\nThe next step is to convert each of the objects to numbers spread uniformly across a range. Remember that this range depends on the false-positive rate we want. BIP158 defines the constant M to be 784931. This means that we want every 1/784931 matches to be a false-positive. As we did in our earlier example, we take this fp rate of M and multiply it by N to get the range that we want all our numbers to lie in. We define this as F where F = M*N. In our case, we have 85 objects and so F=66719135. I am not going to go into the details of the function used to map our objects to numbers (you can check out the details of this in the code in the linked repo). All you need to know for now is that it takes in an object, the constant F which defines the range that it needs to map the object to, and a key which is the block hash. Once we have all the numbers, we sort the list in ascending order and then we also create a new list called differences which will hold the differences between each sequential number in the sorted numbers list.\nnumbers := make([]uint64, 0, N) // Iterate over all the objects, convert them to numbers lying uniformly in the range [0, F] // and add them to the `numbers` list. for o := range objects { // Using the given key, max number (F) and object bytes (o),  // convert the object to a number between 0 and F.  v := convertToNumber(b, F, key) numbers = append(numbers, v) } // Sort the numbers. sort.Slice(numbers, func(i, j int) bool { return numbers[i] numbers[j] }) // Convert the list of numbers to a list of differences. differences := make([]uint64, N) for i, num := range numbers { if i == 0 { differences[i] = num continue } differences[i] = num - numbers[i-1] } Awesome! Here is a graph showing the values in the numbers and differences lists:\nAs you can see, the 85 numbers are really nicely uniformly distributed across the space! And this results in the values in the differences list being pretty small.\nThe last step now is to use Golomb-Rice Coding to encode this differences list. Recall from the earlier explanation that we need to divide each difference by it’s most likely value and then we encode that quotient along with the remainder. In my earlier example I said that this most-likely value would be the M that we choose and that the remainder would then lie in the range [0, M]. However, this is not what is done in the BIP as it was found2 that this is in fact not the ideal way to choose the Golomb-Rice coder parameter when trying to optimize for the smallest possible size of the final encoded filter. And so instead of using M, a new constant of P is defined and P^2 is used as the Golomb-Rice parameter. P is defined as 19. This means that each difference value is divided by 2^19 to get the quotient and remainder and the remainder is then encoded in binary in 19 bits.\nfilter := bstream.NewBStreamWriter(0) // For each number in the differences list, calculate the quotient and // remainder after dividing by 2^P. for _, d := range differences { q := math.Floor(float64(d)/math.Exp2(float64(P))) r := d - uint64(math.Exp2(float64(P))*q) // Encode the quotient.  for i := 0; i q); i++ { filter.WriteBit(true) } filter.WriteBit(false) filter.WriteBits(r, P) } Great stuff! Now when we print out this filter, we get:\n71d126b85aa79c9de56d55995aa292de0484b830680a735793a8c2260113148421279906f800c3b8c94ff37681fb1fd230482518c52df57437864023833f2f801639692646ddcd7976ae4f2e2a1ef58c79b3aed6a705415255e362581692831374a5e5e70d5501cdc0a52095206a15cd2eb98ac980c22466e6945a65a5b0b0c5b32aa1e0cda2545da2c4345e049b614fcad80b9dc9c903788163822f4361bbb8755b79c276b1cf7952148de1e5ee0a92f6d70c4f522aa6877558f62b34b56ade12fa2e61023abf3e570937bf379722bc1b0dc06ffa1c5835bb651b9346a270 Apart from the first two bytes, this matches the filter we got from bitcoind exactly! Why the 2 byte difference? The BIP says that the N value needs to be encoded in CompactSize format and appended to the front of the filter so that it can be decoded by the receiver. This is done as follows:\nfd := filter.Bytes() var buffer bytes.Buffer buffer.Grow(wire.VarIntSerializeSize(uint64(N)) + len(fd)) err = wire.WriteVarInt(\u0026buffer, 0, uint64(N)) if err != nil { return nil, err } _, err = buffer.Write(fd) if err != nil { return nil, err } If we print out the filter now, we get one that matches the one we got from bitcoind exactly:\n5571d126b85aa79c9de56d55995aa292de0484b830680a735793a8c2260113148421279906f800c3b8c94ff37681fb1fd230482518c52df57437864023833f2f801639692646ddcd7976ae4f2e2a1ef58c79b3aed6a705415255e362581692831374a5e5e70d5501cdc0a52095206a15cd2eb98ac980c22466e6945a65a5b0b0c5b32aa1e0cda2545da2c4345e049b614fcad80b9dc9c903788163822f4361bbb8755b79c276b1cf7952148de1e5ee0a92f6d70c4f522aa6877558f62b34b56ade12fa2e61023abf3e570937bf379722bc1b0dc06ffa1c5835bb651b9346a270 Yay!\nHowever, from my understanding, there is no need to add N to the filter. If you know the value of P, then you can figure out the value of N. Let’s do this now by seeing if we can take the filter above, and reconstruct the original list of numbers:\nb := bstream.NewBStreamReader(filter) var ( numbers []uint64 prevNum uint64 ) for { // Read a quotient from the stream. Read until we encounter  // a '0' bit indicating the end of the quotient. The number of  // '1's we encounter before reaching the '0' defines the  // quotient.  var q uint64 c, err := b.ReadBit() if err != nil { return err } for c { q++ c, err = b.ReadBit() if errors.Is(err, io.EOF) { break } else if err != nil { return err } } // The following P bits are the remainder encoded as binary.  r, err := b.ReadBits(P) if errors.Is(err, io.EOF) { break } else if err != nil { return err } n := q*uint64(math.Exp2(float64(P))) + r num := n + prevNum numbers = append(numbers, num) prevNum = num } fmt.Println(numbers) The above produces the same list of numbers that we had before and we were able to reconstruct this without the knowledge of N. So I am not sure why it was decided that N should be added to the filter. If anyone knows why it was required to add N to the filter, please let me know!\nCool, that was fun! Thanks for reading. Yeeeeet!\n  https://en.wikipedia.org/wiki/Bloom_filter ↩︎\n https://gist.github.com/sipa/576d5f09c3b86c3b1b75598d799fc845 ↩︎\n   ","wordCount":"3400","inLanguage":"en","image":"https://www.ellemouton.com/bip158/bip158.png","datePublished":"2021-11-01T00:00:00Z","dateModified":"2021-11-01T00:00:00Z","author":{"@type":"Person","name":{"email":"elle.mouton@gmail.com","name":"Elle Mouton"}},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.ellemouton.com/posts/bip158/"},"publisher":{"@type":"Organization","name":"Elle Mouton","logo":{"@type":"ImageObject","url":"https://www.ellemouton.com/favicon.ico"}}}</script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:'\\[',right:'\\]',display:!0},{left:'$$',right:'$$',display:!0},{left:'\\(',right:'\\)',display:!1},{left:'$',right:'$',display:!1}],throwOnError:!1})})</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add('dark')</script><header class=header><nav class=nav><div class=logo><a href=https://www.ellemouton.com accesskey=h title="Elle Mouton (Alt + H)">Elle Mouton</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://www.ellemouton.com/CV_Elle_Mouton.pdf title=CV><span>CV</span></a></li><li><a href=https://www.ellemouton.com/archives title=Archive><span>Archive</span></a></li><li><a href=https://www.ellemouton.com/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>BIP158: Compact Block Filters Deep Dive</h1><div class=post-meta><span title="2021-11-01 00:00:00 +0000 UTC">November 1, 2021</span>&nbsp;·&nbsp;map[email:elle.mouton@gmail.com name:Elle Mouton]</div></header><figure class=entry-cover><img loading=lazy src=https://www.ellemouton.com/bip158/bip158.png alt></figure><div class=post-content><p>In this post, I will briefly describe the needs of a bitcoin light client and
why compact block filters satisfy these needs better than Bloom filters do. Then
I will dive into exactly how compact block filters work and will follow this
with a step by step guide for constucting such a filter from a testnet block.</p><h3 id=the-purpose-of-block-filters>The purpose of block filters<a hidden class=anchor aria-hidden=true href=#the-purpose-of-block-filters>#</a></h3><p>A bitcoin light client is software that can back a bitcoin wallet without storing the blockchain. This means that it needs to be able to broadcast transactions to the network but most importantly it must be able to pick up when there is a new transaction that is relevant to the wallet it is backing. There are two ways a transaction becomes relevant to a wallet: either it is sending money to the wallet (creating a new output to a wallet address) or it is spending one of the UTXOs that the wallet owns.</p><h3 id=what-was-wrong-with-bloom-filters>What was wrong with Bloom filters?<a hidden class=anchor aria-hidden=true href=#what-was-wrong-with-bloom-filters>#</a></h3><p>Before <a href=https://github.com/bitcoin/bips/blob/master/bip-0158.mediawiki>BIP 158</a> came along, the most widely used method for light clients was to use Bloom filters<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> as described in <a href=https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki>BIP 37</a>. With a bloom filter, you take all the objects you are interested in (script pub keys spent or created), hash them a couple times and add the result of each to a bit map called a Bloom filter. This filter represents what you are interested in. You would then send this filter to a trusted bitcoin node and ask them to send you anything that matches your filter. The problem with this is that it is not very private since you are revealing some information to the bitcoin node you are sending this filter too. They can start getting an idea of the transactions you are interested in as well as the ones you are definitely not interested in. They can also just decide not to send you a transaction that matches the filter. So as you can see, it isn’t great for the light client. But it is also not great for the bitcoin node serving the light client. Each time you send them a filter, they have to load the relevant block from disk and determine which transactions match your filter. You could just spam them with fake filters and effectively DOS them. It takes very little energy to create a filter and lots to respond to it.</p><h3 id=introducing-compact-block-filters>Introducing Compact Block Filters:<a hidden class=anchor aria-hidden=true href=#introducing-compact-block-filters>#</a></h3><p>Ok, take two. What we want is:</p><ul><li>More privacy</li><li>Less asymmetry in the client - server work load. Ie, the server should be required to do way less work.</li><li>Less trust. The light client shouldn&rsquo;t need to worry about the server holding back relevant transactions.</li></ul><p>With compact block filters, the server (full node) will for each block construct a deterministic filter that includes all the objects in the block. This filter can be calculated once and persisted. If light clients request a filter for a block, there is no asymmetry since the server wont have to do any more work than the client had to do when making the request. A light client can also choose to download the filters from multiple sources to ensure they match and can always download the full block and check for itself if the filter that the server provided was indeed correct given the blocks contents. Another bonus is that this is way more private. The light client no longer sends a fingerprint of the data it is interested in to the server. And so it becomes way more difficult to analyse the light client&rsquo;s activity. The light client gets these filters from the server and checks for itself if any of its objects match what is seen in the filter and if it does match, then the light client asks for the full block. One thing to note with this way of doing things is that full nodes serving the light clients will need to persist these filters and the light clients might also want to persist a few filters and so it is important that the filters are as small as possible (hence the name, compact block filters).</p><p>Cool! Now we get to the cool stuff. How is this filter created? What does it look like?</p><p>What do we want?</p><ul><li>We want to put fingerprints of certain objects in the filter so that when clients are looking to see if a block maybe contains info relevant to them, they can take all their objects and check if the filter matches on those objects.</li><li>We want the filters to be as small as possible.</li><li>Effectively we want to sort of summarise some of the block info… in a size much much smaller than the block.</li></ul><p>The info included in the basic filter is: every transaction&rsquo;s input&rsquo;s scriptPubKey being spent and every transaction&rsquo;s output&rsquo;s scriptPubKey being created. So something like this:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>objects</span> = {<span style=color:#a6e22e>spk1</span>, <span style=color:#a6e22e>spk2</span>, <span style=color:#a6e22e>spk3</span>, <span style=color:#a6e22e>spk4</span>, <span style=color:#f92672>...</span>, <span style=color:#a6e22e>spkN</span>} <span style=color:#75715e>// A list of N scriptPubKeys.
</span></code></pre></div><p>Technically we could just stop here and say this list of scriptPubKeys is our filter. It is a condensed version of what is in the block chain and contains the info the light client needs. With this list they could tell with 100% certainty if something they are interested in is in the block. But it is still pretty big. So the next step is all about making this list as compact as possibly. This is where things get insanely cool.</p><p>First we convert each object into a number in a range such that the object numbers are uniformly distributed in that range:
Let&rsquo;s say we have 10 objects (N = 10), then we have some function that turns each of the objects into a number. Let’s say we chose the range [0, 10] since we have 10 objects. Now the hashing-plus-convert-to-number function we use will take each object and produce a number in the space from [0, 10]. It is uniformly distributed in this space. That means that, after ordering them, we will get (in the very very ideal case) something like this:</p><p><img loading=lazy src=/bip158/dense.jpeg#center alt></p><p>First of all, wow that is so great cause we have drastically decreased the size of an objects finger print. Each one is just a number now. Ok so, let this be our new filter:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>numbers</span> <span style=color:#f92672>:=</span> {<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>5</span>,<span style=color:#ae81ff>6</span>,<span style=color:#ae81ff>7</span>,<span style=color:#ae81ff>8</span>,<span style=color:#ae81ff>9</span>,<span style=color:#ae81ff>10</span>}
</code></pre></div><p>Now a light client downloads the filter and wants to see if one of the objects they are looking for is matched in this filter. All they need to do is take their objects and do the same hashing-plus-convert-to-number scheme and check if any of the numbers are in the filter. What is the problem? The filter has a number for each possible number in the space! Meaning that absolutely any object will match on this filter. In other words, the false-positive rate of this filter is 1. This is no good. We have lost too much info on our quest to compress the data in the filter. What we need is a higher false-positive (fp) rate. Ok so let’s say we want a false positive rate of 5. Then what we want is to have our objects be mapped uniformly to a space of [0, 50]:</p><p><img loading=lazy src=/bip158/sparse.png#center alt></p><p>This is starting to look a bit better. If I am a client downloading this filter and I check if my objects are maybe in the filter, there will be a 1/5 chance that if it matches, it is a false positive. Great so now we have mapped 10 objects to numbers between 0 & 50. This new list of numbers is our filter. Again, we could stop here… but we can compress this even further!!</p><p>We have this list of ordered numbers that we know are distributed uniformly across this space between [0, 50]. We know that there are 10 items in the list. What this means is that we can deduce that the most likely <em>difference</em> between each of the numbers in this ordered list is about 5. In general, if we have N items and a false positive rate of M, then the space will be of size N * M. So the numbers in the space can range from 0 to N * M, but the difference between each number (once ordered) will be roughly M. M will definitely be a smaller number to store than a number in the N * M space. So what we can do is instead of storing each number, we can instead store the difference of each successive number. In the above case, this would mean that instead of storing <code>[0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50]</code>, we just store <code>[0, 5, 5, 5, 5, 5, 5, 5, 5, 5]</code> and then it is trivial to reconstruct the original list. As you can gather, storing the number 50 requires way more bits than storing the number 5. But why stop there? We can compress this even further!</p><p>This is where Golomb-Rice Coding comes in. This encoding works well for a list of numbers that will all very likely be close to some number. This is what we have! We have a list of numbers that will all very likely be close to 5 (or, in general, close to our FP rate of M) and so taking the quotient of any number in the list with that number (dividing each number by 5 and ignoring the remainder) will very likely be 0 (if the number is slightly less than 5) or 1 if the number is slight more than 5. The quotient could be 2, 3 etc but the likelihood decreases a lot. Great! So we can take advantage of this knowledge and say that we will encode a small quotient with the smallest number of bits that we can and use more bits to encode larger, unlikely, quotients. Then we also need to encode the remainders (since we want to be able to reconstruct the values exactly) and these will always be numbers between [0, M-1] (in our case, [0, 4]). For encoding the quotients, we use the following mapping:</p><p><img loading=lazy src=/bip158/quotient.png#center alt></p><p>The mapping above is easy to read: The number of <code>1</code>s indicates the quotient we are encoding and the <code>0</code> indicates the end of the quotient encoding. So for each number in our list, we encode the quotient using the above table and then we convert the remainder to binary using the number of bits needed to encode the maximum of M-1. In our case, that is 3 bits. Here is a table showing the encoding of the possible remainders in our example:</p><p><img loading=lazy src=/bip158/remainder.png#center alt></p><p>So, in our ideal case example, our list of <code>[0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]</code> can be encoded as follows:</p><pre><code>0000 10000 10000 10000 10000 10000 10000 10000 10000 10000
</code></pre><p>Before we move on to a more realistic example, let’s see if we can reconstruct our original list from this filter.</p><p>Ok so we have: “0000100001000010000100001000010000100001000010000”. We know the how Golomb-Rice Coding encodes quotients and we also know that M is 5 (since this will be public knowledge known to everyone using this filter construction). Since we know M is 5, we know that 3 bits will be used to encode the remainders. So we can take our filter and produce the following quotient-remainder tuples:</p><pre><code>[(0, 0), (1, 0), (1, 0), (1, 0), (1, 0), (1, 0), (1, 0), (1, 0), (1, 0), (1, 0)]
</code></pre><p>We know that the quotients were produced by dividing number by M (5), so we can reconstruct these:</p><pre><code>[0, 5, 5, 5, 5, 5, 5, 5, 5, 5]
</code></pre><p>And we know that this list represents differences of numbers, so we can reconstruct the OG list:</p><pre><code>[0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50]
</code></pre><h3 id=a-more-realistic-example>A more realistic example<a hidden class=anchor aria-hidden=true href=#a-more-realistic-example>#</a></h3><p>We will now try to construct a filter from an actual Bitcoin testnet block. I&rsquo;m going to use block <a href=https://blockstream.info/testnet/block/000000000000002c06f9afaf2b2b066d4f814ff60cfbc4df55840975a00e035c>2101914</a>. Let’s see what it’s actual filter is:</p><pre><code>$ bitcoin-cli getblockhash 2101914
000000000000002c06f9afaf2b2b066d4f814ff60cfbc4df55840975a00e035c

$ bitcoin-cli getblockfilter 000000000000002c06f9afaf2b2b066d4f814ff60cfbc4df55840975a00e035c
{
  &quot;filter&quot;: &quot;5571d126b85aa79c9de56d55995aa292de0484b830680a735793a8c2260113148421279906f800c3b8c94ff37681fb1fd230482518c52df57437864023833f2f801639692646ddcd7976ae4f2e2a1ef58c79b3aed6a705415255e362581692831374a5e5e70d5501cdc0a52095206a15cd2eb98ac980c22466e6945a65a5b0b0c5b32aa1e0cda2545da2c4345e049b614fcad80b9dc9c903788163822f4361bbb8755b79c276b1cf7952148de1e5ee0a92f6d70c4f522aa6877558f62b34b56ade12fa2e61023abf3e570937bf379722bc1b0dc06ffa1c5835bb651b9346a270&quot;,
  &quot;header&quot;: &quot;8d0cd8353342930209ac7027be150e679bbc7c65cc62bb8392968e43a6ea3bfe&quot;
}
</code></pre><p>Ok shweeeeeet, let’s see if we can reconstruct this filter from the block.</p><p>The full code for this can be found in this <a href=https://github.com/ellemouton/bip158Example>github repo</a>. I will just show some pseudo code snippets here. The beef of the code is the function called <code>constructFilter</code> which takes in a bitcoin client that can be used to make calls to bitcoind and the block in question. The function looks something like this:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>constructFilter</span>(<span style=color:#a6e22e>bc</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>bitcoind</span>.<span style=color:#a6e22e>Bitcoind</span>, <span style=color:#a6e22e>block</span> <span style=color:#a6e22e>bitcoind</span>.<span style=color:#a6e22e>Block</span>) ([]<span style=color:#66d9ef>byte</span>, <span style=color:#66d9ef>error</span>) {
	<span style=color:#75715e>// 1. Collect all the objects from the block that we want to add to the filter
</span><span style=color:#75715e></span>
	<span style=color:#75715e>// 2. Convert all the objects to numbers and sort them. 
</span><span style=color:#75715e></span>
	<span style=color:#75715e>// 3. Get the differences between the sorted numbers
</span><span style=color:#75715e></span>
	<span style=color:#75715e>// 4. Encode these differences using Golomb-Rice Coding
</span><span style=color:#75715e></span>}
</code></pre></div><p>Ok so step 1 is to collect all the objects from the block that we want to add to the filter. From the BIP, we know that these objects are all the scriptPubKeys being spent as well as all the scriptPubKeys of each output. Some extra rules from the BIP are that we skip the input for the coinbase transaction (since it is empty and meaningless) and we skip any OP_RETURN outputs. We also de-duplicate the data. So if there are two identical scriptPubKeys, we only include one in the filter.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// The list of objects we want to include in our filter. These will be
</span><span style=color:#75715e>// every scriptPubKey being spent as well as each output&#39;s scriptPubKey.
</span><span style=color:#75715e>// We use a map so that we can dedup any duplicate scriptPubKeys.
</span><span style=color:#75715e></span><span style=color:#a6e22e>objects</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>] <span style=color:#66d9ef>struct</span>{})

<span style=color:#75715e>// Loop over every transaction in the block.
</span><span style=color:#75715e></span><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>tx</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>block</span>.<span style=color:#a6e22e>Tx</span> {

        <span style=color:#75715e>// Add the scriptPubKey of each of the transaction&#39;s outputs
</span><span style=color:#75715e></span>        <span style=color:#75715e>// and add those to our list of objects.
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>txOut</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>tx</span>.<span style=color:#a6e22e>Vout</span> {
                <span style=color:#a6e22e>scriptPubKey</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>txOut</span>.<span style=color:#a6e22e>ScriptPubKey</span>

                <span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>scriptPubKey</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
                        <span style=color:#66d9ef>continue</span>
                }

                <span style=color:#75715e>// We don&#39;t add the output if it is an OP_RETURN (0x6a).
</span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>spk</span>[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0x6a</span> {
                        <span style=color:#66d9ef>continue</span>
                }

                <span style=color:#a6e22e>objects</span>[<span style=color:#a6e22e>skpStr</span>] = <span style=color:#66d9ef>struct</span>{}{}
        }

        <span style=color:#75715e>// We don&#39;t add the inputs of the coinbase transaction.
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
                <span style=color:#66d9ef>continue</span>
        }

        <span style=color:#75715e>// For each input, go and fetch the scriptPubKey that it is
</span><span style=color:#75715e></span>        <span style=color:#75715e>// spending.
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>txIn</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>tx</span>.<span style=color:#a6e22e>Vin</span> {
                <span style=color:#a6e22e>prevTx</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>bc</span>.<span style=color:#a6e22e>GetRawTransaction</span>(<span style=color:#a6e22e>txIn</span>.<span style=color:#a6e22e>Txid</span>)
                <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
                        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>err</span>
                }

                <span style=color:#a6e22e>scriptPubKey</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>prevTx</span>.<span style=color:#a6e22e>Vout</span>[<span style=color:#a6e22e>txIn</span>.<span style=color:#a6e22e>Vout</span>].<span style=color:#a6e22e>ScriptPubKey</span>

                <span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>scriptPubKey</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
                        <span style=color:#66d9ef>continue</span>
                }

                <span style=color:#a6e22e>objects</span>[<span style=color:#a6e22e>spkStr</span>] = <span style=color:#66d9ef>struct</span>{}{}
        }
}

</code></pre></div><p>Ok great, we have all the objects we care about. And now we can also define the variable N to be the length of the <code>objects</code> map. In this example, N is 85.</p><p>The next step is to convert each of the objects to numbers spread uniformly across a range. Remember that this range depends on the false-positive rate we want. BIP158 defines the constant M to be 784931. This means that we want every 1/784931 matches to be a false-positive. As we did in our earlier example, we take this fp rate of M and multiply it by N to get the range that we want all our numbers to lie in. We define this as F where F = M*N. In our case, we have 85 objects and so F=66719135. I am not going to go into the details of the function used to map our objects to numbers (you can check out the details of this in the code in the linked repo). All you need to know for now is that it takes in an object, the constant F which defines the range that it needs to map the object to, and a key which is the block hash. Once we have all the numbers, we sort the list in ascending order and then we also create a new list called <code>differences</code> which will hold the differences between each sequential number in the sorted <code>numbers</code> list.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>numbers</span> <span style=color:#f92672>:=</span> make([]<span style=color:#66d9ef>uint64</span>, <span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>N</span>)

<span style=color:#75715e>// Iterate over all the objects, convert them to numbers lying uniformly in the range [0, F]
</span><span style=color:#75715e>// and add them to the `numbers` list.
</span><span style=color:#75715e></span><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>o</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>objects</span> {
        <span style=color:#75715e>// Using the given key, max number (F) and object bytes (o),
</span><span style=color:#75715e></span>        <span style=color:#75715e>// convert the object to a number between 0 and F.
</span><span style=color:#75715e></span>        <span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>convertToNumber</span>(<span style=color:#a6e22e>b</span>, <span style=color:#a6e22e>F</span>, <span style=color:#a6e22e>key</span>)

        <span style=color:#a6e22e>numbers</span> = append(<span style=color:#a6e22e>numbers</span>, <span style=color:#a6e22e>v</span>)
}

<span style=color:#75715e>// Sort the numbers.
</span><span style=color:#75715e></span><span style=color:#a6e22e>sort</span>.<span style=color:#a6e22e>Slice</span>(<span style=color:#a6e22e>numbers</span>, <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>j</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>bool</span> { <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>numbers</span>[<span style=color:#a6e22e>i</span>] &lt; <span style=color:#a6e22e>numbers</span>[<span style=color:#a6e22e>j</span>] })

<span style=color:#75715e>// Convert the list of numbers to a list of differences.
</span><span style=color:#75715e></span><span style=color:#a6e22e>differences</span> <span style=color:#f92672>:=</span> make([]<span style=color:#66d9ef>uint64</span>, <span style=color:#a6e22e>N</span>)
<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>num</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>numbers</span> {
        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
                <span style=color:#a6e22e>differences</span>[<span style=color:#a6e22e>i</span>] = <span style=color:#a6e22e>num</span>
                <span style=color:#66d9ef>continue</span>
        }

        <span style=color:#a6e22e>differences</span>[<span style=color:#a6e22e>i</span>] = <span style=color:#a6e22e>num</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>numbers</span>[<span style=color:#a6e22e>i</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
}
</code></pre></div><p>Awesome! Here is a graph showing the values in the <code>numbers</code> and <code>differences</code> lists:</p><p><img loading=lazy src=/bip158/bitcoinExample.png#center alt></p><p>As you can see, the 85 numbers are really nicely uniformly distributed across the space! And this results in the values in the <code>differences</code> list being pretty small.</p><p>The last step now is to use Golomb-Rice Coding to encode this <code>differences</code>
list. Recall from the earlier explanation that we need to divide each difference
by it’s most likely value and then we encode that quotient along with the
remainder. In my earlier example I said that this most-likely value would be the
M that we choose and that the remainder would then lie in the range [0, M].
However, this is not what is done in the BIP as it was found<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> that
this is in fact not the ideal way to choose the Golomb-Rice coder parameter when
trying to optimize for the smallest possible size of the final encoded filter.
And so instead of using M, a new constant of P is defined and P^2 is used as the
Golomb-Rice parameter. P is defined as 19. This means that each difference value
is divided by 2^19 to get the quotient and remainder and the remainder is then
encoded in binary in 19 bits.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>filter</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>bstream</span>.<span style=color:#a6e22e>NewBStreamWriter</span>(<span style=color:#ae81ff>0</span>)

<span style=color:#75715e>// For each number in the differences list, calculate the quotient and
</span><span style=color:#75715e>// remainder after dividing by 2^P.
</span><span style=color:#75715e></span><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>d</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>differences</span> {
        <span style=color:#a6e22e>q</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>math</span>.<span style=color:#a6e22e>Floor</span>(float64(<span style=color:#a6e22e>d</span>)<span style=color:#f92672>/</span><span style=color:#a6e22e>math</span>.<span style=color:#a6e22e>Exp2</span>(float64(<span style=color:#a6e22e>P</span>)))
        <span style=color:#a6e22e>r</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>d</span> <span style=color:#f92672>-</span> uint64(<span style=color:#a6e22e>math</span>.<span style=color:#a6e22e>Exp2</span>(float64(<span style=color:#a6e22e>P</span>))<span style=color:#f92672>*</span><span style=color:#a6e22e>q</span>)

        <span style=color:#75715e>// Encode the quotient.
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; int(<span style=color:#a6e22e>q</span>); <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
               <span style=color:#a6e22e>filter</span>.<span style=color:#a6e22e>WriteBit</span>(<span style=color:#66d9ef>true</span>)
        }
        <span style=color:#a6e22e>filter</span>.<span style=color:#a6e22e>WriteBit</span>(<span style=color:#66d9ef>false</span>)

        <span style=color:#a6e22e>filter</span>.<span style=color:#a6e22e>WriteBits</span>(<span style=color:#a6e22e>r</span>, <span style=color:#a6e22e>P</span>)
}
</code></pre></div><p>Great stuff! Now when we print out this filter, we get:</p><pre><code>71d126b85aa79c9de56d55995aa292de0484b830680a735793a8c2260113148421279906f800c3b8c94ff37681fb1fd230482518c52df57437864023833f2f801639692646ddcd7976ae4f2e2a1ef58c79b3aed6a705415255e362581692831374a5e5e70d5501cdc0a52095206a15cd2eb98ac980c22466e6945a65a5b0b0c5b32aa1e0cda2545da2c4345e049b614fcad80b9dc9c903788163822f4361bbb8755b79c276b1cf7952148de1e5ee0a92f6d70c4f522aa6877558f62b34b56ade12fa2e61023abf3e570937bf379722bc1b0dc06ffa1c5835bb651b9346a270
</code></pre><p>Apart from the first two bytes, this matches the filter we got from bitcoind exactly! Why the 2 byte difference? The BIP says that the N value needs to be encoded in CompactSize format and appended to the front of the filter so that it can be decoded by the receiver. This is done as follows:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>fd</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>filter</span>.<span style=color:#a6e22e>Bytes</span>()

<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>buffer</span> <span style=color:#a6e22e>bytes</span>.<span style=color:#a6e22e>Buffer</span>
<span style=color:#a6e22e>buffer</span>.<span style=color:#a6e22e>Grow</span>(<span style=color:#a6e22e>wire</span>.<span style=color:#a6e22e>VarIntSerializeSize</span>(uint64(<span style=color:#a6e22e>N</span>)) <span style=color:#f92672>+</span> len(<span style=color:#a6e22e>fd</span>))

<span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>wire</span>.<span style=color:#a6e22e>WriteVarInt</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>buffer</span>, <span style=color:#ae81ff>0</span>, uint64(<span style=color:#a6e22e>N</span>))
<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>err</span>
}

<span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>buffer</span>.<span style=color:#a6e22e>Write</span>(<span style=color:#a6e22e>fd</span>)
<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>err</span>
}
</code></pre></div><p>If we print out the filter now, we get one that matches the one we got from bitcoind exactly:</p><pre><code>5571d126b85aa79c9de56d55995aa292de0484b830680a735793a8c2260113148421279906f800c3b8c94ff37681fb1fd230482518c52df57437864023833f2f801639692646ddcd7976ae4f2e2a1ef58c79b3aed6a705415255e362581692831374a5e5e70d5501cdc0a52095206a15cd2eb98ac980c22466e6945a65a5b0b0c5b32aa1e0cda2545da2c4345e049b614fcad80b9dc9c903788163822f4361bbb8755b79c276b1cf7952148de1e5ee0a92f6d70c4f522aa6877558f62b34b56ade12fa2e61023abf3e570937bf379722bc1b0dc06ffa1c5835bb651b9346a270
</code></pre><p>Yay!</p><p>However, from my understanding, there is no need to add N to the filter. If you know the value of P, then you can figure out the value of N. Let’s do this now by seeing if we can take the filter above, and reconstruct the original list of numbers:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>b</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>bstream</span>.<span style=color:#a6e22e>NewBStreamReader</span>(<span style=color:#a6e22e>filter</span>)
<span style=color:#66d9ef>var</span> (
	<span style=color:#a6e22e>numbers</span> []<span style=color:#66d9ef>uint64</span>
	<span style=color:#a6e22e>prevNum</span> <span style=color:#66d9ef>uint64</span>
)

<span style=color:#66d9ef>for</span> {

        <span style=color:#75715e>// Read a quotient from the stream. Read until we encounter
</span><span style=color:#75715e></span>        <span style=color:#75715e>// a &#39;0&#39; bit indicating the end of the quotient. The number of 
</span><span style=color:#75715e></span>        <span style=color:#75715e>// &#39;1&#39;s we encounter before reaching the &#39;0&#39; defines the 
</span><span style=color:#75715e></span>        <span style=color:#75715e>// quotient.
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>q</span> <span style=color:#66d9ef>uint64</span>
        <span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>ReadBit</span>()
        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
                <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
        }

        <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>c</span> {
                <span style=color:#a6e22e>q</span><span style=color:#f92672>++</span>
                <span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>ReadBit</span>()
                <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>Is</span>(<span style=color:#a6e22e>err</span>, <span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>EOF</span>) {
                        <span style=color:#66d9ef>break</span>
                } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
                        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
                }
        }

        <span style=color:#75715e>// The following P bits are the remainder encoded as binary.
</span><span style=color:#75715e></span>        <span style=color:#a6e22e>r</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>ReadBits</span>(<span style=color:#a6e22e>P</span>)
        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>Is</span>(<span style=color:#a6e22e>err</span>, <span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>EOF</span>) {
                <span style=color:#66d9ef>break</span>
        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
                <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
        }

        <span style=color:#a6e22e>n</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>q</span><span style=color:#f92672>*</span>uint64(<span style=color:#a6e22e>math</span>.<span style=color:#a6e22e>Exp2</span>(float64(<span style=color:#a6e22e>P</span>))) <span style=color:#f92672>+</span> <span style=color:#a6e22e>r</span>

        <span style=color:#a6e22e>num</span> <span style=color:#f92672>:=</span>  <span style=color:#a6e22e>n</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>prevNum</span>
        <span style=color:#a6e22e>numbers</span> = append(<span style=color:#a6e22e>numbers</span>, <span style=color:#a6e22e>num</span>)
        <span style=color:#a6e22e>prevNum</span> = <span style=color:#a6e22e>num</span>
}

<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>numbers</span>)
</code></pre></div><p>The above produces the same list of numbers that we had before and we were able to reconstruct this without the knowledge of N. So I am not sure why it was decided that N should be added to the filter. If anyone knows why it was required to add N to the filter, please let me know!</p><p>Cool, that was fun! Thanks for reading. Yeeeeet!</p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p><a href=https://en.wikipedia.org/wiki/Bloom_filter>https://en.wikipedia.org/wiki/Bloom_filter</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2 role=doc-endnote><p><a href=https://gist.github.com/sipa/576d5f09c3b86c3b1b75598d799fc845>https://gist.github.com/sipa/576d5f09c3b86c3b1b75598d799fc845</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></div><footer class=post-footer><ul class=post-tags></ul><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share BIP158: Compact Block Filters Deep Dive on twitter" href="https://twitter.com/intent/tweet/?text=BIP158%3a%20Compact%20Block%20Filters%20Deep%20Dive&url=https%3a%2f%2fwww.ellemouton.com%2fposts%2fbip158%2f&hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share BIP158: Compact Block Filters Deep Dive on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fwww.ellemouton.com%2fposts%2fbip158%2f&title=BIP158%3a%20Compact%20Block%20Filters%20Deep%20Dive&summary=BIP158%3a%20Compact%20Block%20Filters%20Deep%20Dive&source=https%3a%2f%2fwww.ellemouton.com%2fposts%2fbip158%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share BIP158: Compact Block Filters Deep Dive on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fwww.ellemouton.com%2fposts%2fbip158%2f&title=BIP158%3a%20Compact%20Block%20Filters%20Deep%20Dive"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share BIP158: Compact Block Filters Deep Dive on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.ellemouton.com%2fposts%2fbip158%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share BIP158: Compact Block Filters Deep Dive on whatsapp" href="https://api.whatsapp.com/send?text=BIP158%3a%20Compact%20Block%20Filters%20Deep%20Dive%20-%20https%3a%2f%2fwww.ellemouton.com%2fposts%2fbip158%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share BIP158: Compact Block Filters Deep Dive on telegram" href="https://telegram.me/share/url?text=BIP158%3a%20Compact%20Block%20Filters%20Deep%20Dive&url=https%3a%2f%2fwww.ellemouton.com%2fposts%2fbip158%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer><script src=https://utteranc.es/client.js repo=ellemouton/website issue-term=pathname theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://www.ellemouton.com>Elle Mouton</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>